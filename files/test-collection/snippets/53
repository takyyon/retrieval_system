Snippets for the query:  Semantics of programming languages, including abstract specifications of data types, denotational semantics, and proofs of correctness. Hoare, A. Dijkstra, E. University of Massachusetts, Amherst, MA 01003
************************
Total Hits:  5
************************

************************
Document:  CACM-2886.html
************************


Semantic Evaluation from Left to Right

This paper describes attribute grammars and their
use for the definition of programming languages 
and compilers; a formal definition of attribute grammars
and a discussion of some of its important aspects 
are included. The paper concentrates on the evaluation
of semantic attributes in a few passes from left 
to right over the derivation tree of a program.  A
condition for an attribute grammar is given which 
assures that the semantics of any program can be evaluated
in a single pass over the derivation tree, 
and an algorithm is discussed which decides how many
passes from left to right are in general necessary, 
given the attribute grammar. These notions are explained
in terms of an example grammar which describes 
the scope rules of Algol 60.  Practical questions, such
as the relative efficiency of different evaluation 
schemes, and the ease of adapting the attribute grammar
of a given programming language to the left-to-right 
evaluation scheme are discussed.

CACM February, 1976

Bochmann, G. V.

attribute grammars, semantics of programming languages,
semantic attributes, left-to-right parsing, 
multipass compilers, semantic evaluation, semantic conditions

4.10 4.20 5.23 5.24

CA760201 JB January 5, 1978  9:54 AM

2886	4	2886
2301	5	2886
2703	5	2886
2886	5	2886
2886	5	2886
2886	5	2886
2886	6	2886


************************

************************
Document:  CACM-2411.html
************************


Tree-Structured Programs

CACM November, 1973

Wegner, E.

control structures, flowcharts, goto statements,
inductive assertion, least fix points, optimization 
in compilers, program documentation, program flow graphs,
programming language design, proof of programs, 
semantics of programming languages, structured programming.

4.12 4.22 5.24

CA731115 JB January 19, 1978  4:19 PM

2411	4	2411
2411	4	2411
2457	4	2411
2709	4	2411
2889	4	2411
2937	4	2411
2989	4	2411
3005	4	2411
3025	4	2411
3101	4	2411
2138	5	2411
2326	5	2411
2411	5	2411
2411	5	2411
2411	5	2411


************************

************************
Document:  CACM-2148.html
************************


The Composition of Semantics in Algol 68

The main features of Algol 68 are explained
from a semantic point of view.  It is shown how 
the language permits the composition of values and actions,
i.e. ultimately programs, from a minimum 
set of primitives with a few fundamental recursive rules
of composition.  The associated syntax is briefly 
reviewed.  An attempt has been made to obtain a structured
and simple introduction to both Algol 68 and 
its orthogonal design.

CACM November, 1971

Branquart, P.
Lewi, J.
Sintzoff, M.
Wodon, P. L.

programming primitives, programming languages,
Algol, semantics, recursive composition, design 
of programming languages, data structures

1.3 4.2 4.22 5.23 5.24

CA711101 JB February 2, 1978  11:49 AM

2148	5	2148
2148	5	2148
2148	5	2148
2314	5	2148
2317	5	2148
2842	5	2148
1098	6	2148
1198	6	2148
1572	6	2148
1626	6	2148
1693	6	2148
1749	6	2148
1753	6	2148
1781	6	2148
210	6	2148
2060	6	2148
2082	6	2148
2126	6	2148
2148	6	2148
2148	6	2148
2148	6	2148
2192	6	2148
3184	6	2148


************************

************************
Document:  CACM-2295.html
************************


Comment on the Composition of Semantics in Algol 68

CACM August, 1972

van der Poel, W. L.

programming primitives, programming languages,
Algol, semantics, recursive composition, design 
of programming languages, data structures

1.3 4.2 4.22 5.23 5.24

CA720807 JB January 30, 1978  9:29 AM

2295	5	2295
2295	5	2295
2295	5	2295


************************

************************
Document:  CACM-2943.html
************************


Lucid, a Nonprocedural Language with Iteration

Lucid is a formal system in which programs
can be written and proofs of programs carried out. 
 The proofs are particularly easy to follow and straightforward
to produce because the statements in 
a Lucid program are simply axioms from which the proof
proceeds by (almost) conventional logical reasoning, 
with the help of a few axioms and rules of inference
for the special Lucid functions.  As a programming 
language, Lucid is unconventional because, among other
things, the order of statements is irrelevant 
and assignment statements are equations.  Nevertheless,
Lucid programs need not look much different than 
iterative programs in a conventional structured programming
language using assignment and conditional 
statements and loops.

CACM July, 1977

Ashcrof, E. A.
Wadge, W. W.

program proving, formal systems, semantics,
iteration, structured programming

5.21 5.24

CA770709 JB December 28, 1977  8:30 AM

2021	4	2943
2222	4	2943
2227	4	2943
2315	4	2943
2326	4	2943
2470	4	2943
2732	4	2943
2865	4	2943
2896	4	2943
2943	4	2943
3014	4	2943
3068	4	2943
3077	4	2943
3143	4	2943
1834	5	2943
2943	5	2943
2943	5	2943
2943	5	2943
3150	5	2943
2060	6	2943
2704	6	2943
2842	6	2943
2939	6	2943
2940	6	2943
2941	6	2943
2943	6	2943
3073	6	2943
3148	6	2943


************************

