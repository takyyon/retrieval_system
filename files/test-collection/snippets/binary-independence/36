Snippets for the query:  Articles describing the relationship between data types and concurrency (e.g. what is the type of a process? when is a synchronization attempt between two processes "type correct"? in a message-passing system is there any notion of the types of messages?--i.e. any way to check that the sender of the message and the receiver are both treating the bit stream as some particular type)
************************
Total Hits:  133
************************

************************
Document:  CACM-1974.html
************************


NEATER2: A PL/I Source Statement Reformatter

NEATER2 accepts a PL/I source program and operates on it to produce
a reformatted version.  When in the LOGICAL mode, NEATER2 indicates
the logical structure of the source program in the indentation
pattern of its output.  Logic errors discovered through NEATER2
logical analys<B>is a</B>re discovered much more economically than is possible
through compilation and trial runs.  A number of options are
available to give the user full control over the output format and
to maximize the utility of NEATER2 as an aid during the early
stages of development of a PL/I source deck.  One option, USAGE, causes
NEATER2 to insert into each logical unit of coding a statement
which will case the number of times each one is executed to be recorded
during execution.  This feature is expected to provide a
major aid in optimization of PL/I programs.

CACM November, 1970

Conrow, K.
Smith, R. G.

logical analysis of PL/I source, reformatting of PL/I
source, documentation aid, execution time usage data

1.52 4.12 4.19 4.42

CA701104 JB February 10, 1978  8:40 AM

1974	5	1974
1974	5	1974
1974	5	1974
2971	5	1974
1835	6	1974
1974	6	1974
2534	6	1974


************************



NEATER2: A PL/I Source Statement Reformatter

NEATER2 accepts a PL/I source program and operates on it to produce
a reformatted version.  When in the LOGICAL mode, NEATER2 indicates
the logical structure of the source program in the indentation
pattern of its output.  Logic errors discovered through NEATER2
logical analysis are discovered much more economically than is possible
through compilation and trial runs.  A number of options are
available to give the user full control over the output format and
to maximize the utility of NEATER2 as an aid during the early
stages of development <B>of a</B> PL/I source deck.  One option, USAGE, causes
NEATER2 to insert into each logical unit of coding a statement
which will case the number of times each one is executed to be recorded
during execution.  This feature is expected to provide a
major aid in optimization of PL/I programs.

CACM November, 1970

Conrow, K.
Smith, R. G.

logical analysis of PL/I source, reformatting of PL/I
source, documentation aid, execution time usage data

1.52 4.12 4.19 4.42

CA701104 JB February 10, 1978  8:40 AM

1974	5	1974
1974	5	1974
1974	5	1974
2971	5	1974
1835	6	1974
1974	6	1974
2534	6	1974


************************



NEATER2: A PL/I Source Statement Reformatter

NEATER2 accepts a PL/I source program and operates on it to produce
a reformatted version.  When in the LOGICAL mode, NEATER2 indicates
the logical structure <B>of the</B> source program in the indentation
pattern of its output.  Logic errors discovered through NEATER2
logical analysis are discovered much more economically than is possible
through compilation and trial runs.  A number of options are
available to give the user full control over the output format and
to maximize the utility of NEATER2 as an aid during the early
stages of development of a PL/I source deck.  One option, USAGE, causes
NEATER2 to insert into each logical unit of coding a statement
which will case the number of times each one is executed to be recorded
during execution.  This feature is expected to provide a
major aid in optimization of PL/I programs.

CACM November, 1970

Conrow, K.
Smith, R. G.

logical analysis of PL/I source, reformatting of PL/I
source, documentation aid, execution time usage data

1.52 4.12 4.19 4.42

CA701104 JB February 10, 1978  8:40 AM

1974	5	1974
1974	5	1974
1974	5	1974
2971	5	1974
1835	6	1974
1974	6	1974
2534	6	1974


************************

************************
Document:  CACM-2219.html
************************


A Policy-Driven Scheduler for a Time-Sharing System

The service received by a process from a time-sharing
operating system can be characterized 
by a resource count SUM{w[i]R[ij]} where R[ij] is the
number of units of service received by process 
i from resource i and w[i] is the cost per unit of the
service.  Each class of users can be characterized 
by a policy function which specifies the amount of service
a user who belongs to this class should receive 
as a function of time.  Priority changes dynamically
as a function of the difference between the service 
promised to the user by the policy function and the service
he actually receives.  A scheduling and swapping 
algorithm which keeps the resource count of each process
above its policy function will provide the specified 
level of service.  Overhead can be reduced by avoiding
swaps of process which have received at least 
his level of service.  The algorithm has been implemented
<B>in a</B> general purpose operating system, and 
it has provided significantly better service to interactive
and to batch jobs than the previous scheduler.

CACM February, 1971

Bernstein, A. J.
Sharp, J. C.

scheduler, time-sharing, operating system,
resource allocation and swapping

4.32

CA710202 JB February 8, 1978  9:54 AM

2219	4	2219
2344	4	2219
1938	5	2219
2219	5	2219
2219	5	2219
2219	5	2219
2950	5	2219
3072	5	2219
1713	6	2219
2219	6	2219
2219	6	2219
2245	6	2219
2375	6	2219


************************



A Policy-Driven Scheduler for a Time-Sharing System

The service received by a process from a time-sharing
operating system can be characterized 
by a resource count SUM{w[i]R[ij]} where R[ij] <B>is the</B>
number of units of service received by process 
i from resource i and w[i] is the cost per unit of the
service.  Each class of users can be characterized 
by a policy function which specifies the amount of service
a user who belongs to this class should receive 
as a function of time.  Priority changes dynamically
as a function of the difference between the service 
promised to the user by the policy function and the service
he actually receives.  A scheduling and swapping 
algorithm which keeps the resource count of each process
above its policy function will provide the specified 
level of service.  Overhead can be reduced by avoiding
swaps of process which have received at least 
his level of service.  The algorithm has been implemented
in a general purpose operating system, and 
it has provided significantly better service to interactive
and to batch jobs than the previous scheduler.

CACM February, 1971

Bernstein, A. J.
Sharp, J. C.

scheduler, time-sharing, operating system,
resource allocation and swapping

4.32

CA710202 JB February 8, 1978  9:54 AM

2219	4	2219
2344	4	2219
1938	5	2219
2219	5	2219
2219	5	2219
2219	5	2219
2950	5	2219
3072	5	2219
1713	6	2219
2219	6	2219
2219	6	2219
2245	6	2219
2375	6	2219


************************



A Policy-Driven Scheduler for a Time-Sharing System

The service received by a process from a time-sharing
operating system can be characterized 
by a resource count SUM{w[i]R[ij]} where R[ij] is the
number of units of service received by process 
i from resource i and w[i] is the cost per unit of the
service.  Each class of users can be characterized 
by a policy function which specifies the amount of service
a user who belongs to this class should receive 
as a function of time.  Priority changes dynamically
as a function of the difference between the service 
promised to the user by the policy function <B>and the</B> service
he actually receives.  A scheduling and swapping 
algorithm which keeps the resource count of each process
above its policy function will provide the specified 
level of service.  Overhead can be reduced by avoiding
swaps of process which have received at least 
his level of service.  The algorithm has been implemented
in a general purpose operating system, and 
it has provided significantly better service to interactive
and to batch jobs than the previous scheduler.

CACM February, 1971

Bernstein, A. J.
Sharp, J. C.

scheduler, time-sharing, operating system,
resource allocation and swapping

4.32

CA710202 JB February 8, 1978  9:54 AM

2219	4	2219
2344	4	2219
1938	5	2219
2219	5	2219
2219	5	2219
2219	5	2219
2950	5	2219
3072	5	2219
1713	6	2219
2219	6	2219
2219	6	2219
2245	6	2219
2375	6	2219


************************



A Policy-Driven Scheduler for a Time-Sharing System

The service received by a process from a time-sharing
operating system can be characterized 
by a resource count SUM{w[i]R[ij]} where R[ij] is the
number of units of service received by process 
i from resource i and w[i] is the cost per unit <B>of the</B>
service.  Each class of users can be characterized 
by a policy function which specifies the amount of service
a user who belongs to this class should receive 
as a function of time.  Priority changes dynamically
as a function of the difference between the service 
promised to the user by the policy function and the service
he actually receives.  A scheduling and swapping 
algorithm which keeps the resource count of each process
above its policy function will provide the specified 
level of service.  Overhead can be reduced by avoiding
swaps of process which have received at least 
his level of service.  The algorithm has been implemented
in a general purpose operating system, and 
it has provided significantly better service to interactive
and to batch jobs than the previous scheduler.

CACM February, 1971

Bernstein, A. J.
Sharp, J. C.

scheduler, time-sharing, operating system,
resource allocation and swapping

4.32

CA710202 JB February 8, 1978  9:54 AM

2219	4	2219
2344	4	2219
1938	5	2219
2219	5	2219
2219	5	2219
2219	5	2219
2950	5	2219
3072	5	2219
1713	6	2219
2219	6	2219
2219	6	2219
2245	6	2219
2375	6	2219


************************

************************
Document:  CACM-1847.html
************************


An Algorithm for Finding a Fundamental Set of Cycles of a Graph

A fast method is presented for finding a fundamental
set of cycles for an undirected finite 
graph.  A spanning tree is grown and the vertices examined
in turn, unexamined vertices being stored 
in a pushdown list to await examination.  One stage
in the process is to take the top element v of the 
pushdown list and examine it, i.e. inspect all those
edges (v,z) of the graph for which z has not yet 
been examined.  If z <B>is a</B>lready in the tree, a fundamental
cycle is added; if not, the edge (v,z) is 
placed in the tree.  There is exactly one such stage
for each of the n vertices of the graph.  For large 
n, the store required in creases as n^2 and the time as
n^g where g depends on the type of graph involved. 
 g is bounded below by 2 and above by 3, and it is shown
that both bounds are attained.  In terms of 
storage our algorithm is similar to that of Gotlieb and
Corneil and superior to that of Welch; in terms 
of speed it is similar to that of Welch and superior
to that of Gotlieb and Corneil.  Testsshow our 
algorithm to be remarkably efficient (g=2) on random graphs.

CACM September, 1969

Paton, K.

fundamental cycle set, graph, algorithm, cycle, spanning tree

5.32

CA690909 JB February 15, 1978  4:29 PM

1847	4	1847
1961	4	1847
2052	4	1847
1504	5	1847
1847	5	1847
1847	5	1847
1847	5	1847
1961	5	1847
2177	5	1847
2763	5	1847
1369	6	1847
1504	6	1847
1847	6	1847
1847	6	1847
1847	6	1847


************************



An Algorithm for Finding a Fundamental Set of Cycles of a Graph

A fast method is presented for finding a fundamental
set of cycles for an undirected finite 
graph.  A spanning tree is grown and the vertices examined
in turn, unexamined vertices being stored 
in a pushdown list to await examination.  One stage
in the process is to take the top element v of the 
pushdown list and examine it, i.e. inspect all those
edges (v,z) of the graph for which z has not yet 
been examined.  If z is already in the tree, a fundamental
cycle is added; if not, the edge (v,z) is 
placed in the tree.  There is exactly one such stage
for each of the n vertices of the graph.  For large 
n, the store required in creases as n^2 and the time as
n^g where g depends on the <B>type of</B> graph involved. 
 g is bounded below by 2 and above by 3, and it is shown
that both bounds are attained.  In terms of 
storage our algorithm is similar to that of Gotlieb and
Corneil and superior to that of Welch; in terms 
of speed it is similar to that of Welch and superior
to that of Gotlieb and Corneil.  Testsshow our 
algorithm to be remarkably efficient (g=2) on random graphs.

CACM September, 1969

Paton, K.

fundamental cycle set, graph, algorithm, cycle, spanning tree

5.32

CA690909 JB February 15, 1978  4:29 PM

1847	4	1847
1961	4	1847
2052	4	1847
1504	5	1847
1847	5	1847
1847	5	1847
1847	5	1847
1961	5	1847
2177	5	1847
2763	5	1847
1369	6	1847
1504	6	1847
1847	6	1847
1847	6	1847
1847	6	1847


************************



An Algorithm for Finding a Fundamental Set of Cycles of a Graph

A fast method is presented for finding a fundamental
set of cycles for an undirected finite 
graph.  A spanning tree is grown and the vertices examined
in turn, unexamined vertices being stored 
in a pushdown list to await examination.  One stage
in the process is to take the top element v <B>of the</B> 
pushdown list and examine it, i.e. inspect all those
edges (v,z) of the graph for which z has not yet 
been examined.  If z is already in the tree, a fundamental
cycle is added; if not, the edge (v,z) is 
placed in the tree.  There is exactly one such stage
for each of the n vertices of the graph.  For large 
n, the store required in creases as n^2 and the time as
n^g where g depends on the type of graph involved. 
 g is bounded below by 2 and above by 3, and it is shown
that both bounds are attained.  In terms of 
storage our algorithm is similar to that of Gotlieb and
Corneil and superior to that of Welch; in terms 
of speed it is similar to that of Welch and superior
to that of Gotlieb and Corneil.  Testsshow our 
algorithm to be remarkably efficient (g=2) on random graphs.

CACM September, 1969

Paton, K.

fundamental cycle set, graph, algorithm, cycle, spanning tree

5.32

CA690909 JB February 15, 1978  4:29 PM

1847	4	1847
1961	4	1847
2052	4	1847
1504	5	1847
1847	5	1847
1847	5	1847
1847	5	1847
1961	5	1847
2177	5	1847
2763	5	1847
1369	6	1847
1504	6	1847
1847	6	1847
1847	6	1847
1847	6	1847


************************



An Algorithm for Finding a Fundamental Set of Cycles <B>of a</B> Graph

A fast method is presented for finding a fundamental
set of cycles for an undirected finite 
graph.  A spanning tree is grown and the vertices examined
in turn, unexamined vertices being stored 
in a pushdown list to await examination.  One stage
in the process is to take the top element v of the 
pushdown list and examine it, i.e. inspect all those
edges (v,z) of the graph for which z has not yet 
been examined.  If z is already in the tree, a fundamental
cycle is added; if not, the edge (v,z) is 
placed in the tree.  There is exactly one such stage
for each of the n vertices of the graph.  For large 
n, the store required in creases as n^2 and the time as
n^g where g depends on the type of graph involved. 
 g is bounded below by 2 and above by 3, and it is shown
that both bounds are attained.  In terms of 
storage our algorithm is similar to that of Gotlieb and
Corneil and superior to that of Welch; in terms 
of speed it is similar to that of Welch and superior
to that of Gotlieb and Corneil.  Testsshow our 
algorithm to be remarkably efficient (g=2) on random graphs.

CACM September, 1969

Paton, K.

fundamental cycle set, graph, algorithm, cycle, spanning tree

5.32

CA690909 JB February 15, 1978  4:29 PM

1847	4	1847
1961	4	1847
2052	4	1847
1504	5	1847
1847	5	1847
1847	5	1847
1847	5	1847
1961	5	1847
2177	5	1847
2763	5	1847
1369	6	1847
1504	6	1847
1847	6	1847
1847	6	1847
1847	6	1847


************************



An Algorithm for Finding a Fundamental Set of Cycles of a Graph

A fast method is presented for finding a fundamental
set of cycles for an undirected finite 
graph.  A spanning tree is grown and the vertices examined
in turn, unexamined vertices being stored 
in a pushdown list to await examination.  One stage
in the process is to take the top element v of the 
pushdown list and examine it, i.e. inspect all those
edges (v,z) of the graph for which z has not yet 
been examined.  If z is already in the tree, a fundamental
cycle is added; if not, the edge (v,z) is 
placed in the tree.  There is exactly one such stage
for each of the n vertices of the graph.  For large 
n, the store required in creases as n^2 and the time as
n^g where g depends on <B>the type</B> of graph involved. 
 g is bounded below by 2 and above by 3, and it is shown
that both bounds are attained.  In terms of 
storage our algorithm is similar to that of Gotlieb and
Corneil and superior to that of Welch; in terms 
of speed it is similar to that of Welch and superior
to that of Gotlieb and Corneil.  Testsshow our 
algorithm to be remarkably efficient (g=2) on random graphs.

CACM September, 1969

Paton, K.

fundamental cycle set, graph, algorithm, cycle, spanning tree

5.32

CA690909 JB February 15, 1978  4:29 PM

1847	4	1847
1961	4	1847
2052	4	1847
1504	5	1847
1847	5	1847
1847	5	1847
1847	5	1847
1961	5	1847
2177	5	1847
2763	5	1847
1369	6	1847
1504	6	1847
1847	6	1847
1847	6	1847
1847	6	1847


************************



An Algorithm for Finding a Fundamental Set of Cycles of a Graph

A fast method is presented for finding a fundamental
set of cycles for an undirected finite 
graph.  A spanning tree is grown <B>and the</B> vertices examined
in turn, unexamined vertices being stored 
in a pushdown list to await examination.  One stage
in the process is to take the top element v of the 
pushdown list and examine it, i.e. inspect all those
edges (v,z) of the graph for which z has not yet 
been examined.  If z is already in the tree, a fundamental
cycle is added; if not, the edge (v,z) is 
placed in the tree.  There is exactly one such stage
for each of the n vertices of the graph.  For large 
n, the store required in creases as n^2 and the time as
n^g where g depends on the type of graph involved. 
 g is bounded below by 2 and above by 3, and it is shown
that both bounds are attained.  In terms of 
storage our algorithm is similar to that of Gotlieb and
Corneil and superior to that of Welch; in terms 
of speed it is similar to that of Welch and superior
to that of Gotlieb and Corneil.  Testsshow our 
algorithm to be remarkably efficient (g=2) on random graphs.

CACM September, 1969

Paton, K.

fundamental cycle set, graph, algorithm, cycle, spanning tree

5.32

CA690909 JB February 15, 1978  4:29 PM

1847	4	1847
1961	4	1847
2052	4	1847
1504	5	1847
1847	5	1847
1847	5	1847
1847	5	1847
1961	5	1847
2177	5	1847
2763	5	1847
1369	6	1847
1504	6	1847
1847	6	1847
1847	6	1847
1847	6	1847


************************



An Algorithm for Finding a Fundamental Set of Cycles of a Graph

A fast method is presented for finding a fundamental
set of cycles for an undirected finite 
graph.  A spanning tree is grown and the vertices examined
in turn, unexamined vertices being stored 
<B>in a</B> pushdown list to await examination.  One stage
in the process is to take the top element v of the 
pushdown list and examine it, i.e. inspect all those
edges (v,z) of the graph for which z has not yet 
been examined.  If z is already in the tree, a fundamental
cycle is added; if not, the edge (v,z) is 
placed in the tree.  There is exactly one such stage
for each of the n vertices of the graph.  For large 
n, the store required in creases as n^2 and the time as
n^g where g depends on the type of graph involved. 
 g is bounded below by 2 and above by 3, and it is shown
that both bounds are attained.  In terms of 
storage our algorithm is similar to that of Gotlieb and
Corneil and superior to that of Welch; in terms 
of speed it is similar to that of Welch and superior
to that of Gotlieb and Corneil.  Testsshow our 
algorithm to be remarkably efficient (g=2) on random graphs.

CACM September, 1969

Paton, K.

fundamental cycle set, graph, algorithm, cycle, spanning tree

5.32

CA690909 JB February 15, 1978  4:29 PM

1847	4	1847
1961	4	1847
2052	4	1847
1504	5	1847
1847	5	1847
1847	5	1847
1847	5	1847
1961	5	1847
2177	5	1847
2763	5	1847
1369	6	1847
1504	6	1847
1847	6	1847
1847	6	1847
1847	6	1847


************************

************************
Document:  CACM-1879.html
************************


A Note on Storage Fragmentation and Program Segmentation

The main purpose of this paper is the presentation
of some of the results of a series of simulation 
experiments investigating the phenomenon of storage fragmentation.
 Two different <B>types of</B> storage fragmentation 
are distinguished: (1) external fragmentation, namely the
loss in storage utilization caused by the inability 
to make use of all available storage after it has been
fragmented into a large number of separate blocks; 
and (2) internal fragmentation, the loss of utilization
caused by rounding up a request for storage, 
rather than allocating only the exact number of words required.
 The most striking result is the apparently 
general rule that rounding up requests for storage,
to reduce the number of different sizes of blocks 
coexisting in storage, causes more loss of storage
by increased internal fragmentation than is saved 
by decreased external fragmentation.  Described also are
a method of segment allocation and an accompanying 
technique for segment addressing which take advantage
of the above result.  Evidence is presented of 
possible advantages of the method over conventional paging techniques.

CACM July, 1969

Randell, B.

storage allocation, storage fragmentation,
paging, segmentation, addressing

6.2 6.20

CA690701 JB February 17, 1978  9:46 AM

1879	4	1879
1884	4	1879
1901	4	1879
2095	4	1879
2277	4	1879
2297	4	1879
2365	4	1879
1754	5	1879
1879	5	1879
1879	5	1879
1879	5	1879
2095	5	1879
2218	5	1879
2498	5	1879
2596	5	1879
2734	5	1879
2902	5	1879
2911	5	1879
3000	5	1879
1051	6	1879
1062	6	1879
1184	6	1879
1184	6	1879
1211	6	1879
1380	6	1879
1552	6	1879
1572	6	1879
1728	6	1879
1728	6	1879
1751	6	1879
1751	6	1879
1754	6	1879
1752	6	1879
1810	6	1879
1879	6	1879
1879	6	1879
1879	6	1879
1879	6	1879
1879	6	1879
1879	6	1879
1879	6	1879
1879	6	1879
273	6	1879
2095	6	1879
2095	6	1879
2095	6	1879
2435	6	1879
2435	6	1879
2435	6	1879
2498	6	1879
2596	6	1879
2734	6	1879
2734	6	1879
2747	6	1879
2768	6	1879
2773	6	1879
2864	6	1879
2983	6	1879


************************



A Note on Storage Fragmentation and Program Segmentation

The main purpose of this paper is the presentation
of some of the results <B>of a</B> series of simulation 
experiments investigating the phenomenon of storage fragmentation.
 Two different types of storage fragmentation 
are distinguished: (1) external fragmentation, namely the
loss in storage utilization caused by the inability 
to make use of all available storage after it has been
fragmented into a large number of separate blocks; 
and (2) internal fragmentation, the loss of utilization
caused by rounding up a request for storage, 
rather than allocating only the exact number of words required.
 The most striking result is the apparently 
general rule that rounding up requests for storage,
to reduce the number of different sizes of blocks 
coexisting in storage, causes more loss of storage
by increased internal fragmentation than is saved 
by decreased external fragmentation.  Described also are
a method of segment allocation and an accompanying 
technique for segment addressing which take advantage
of the above result.  Evidence is presented of 
possible advantages of the method over conventional paging techniques.

CACM July, 1969

Randell, B.

storage allocation, storage fragmentation,
paging, segmentation, addressing

6.2 6.20

CA690701 JB February 17, 1978  9:46 AM

1879	4	1879
1884	4	1879
1901	4	1879
2095	4	1879
2277	4	1879
2297	4	1879
2365	4	1879
1754	5	1879
1879	5	1879
1879	5	1879
1879	5	1879
2095	5	1879
2218	5	1879
2498	5	1879
2596	5	1879
2734	5	1879
2902	5	1879
2911	5	1879
3000	5	1879
1051	6	1879
1062	6	1879
1184	6	1879
1184	6	1879
1211	6	1879
1380	6	1879
1552	6	1879
1572	6	1879
1728	6	1879
1728	6	1879
1751	6	1879
1751	6	1879
1754	6	1879
1752	6	1879
1810	6	1879
1879	6	1879
1879	6	1879
1879	6	1879
1879	6	1879
1879	6	1879
1879	6	1879
1879	6	1879
1879	6	1879
273	6	1879
2095	6	1879
2095	6	1879
2095	6	1879
2435	6	1879
2435	6	1879
2435	6	1879
2498	6	1879
2596	6	1879
2734	6	1879
2734	6	1879
2747	6	1879
2768	6	1879
2773	6	1879
2864	6	1879
2983	6	1879


************************



A Note on Storage Fragmentation and Program Segmentation

The main purpose of this paper is the presentation
of some <B>of the</B> results of a series of simulation 
experiments investigating the phenomenon of storage fragmentation.
 Two different types of storage fragmentation 
are distinguished: (1) external fragmentation, namely the
loss in storage utilization caused by the inability 
to make use of all available storage after it has been
fragmented into a large number of separate blocks; 
and (2) internal fragmentation, the loss of utilization
caused by rounding up a request for storage, 
rather than allocating only the exact number of words required.
 The most striking result is the apparently 
general rule that rounding up requests for storage,
to reduce the number of different sizes of blocks 
coexisting in storage, causes more loss of storage
by increased internal fragmentation than is saved 
by decreased external fragmentation.  Described also are
a method of segment allocation and an accompanying 
technique for segment addressing which take advantage
of the above result.  Evidence is presented of 
possible advantages of the method over conventional paging techniques.

CACM July, 1969

Randell, B.

storage allocation, storage fragmentation,
paging, segmentation, addressing

6.2 6.20

CA690701 JB February 17, 1978  9:46 AM

1879	4	1879
1884	4	1879
1901	4	1879
2095	4	1879
2277	4	1879
2297	4	1879
2365	4	1879
1754	5	1879
1879	5	1879
1879	5	1879
1879	5	1879
2095	5	1879
2218	5	1879
2498	5	1879
2596	5	1879
2734	5	1879
2902	5	1879
2911	5	1879
3000	5	1879
1051	6	1879
1062	6	1879
1184	6	1879
1184	6	1879
1211	6	1879
1380	6	1879
1552	6	1879
1572	6	1879
1728	6	1879
1728	6	1879
1751	6	1879
1751	6	1879
1754	6	1879
1752	6	1879
1810	6	1879
1879	6	1879
1879	6	1879
1879	6	1879
1879	6	1879
1879	6	1879
1879	6	1879
1879	6	1879
1879	6	1879
273	6	1879
2095	6	1879
2095	6	1879
2095	6	1879
2435	6	1879
2435	6	1879
2435	6	1879
2498	6	1879
2596	6	1879
2734	6	1879
2734	6	1879
2747	6	1879
2768	6	1879
2773	6	1879
2864	6	1879
2983	6	1879


************************



A Note on Storage Fragmentation and Program Segmentation

The main purpose of this paper <B>is the</B> presentation
of some of the results of a series of simulation 
experiments investigating the phenomenon of storage fragmentation.
 Two different types of storage fragmentation 
are distinguished: (1) external fragmentation, namely the
loss in storage utilization caused by the inability 
to make use of all available storage after it has been
fragmented into a large number of separate blocks; 
and (2) internal fragmentation, the loss of utilization
caused by rounding up a request for storage, 
rather than allocating only the exact number of words required.
 The most striking result is the apparently 
general rule that rounding up requests for storage,
to reduce the number of different sizes of blocks 
coexisting in storage, causes more loss of storage
by increased internal fragmentation than is saved 
by decreased external fragmentation.  Described also are
a method of segment allocation and an accompanying 
technique for segment addressing which take advantage
of the above result.  Evidence is presented of 
possible advantages of the method over conventional paging techniques.

CACM July, 1969

Randell, B.

storage allocation, storage fragmentation,
paging, segmentation, addressing

6.2 6.20

CA690701 JB February 17, 1978  9:46 AM

1879	4	1879
1884	4	1879
1901	4	1879
2095	4	1879
2277	4	1879
2297	4	1879
2365	4	1879
1754	5	1879
1879	5	1879
1879	5	1879
1879	5	1879
2095	5	1879
2218	5	1879
2498	5	1879
2596	5	1879
2734	5	1879
2902	5	1879
2911	5	1879
3000	5	1879
1051	6	1879
1062	6	1879
1184	6	1879
1184	6	1879
1211	6	1879
1380	6	1879
1552	6	1879
1572	6	1879
1728	6	1879
1728	6	1879
1751	6	1879
1751	6	1879
1754	6	1879
1752	6	1879
1810	6	1879
1879	6	1879
1879	6	1879
1879	6	1879
1879	6	1879
1879	6	1879
1879	6	1879
1879	6	1879
1879	6	1879
273	6	1879
2095	6	1879
2095	6	1879
2095	6	1879
2435	6	1879
2435	6	1879
2435	6	1879
2498	6	1879
2596	6	1879
2734	6	1879
2734	6	1879
2747	6	1879
2768	6	1879
2773	6	1879
2864	6	1879
2983	6	1879


************************

************************
Document:  CACM-3137.html
************************


A Methodology for the Design of Distributed Information Systems

A macro model of a distributed information system in presented.  The model
describes the major costs of using an information
system from the perspective <B>of the</B> end-user.  The making evident the effect of
various design and operating parameters on overall cost per transaction.
 The technique is illustrated by application to the design
of an interactive transaction processing system.

CACM April, 1979

Bucci, G.
Streeter, D.

Distributed processing, system design, cost minimization, distributed
database, interactive computing, economic modeling, transaction processing

4.32 4.33 6.2 8.1

CA790403 DH May 21, 1979  1:25 PM

3137	5	3137
3137	5	3137
3137	5	3137


************************



A Methodology for the Design of Distributed Information Systems

A macro model <B>of a</B> distributed information system in presented.  The model
describes the major costs of using an information
system from the perspective of the end-user.  The making evident the effect of
various design and operating parameters on overall cost per transaction.
 The technique is illustrated by application to the design
of an interactive transaction processing system.

CACM April, 1979

Bucci, G.
Streeter, D.

Distributed processing, system design, cost minimization, distributed
database, interactive computing, economic modeling, transaction processing

4.32 4.33 6.2 8.1

CA790403 DH May 21, 1979  1:25 PM

3137	5	3137
3137	5	3137
3137	5	3137


************************

************************
Document:  CACM-0185.html
************************


Multiprogram Scheduling Parts 1 and 2.  Introduction and Theory*

In order to exploit fully a fast computer which
possesses simultaneous processing abilities, 
it should to a large extent schedule its own workload.
 The scheduling routine must be capable of extremely 
rapid execution if it is not to prove self-defeating.
 The construction of a schedule entails determining 
which programs are to be run concurrently and which sequentially
with respect to each other.  A concise 
scheduling algorithm is described which tends to minimize
the time for executing the entire pending workload 
(or any subset of it), subject to external constraints
such as precedence, urgency, etc.  The algorithm 
<B>is a</B>pplicable to a wide class of machines.

CACM June, 1960

Codd, E. F.

CA600605 JB March 20, 1978  9:46 PM

185	5	185
185	5	185
185	5	185
1713	5	185
1901	5	185
491	5	185
168	6	185
168	6	185
168	6	185
185	6	185
185	6	185
185	6	185
196	6	185
1751	6	185
1754	6	185
46	6	185


************************



Multiprogram Scheduling Parts 1 and 2.  Introduction and Theory*

In order to exploit fully a fast computer which
possesses simultaneous processing abilities, 
it should to a large extent schedule its own workload.
 The scheduling routine must be capable of extremely 
rapid execution if it is not to prove self-defeating.
 The construction <B>of a</B> schedule entails determining 
which programs are to be run concurrently and which sequentially
with respect to each other.  A concise 
scheduling algorithm is described which tends to minimize
the time for executing the entire pending workload 
(or any subset of it), subject to external constraints
such as precedence, urgency, etc.  The algorithm 
is applicable to a wide class of machines.

CACM June, 1960

Codd, E. F.

CA600605 JB March 20, 1978  9:46 PM

185	5	185
185	5	185
185	5	185
1713	5	185
1901	5	185
491	5	185
168	6	185
168	6	185
168	6	185
185	6	185
185	6	185
185	6	185
196	6	185
1751	6	185
1754	6	185
46	6	185


************************

************************
Document:  CACM-1485.html
************************


The Structure of Programming Languages

In this paper the major components of every
programming language are identified as: (1) the 
elementary program statement, (2) mechanisms for linking
elementary statements together, (3) the means 
by which a program can obtain data inputs.  Several
alternative forms of each of these components are 
also described, compared and evaluated.  Many examples,
frequently from list processing languages, illustrate 
the forms described.  The advantages, disadvantages and
factors influencing the choice of a form of component 
for a language are discussed, <B>and the</B> paper concludes
with the suggestion that programming languages 
evolve toward one which will permit all the most convenient
ways of structuring programs, organizing 
systems and referencing data.

CACM February, 1966

Raphael, B.

CA660202 JB March 3, 1978  3:46 PM

1024	4	1485
1051	4	1485
1098	4	1485
1214	4	1485
1380	4	1485
1388	4	1485
1393	4	1485
1485	4	1485
1487	4	1485
1549	4	1485
1570	4	1485
1878	4	1485
1946	4	1485
1957	4	1485
2168	4	1485
2723	4	1485
2857	4	1485
3112	4	1485
1485	5	1485
1485	5	1485
1485	5	1485
731	5	1485


************************



The Structure of Programming Languages

In this paper the major components of every
programming language are identified as: (1) the 
elementary program statement, (2) mechanisms for linking
elementary statements together, (3) the means 
by which a program can obtain data inputs.  Several
alternative forms of each <B>of the</B>se components are 
also described, compared and evaluated.  Many examples,
frequently from list processing languages, illustrate 
the forms described.  The advantages, disadvantages and
factors influencing the choice of a form of component 
for a language are discussed, and the paper concludes
with the suggestion that programming languages 
evolve toward one which will permit all the most convenient
ways of structuring programs, organizing 
systems and referencing data.

CACM February, 1966

Raphael, B.

CA660202 JB March 3, 1978  3:46 PM

1024	4	1485
1051	4	1485
1098	4	1485
1214	4	1485
1380	4	1485
1388	4	1485
1393	4	1485
1485	4	1485
1487	4	1485
1549	4	1485
1570	4	1485
1878	4	1485
1946	4	1485
1957	4	1485
2168	4	1485
2723	4	1485
2857	4	1485
3112	4	1485
1485	5	1485
1485	5	1485
1485	5	1485
731	5	1485


************************



The Structure of Programming Languages

In this paper the major components of every
programming language are identified as: (1) the 
elementary program statement, (2) mechanisms for linking
elementary statements together, (3) the means 
by which a program can obtain data inputs.  Several
alternative forms of each of these components are 
also described, compared and evaluated.  Many examples,
frequently from list processing languages, illustrate 
the forms described.  The advantages, disadvantages and
factors influencing the choice <B>of a</B> form of component 
for a language are discussed, and the paper concludes
with the suggestion that programming languages 
evolve toward one which will permit all the most convenient
ways of structuring programs, organizing 
systems and referencing data.

CACM February, 1966

Raphael, B.

CA660202 JB March 3, 1978  3:46 PM

1024	4	1485
1051	4	1485
1098	4	1485
1214	4	1485
1380	4	1485
1388	4	1485
1393	4	1485
1485	4	1485
1487	4	1485
1549	4	1485
1570	4	1485
1878	4	1485
1946	4	1485
1957	4	1485
2168	4	1485
2723	4	1485
2857	4	1485
3112	4	1485
1485	5	1485
1485	5	1485
1485	5	1485
731	5	1485


************************

************************
Document:  CACM-1439.html
************************


Mechanization of the Curve Fitting Process: DATAN

A process for fitting a curve to approximate data
<B>and the</B> problem it creates for the engineer-programmer 
is defined.  An approach has also been defined and a system
has been written for the SRU 1107 to mechanize 
a major portion of this process.  The techniques developed
to accomplish the mechanization are largely 
empirical, and are dependent for their information
only on the actual data points.

CACM April, 1966

Simonsen, R. H.
Anketell, D. L.

CA660410 JB March 3, 1978  10:26 AM

1439	5	1439
1439	5	1439
1439	5	1439


************************



Mechanization <B>of the</B> Curve Fitting Process: DATAN

A process for fitting a curve to approximate data
and the problem it creates for the engineer-programmer 
is defined.  An approach has also been defined and a system
has been written for the SRU 1107 to mechanize 
a major portion of this process.  The techniques developed
to accomplish the mechanization are largely 
empirical, and are dependent for their information
only on the actual data points.

CACM April, 1966

Simonsen, R. H.
Anketell, D. L.

CA660410 JB March 3, 1978  10:26 AM

1439	5	1439
1439	5	1439
1439	5	1439


************************

************************
Document:  CACM-1425.html
************************


Flow Diagrams, Turing Machines And
Languages With Only Two Formation Rules

In the first part of the paper, flow diagrams
are introduced to represent inter al. mappings 
<B>of a</B> set into itself.  Although not every diagram is
decomposable into a finite number of given base 
diagrams, this becomes true at a semantical level due
to a suitable extension of the given set and of 
the basic mappings defined in it.  Two normalization
methods of flow diagrams are given.  The first has 
three base diagrams; the second, only two.  In the second
part of the paper, the second method is applied 
to the theory of Turing machines.  With every Turing
machine provided with a two-way half-tape, there 
is associated a similar machine, doing essentially
the same job, but working on a tape obtained from 
the first one by interspersing alternate blank squares.
 The new machine belongs to the family, elsewhere 
introduced, generated by composition and iteration from
the two machines L and R.  That family is a proper 
subfamily of the whole family of Turing machines.

CACM May, 1966

Bohm, C.
Jacopini, G.

CA660512 JB March 3, 1978  9:35 AM

1425	4	1425
1781	4	1425
438	4	1425
762	4	1425
249	5	1425
1425	5	1425
1425	5	1425
1425	5	1425
2709	5	1425
2802	5	1425
3004	5	1425
1425	6	1425
1425	6	1425
1425	6	1425
2138	6	1425
2204	6	1425
2247	6	1425
2356	6	1425
2456	6	1425
2456	6	1425
2477	6	1425
3186	6	1425


************************



Flow Diagrams, Turing Machines And
Languages With Only Two Formation Rules

In the first part <B>of the</B> paper, flow diagrams
are introduced to represent inter al. mappings 
of a set into itself.  Although not every diagram is
decomposable into a finite number of given base 
diagrams, this becomes true at a semantical level due
to a suitable extension of the given set and of 
the basic mappings defined in it.  Two normalization
methods of flow diagrams are given.  The first has 
three base diagrams; the second, only two.  In the second
part of the paper, the second method is applied 
to the theory of Turing machines.  With every Turing
machine provided with a two-way half-tape, there 
is associated a similar machine, doing essentially
the same job, but working on a tape obtained from 
the first one by interspersing alternate blank squares.
 The new machine belongs to the family, elsewhere 
introduced, generated by composition and iteration from
the two machines L and R.  That family is a proper 
subfamily of the whole family of Turing machines.

CACM May, 1966

Bohm, C.
Jacopini, G.

CA660512 JB March 3, 1978  9:35 AM

1425	4	1425
1781	4	1425
438	4	1425
762	4	1425
249	5	1425
1425	5	1425
1425	5	1425
1425	5	1425
2709	5	1425
2802	5	1425
3004	5	1425
1425	6	1425
1425	6	1425
1425	6	1425
2138	6	1425
2204	6	1425
2247	6	1425
2356	6	1425
2456	6	1425
2456	6	1425
2477	6	1425
3186	6	1425


************************



Flow Diagrams, Turing Machines And
Languages With Only Two Formation Rules

In the first part of the paper, flow diagrams
are introduced to represent inter al. mappings 
of a set into itself.  Although not every diagram is
decomposable into a finite number of given base 
diagrams, this becomes true at a semantical level due
to a suitable extension of the given set and of 
the basic mappings defined in it.  Two normalization
methods of flow diagrams are given.  The first has 
three base diagrams; the second, only two.  In the second
part of the paper, the second method <B>is a</B>pplied 
to the theory of Turing machines.  With every Turing
machine provided with a two-way half-tape, there 
is associated a similar machine, doing essentially
the same job, but working on a tape obtained from 
the first one by interspersing alternate blank squares.
 The new machine belongs to the family, elsewhere 
introduced, generated by composition and iteration from
the two machines L and R.  That family is a proper 
subfamily of the whole family of Turing machines.

CACM May, 1966

Bohm, C.
Jacopini, G.

CA660512 JB March 3, 1978  9:35 AM

1425	4	1425
1781	4	1425
438	4	1425
762	4	1425
249	5	1425
1425	5	1425
1425	5	1425
1425	5	1425
2709	5	1425
2802	5	1425
3004	5	1425
1425	6	1425
1425	6	1425
1425	6	1425
2138	6	1425
2204	6	1425
2247	6	1425
2356	6	1425
2456	6	1425
2456	6	1425
2477	6	1425
3186	6	1425


************************

************************
Document:  CACM-1614.html
************************


A Proposal for Definitions in ALGOL

An extension to ALGOL is proposed for adding
new data types and operators to the language. 
 Definitions may occur in any block heading and terminate
with the block.  They are an integral part 
<B>of the</B> program and are not fixed in the language.  Even
the behavior of existing operators may be redefined. 
 The processing of text containing defined contexts features
a "replacement rule" that eliminates unnecessary 
iterations and temporary storage.  Examples of definition sets
are given for real and complex matrices, 
complex numbers, file processing, and list manipulation.

CACM April, 1967

Galler, B. A.
Perlis, A. J.

CA670401 JB February 28, 1978  11:43 AM

1086	4	1614
1132	4	1614
1234	4	1614
1263	4	1614
1265	4	1614
1270	4	1614
1323	4	1614
1358	4	1614
1379	4	1614
1380	4	1614
1453	4	1614
1464	4	1614
1484	4	1614
1491	4	1614
1498	4	1614
1613	4	1614
1614	4	1614
1614	4	1614
1781	4	1614
1825	4	1614
1860	4	1614
2083	4	1614
2178	4	1614
2179	4	1614
2252	4	1614
2253	4	1614
2325	4	1614
2341	4	1614
2546	4	1614
2557	4	1614
2645	4	1614
2652	4	1614
2684	4	1614
2842	4	1614
2929	4	1614
2934	4	1614
3069	4	1614
669	4	1614
679	4	1614
691	4	1614
761	4	1614
949	4	1614
989	4	1614
1614	5	1614
1614	5	1614
1614	5	1614
1693	5	1614
1781	5	1614
1824	5	1614
1861	5	1614
2126	5	1614
437	5	1614
3184	5	1614
823	6	1614
123	6	1614
196	6	1614
196	6	1614
919	6	1614
990	6	1614
1007	6	1614
1046	6	1614
1131	6	1614
1139	6	1614
1140	6	1614
1149	6	1614
1198	6	1614
1215	6	1614
1223	6	1614
1265	6	1614
1303	6	1614
1323	6	1614
1358	6	1614
1358	6	1614
1366	6	1614
1421	6	1614
1421	6	1614
1460	6	1614
1462	6	1614
1463	6	1614
1467	6	1614
1468	6	1614
1477	6	1614
1477	6	1614
1491	6	1614
1491	6	1614
1496	6	1614
1531	6	1614
1535	6	1614
1565	6	1614
1601	6	1614
1602	6	1614
1613	6	1614
1614	6	1614
1614	6	1614
1614	6	1614
1614	6	1614
1614	6	1614
1626	6	1614
1641	6	1614
1693	6	1614
1781	6	1614
1781	6	1614
1787	6	1614
1788	6	1614
205	6	1614
224	6	1614
249	6	1614
288	6	1614
316	6	1614
381	6	1614
398	6	1614
11	6	1614
404	6	1614
404	6	1614
404	6	1614
408	6	1614
410	6	1614
463	6	1614
464	6	1614
483	6	1614
3184	6	1614
3188	6	1614
584	6	1614
600	6	1614
680	6	1614
691	6	1614
763	6	1614
799	6	1614


************************



A Proposal for Definitions in ALGOL

An extension to ALGOL is proposed for adding
new <B>data types</B> and operators to the language. 
 Definitions may occur in any block heading and terminate
with the block.  They are an integral part 
of the program and are not fixed in the language.  Even
the behavior of existing operators may be redefined. 
 The processing of text containing defined contexts features
a "replacement rule" that eliminates unnecessary 
iterations and temporary storage.  Examples of definition sets
are given for real and complex matrices, 
complex numbers, file processing, and list manipulation.

CACM April, 1967

Galler, B. A.
Perlis, A. J.

CA670401 JB February 28, 1978  11:43 AM

1086	4	1614
1132	4	1614
1234	4	1614
1263	4	1614
1265	4	1614
1270	4	1614
1323	4	1614
1358	4	1614
1379	4	1614
1380	4	1614
1453	4	1614
1464	4	1614
1484	4	1614
1491	4	1614
1498	4	1614
1613	4	1614
1614	4	1614
1614	4	1614
1781	4	1614
1825	4	1614
1860	4	1614
2083	4	1614
2178	4	1614
2179	4	1614
2252	4	1614
2253	4	1614
2325	4	1614
2341	4	1614
2546	4	1614
2557	4	1614
2645	4	1614
2652	4	1614
2684	4	1614
2842	4	1614
2929	4	1614
2934	4	1614
3069	4	1614
669	4	1614
679	4	1614
691	4	1614
761	4	1614
949	4	1614
989	4	1614
1614	5	1614
1614	5	1614
1614	5	1614
1693	5	1614
1781	5	1614
1824	5	1614
1861	5	1614
2126	5	1614
437	5	1614
3184	5	1614
823	6	1614
123	6	1614
196	6	1614
196	6	1614
919	6	1614
990	6	1614
1007	6	1614
1046	6	1614
1131	6	1614
1139	6	1614
1140	6	1614
1149	6	1614
1198	6	1614
1215	6	1614
1223	6	1614
1265	6	1614
1303	6	1614
1323	6	1614
1358	6	1614
1358	6	1614
1366	6	1614
1421	6	1614
1421	6	1614
1460	6	1614
1462	6	1614
1463	6	1614
1467	6	1614
1468	6	1614
1477	6	1614
1477	6	1614
1491	6	1614
1491	6	1614
1496	6	1614
1531	6	1614
1535	6	1614
1565	6	1614
1601	6	1614
1602	6	1614
1613	6	1614
1614	6	1614
1614	6	1614
1614	6	1614
1614	6	1614
1614	6	1614
1626	6	1614
1641	6	1614
1693	6	1614
1781	6	1614
1781	6	1614
1787	6	1614
1788	6	1614
205	6	1614
224	6	1614
249	6	1614
288	6	1614
316	6	1614
381	6	1614
398	6	1614
11	6	1614
404	6	1614
404	6	1614
404	6	1614
408	6	1614
410	6	1614
463	6	1614
464	6	1614
483	6	1614
3184	6	1614
3188	6	1614
584	6	1614
600	6	1614
680	6	1614
691	6	1614
763	6	1614
799	6	1614


************************



A Proposal for Definitions in ALGOL

An extension to ALGOL is proposed for adding
new data types and operators to the language. 
 Definitions may occur <B>in a</B>ny block heading and terminate
with the block.  They are an integral part 
of the program and are not fixed in the language.  Even
the behavior of existing operators may be redefined. 
 The processing of text containing defined contexts features
a "replacement rule" that eliminates unnecessary 
iterations and temporary storage.  Examples of definition sets
are given for real and complex matrices, 
complex numbers, file processing, and list manipulation.

CACM April, 1967

Galler, B. A.
Perlis, A. J.

CA670401 JB February 28, 1978  11:43 AM

1086	4	1614
1132	4	1614
1234	4	1614
1263	4	1614
1265	4	1614
1270	4	1614
1323	4	1614
1358	4	1614
1379	4	1614
1380	4	1614
1453	4	1614
1464	4	1614
1484	4	1614
1491	4	1614
1498	4	1614
1613	4	1614
1614	4	1614
1614	4	1614
1781	4	1614
1825	4	1614
1860	4	1614
2083	4	1614
2178	4	1614
2179	4	1614
2252	4	1614
2253	4	1614
2325	4	1614
2341	4	1614
2546	4	1614
2557	4	1614
2645	4	1614
2652	4	1614
2684	4	1614
2842	4	1614
2929	4	1614
2934	4	1614
3069	4	1614
669	4	1614
679	4	1614
691	4	1614
761	4	1614
949	4	1614
989	4	1614
1614	5	1614
1614	5	1614
1614	5	1614
1693	5	1614
1781	5	1614
1824	5	1614
1861	5	1614
2126	5	1614
437	5	1614
3184	5	1614
823	6	1614
123	6	1614
196	6	1614
196	6	1614
919	6	1614
990	6	1614
1007	6	1614
1046	6	1614
1131	6	1614
1139	6	1614
1140	6	1614
1149	6	1614
1198	6	1614
1215	6	1614
1223	6	1614
1265	6	1614
1303	6	1614
1323	6	1614
1358	6	1614
1358	6	1614
1366	6	1614
1421	6	1614
1421	6	1614
1460	6	1614
1462	6	1614
1463	6	1614
1467	6	1614
1468	6	1614
1477	6	1614
1477	6	1614
1491	6	1614
1491	6	1614
1496	6	1614
1531	6	1614
1535	6	1614
1565	6	1614
1601	6	1614
1602	6	1614
1613	6	1614
1614	6	1614
1614	6	1614
1614	6	1614
1614	6	1614
1614	6	1614
1626	6	1614
1641	6	1614
1693	6	1614
1781	6	1614
1781	6	1614
1787	6	1614
1788	6	1614
205	6	1614
224	6	1614
249	6	1614
288	6	1614
316	6	1614
381	6	1614
398	6	1614
11	6	1614
404	6	1614
404	6	1614
404	6	1614
408	6	1614
410	6	1614
463	6	1614
464	6	1614
483	6	1614
3184	6	1614
3188	6	1614
584	6	1614
600	6	1614
680	6	1614
691	6	1614
763	6	1614
799	6	1614


************************



A Proposal for Definitions in ALGOL

An extension to ALGOL is proposed for adding
new data <B>types and</B> operators to the language. 
 Definitions may occur in any block heading and terminate
with the block.  They are an integral part 
of the program and are not fixed in the language.  Even
the behavior of existing operators may be redefined. 
 The processing of text containing defined contexts features
a "replacement rule" that eliminates unnecessary 
iterations and temporary storage.  Examples of definition sets
are given for real and complex matrices, 
complex numbers, file processing, and list manipulation.

CACM April, 1967

Galler, B. A.
Perlis, A. J.

CA670401 JB February 28, 1978  11:43 AM

1086	4	1614
1132	4	1614
1234	4	1614
1263	4	1614
1265	4	1614
1270	4	1614
1323	4	1614
1358	4	1614
1379	4	1614
1380	4	1614
1453	4	1614
1464	4	1614
1484	4	1614
1491	4	1614
1498	4	1614
1613	4	1614
1614	4	1614
1614	4	1614
1781	4	1614
1825	4	1614
1860	4	1614
2083	4	1614
2178	4	1614
2179	4	1614
2252	4	1614
2253	4	1614
2325	4	1614
2341	4	1614
2546	4	1614
2557	4	1614
2645	4	1614
2652	4	1614
2684	4	1614
2842	4	1614
2929	4	1614
2934	4	1614
3069	4	1614
669	4	1614
679	4	1614
691	4	1614
761	4	1614
949	4	1614
989	4	1614
1614	5	1614
1614	5	1614
1614	5	1614
1693	5	1614
1781	5	1614
1824	5	1614
1861	5	1614
2126	5	1614
437	5	1614
3184	5	1614
823	6	1614
123	6	1614
196	6	1614
196	6	1614
919	6	1614
990	6	1614
1007	6	1614
1046	6	1614
1131	6	1614
1139	6	1614
1140	6	1614
1149	6	1614
1198	6	1614
1215	6	1614
1223	6	1614
1265	6	1614
1303	6	1614
1323	6	1614
1358	6	1614
1358	6	1614
1366	6	1614
1421	6	1614
1421	6	1614
1460	6	1614
1462	6	1614
1463	6	1614
1467	6	1614
1468	6	1614
1477	6	1614
1477	6	1614
1491	6	1614
1491	6	1614
1496	6	1614
1531	6	1614
1535	6	1614
1565	6	1614
1601	6	1614
1602	6	1614
1613	6	1614
1614	6	1614
1614	6	1614
1614	6	1614
1614	6	1614
1614	6	1614
1626	6	1614
1641	6	1614
1693	6	1614
1781	6	1614
1781	6	1614
1787	6	1614
1788	6	1614
205	6	1614
224	6	1614
249	6	1614
288	6	1614
316	6	1614
381	6	1614
398	6	1614
11	6	1614
404	6	1614
404	6	1614
404	6	1614
408	6	1614
410	6	1614
463	6	1614
464	6	1614
483	6	1614
3184	6	1614
3188	6	1614
584	6	1614
600	6	1614
680	6	1614
691	6	1614
763	6	1614
799	6	1614


************************

************************
Document:  CACM-2842.html
************************


The Denotational Semantics of Programming Languages

This paper is a tutorial introduction to the
theory of programming language semantics developed 
by D. Scott and C. Strachey.  The application <B>of the</B> theory
to formal language specification is demonstrated 
and other applications are surveyed. The first language
considered, LOOP, is very elementary and its 
definition merely introduces the notation and methodology
of the approach.  Then the semantic concepts
of environments, stores, and continuations are introduced
to model classes of programming language features 
and the underlying mathematical theory of computation
due to Scott is motivated and outlined.  Finally, 
the paper presents a formal definition of the language GEDANKEN.

CACM August, 1976

Tennent, R. D.

semantics, programming language, applicative, imperative,
environment, store, continuation, theory 
of computation, higher-order function, recursive definition, LOOP, GEDANKEN

4.22 5.24

CA760802 JB January 4, 1978  10:33 AM

1024	4	2842
1051	4	2842
1086	4	2842
1102	4	2842
1132	4	2842
1132	4	2842
1234	4	2842
1263	4	2842
1265	4	2842
1270	4	2842
1323	4	2842
1358	4	2842
1379	4	2842
1380	4	2842
1390	4	2842
1453	4	2842
1464	4	2842
1484	4	2842
1486	4	2842
1491	4	2842
1498	4	2842
1549	4	2842
1613	4	2842
1614	4	2842
1706	4	2842
1781	4	2842
1825	4	2842
1826	4	2842
1860	4	2842
1878	4	2842
378	4	2842
2060	4	2842
2083	4	2842
2155	4	2842
2155	4	2842
2168	4	2842
2178	4	2842
2179	4	2842
2252	4	2842
2294	4	2842
2314	4	2842
2317	4	2842
2325	4	2842
2326	4	2842
2341	4	2842
2457	4	2842
2546	4	2842
2558	4	2842
2645	4	2842
2652	4	2842
2684	4	2842
2719	4	2842
2723	4	2842
2838	4	2842
2842	4	2842
2842	4	2842
2842	4	2842
2842	4	2842
2842	4	2842
2855	4	2842
2879	4	2842
2903	4	2842
2929	4	2842
2934	4	2842
3069	4	2842
3077	4	2842
3077	4	2842
3080	4	2842
3106	4	2842
3150	4	2842
627	4	2842
669	4	2842
679	4	2842
691	4	2842
761	4	2842
106	4	2842
949	4	2842
989	4	2842
210	5	2842
2060	5	2842
2148	5	2842
2192	5	2842
2837	5	2842
2842	5	2842
2842	5	2842
2842	5	2842
3150	5	2842
3184	5	2842
2060	6	2842
2704	6	2842
2784	6	2842
2842	6	2842
2842	6	2842
2939	6	2842
2940	6	2842
2941	6	2842
2943	6	2842
3073	6	2842
3148	6	2842


************************



The Denotational Semantics of Programming Languages

This paper <B>is a</B> tutorial introduction to the
theory of programming language semantics developed 
by D. Scott and C. Strachey.  The application of the theory
to formal language specification is demonstrated 
and other applications are surveyed. The first language
considered, LOOP, is very elementary and its 
definition merely introduces the notation and methodology
of the approach.  Then the semantic concepts
of environments, stores, and continuations are introduced
to model classes of programming language features 
and the underlying mathematical theory of computation
due to Scott is motivated and outlined.  Finally, 
the paper presents a formal definition of the language GEDANKEN.

CACM August, 1976

Tennent, R. D.

semantics, programming language, applicative, imperative,
environment, store, continuation, theory 
of computation, higher-order function, recursive definition, LOOP, GEDANKEN

4.22 5.24

CA760802 JB January 4, 1978  10:33 AM

1024	4	2842
1051	4	2842
1086	4	2842
1102	4	2842
1132	4	2842
1132	4	2842
1234	4	2842
1263	4	2842
1265	4	2842
1270	4	2842
1323	4	2842
1358	4	2842
1379	4	2842
1380	4	2842
1390	4	2842
1453	4	2842
1464	4	2842
1484	4	2842
1486	4	2842
1491	4	2842
1498	4	2842
1549	4	2842
1613	4	2842
1614	4	2842
1706	4	2842
1781	4	2842
1825	4	2842
1826	4	2842
1860	4	2842
1878	4	2842
378	4	2842
2060	4	2842
2083	4	2842
2155	4	2842
2155	4	2842
2168	4	2842
2178	4	2842
2179	4	2842
2252	4	2842
2294	4	2842
2314	4	2842
2317	4	2842
2325	4	2842
2326	4	2842
2341	4	2842
2457	4	2842
2546	4	2842
2558	4	2842
2645	4	2842
2652	4	2842
2684	4	2842
2719	4	2842
2723	4	2842
2838	4	2842
2842	4	2842
2842	4	2842
2842	4	2842
2842	4	2842
2842	4	2842
2855	4	2842
2879	4	2842
2903	4	2842
2929	4	2842
2934	4	2842
3069	4	2842
3077	4	2842
3077	4	2842
3080	4	2842
3106	4	2842
3150	4	2842
627	4	2842
669	4	2842
679	4	2842
691	4	2842
761	4	2842
106	4	2842
949	4	2842
989	4	2842
210	5	2842
2060	5	2842
2148	5	2842
2192	5	2842
2837	5	2842
2842	5	2842
2842	5	2842
2842	5	2842
3150	5	2842
3184	5	2842
2060	6	2842
2704	6	2842
2784	6	2842
2842	6	2842
2842	6	2842
2939	6	2842
2940	6	2842
2941	6	2842
2943	6	2842
3073	6	2842
3148	6	2842


************************



The Denotational Semantics of Programming Languages

This paper is a tutorial introduction to the
theory of programming language semantics developed 
by D. Scott and C. Strachey.  The application of the theory
to formal language specification is demonstrated 
and other applications are surveyed. The first language
considered, LOOP, is very elementary and its 
definition merely introduces the notation and methodology
of the approach.  Then the semantic concepts
of environments, stores, and continuations are introduced
to model classes of programming language features 
<B>and the</B> underlying mathematical theory of computation
due to Scott is motivated and outlined.  Finally, 
the paper presents a formal definition of the language GEDANKEN.

CACM August, 1976

Tennent, R. D.

semantics, programming language, applicative, imperative,
environment, store, continuation, theory 
of computation, higher-order function, recursive definition, LOOP, GEDANKEN

4.22 5.24

CA760802 JB January 4, 1978  10:33 AM

1024	4	2842
1051	4	2842
1086	4	2842
1102	4	2842
1132	4	2842
1132	4	2842
1234	4	2842
1263	4	2842
1265	4	2842
1270	4	2842
1323	4	2842
1358	4	2842
1379	4	2842
1380	4	2842
1390	4	2842
1453	4	2842
1464	4	2842
1484	4	2842
1486	4	2842
1491	4	2842
1498	4	2842
1549	4	2842
1613	4	2842
1614	4	2842
1706	4	2842
1781	4	2842
1825	4	2842
1826	4	2842
1860	4	2842
1878	4	2842
378	4	2842
2060	4	2842
2083	4	2842
2155	4	2842
2155	4	2842
2168	4	2842
2178	4	2842
2179	4	2842
2252	4	2842
2294	4	2842
2314	4	2842
2317	4	2842
2325	4	2842
2326	4	2842
2341	4	2842
2457	4	2842
2546	4	2842
2558	4	2842
2645	4	2842
2652	4	2842
2684	4	2842
2719	4	2842
2723	4	2842
2838	4	2842
2842	4	2842
2842	4	2842
2842	4	2842
2842	4	2842
2842	4	2842
2855	4	2842
2879	4	2842
2903	4	2842
2929	4	2842
2934	4	2842
3069	4	2842
3077	4	2842
3077	4	2842
3080	4	2842
3106	4	2842
3150	4	2842
627	4	2842
669	4	2842
679	4	2842
691	4	2842
761	4	2842
106	4	2842
949	4	2842
989	4	2842
210	5	2842
2060	5	2842
2148	5	2842
2192	5	2842
2837	5	2842
2842	5	2842
2842	5	2842
2842	5	2842
3150	5	2842
3184	5	2842
2060	6	2842
2704	6	2842
2784	6	2842
2842	6	2842
2842	6	2842
2939	6	2842
2940	6	2842
2941	6	2842
2943	6	2842
3073	6	2842
3148	6	2842


************************

************************
Document:  CACM-2889.html
************************


Performance of Height-Balanced Trees

This paper presents the results of simulations
that investigate the performance of height-balanced 
(HB[k]) trees.  It is shown that the only statistic
of HB[1] trees (AVL trees) that is a function of 
the size <B>of the</B> tree is the time to search for an item
in the tree.  For sufficiently large trees, the 
execution times of all procedures for maintaining HB[1]
trees are independent of the size of the tree. 
 In particular, an average of .465 restructures are required
per insertion, with an average of 2.78 nodes 
revisited to restore the HB[1] property; an average of
 .214 restructures are required per deletion, with 
an average of 1.91 nodes revisited to restore the HB[1]
property.  Moreover,the execution times of procedures 
for maintaining HB[k] trees, for k>1, are also independent
of the size of the tree except for the average 
number of nodes revisited on a delete operation in
order to restore the HB[k] property on trace back. 
 The cost of maintaining HB[k] trees drops sharply as the
allowable imbalance (k) increases.  Both analytical 
and experimental results that show the cost of maintaining
HB[k] trees as a function of k are discussed.

CACM January, 1976

Karlton, P. L.
Fuller, S. H.
Scroggs, R. E.
Kaehler, E. B.

HB[k] trees, balanced trees, AVL trees,
information storage and retrieval, searching

3.7 3.72 3.74 4.49 5.39

CA760104 JB January 5, 1978  10:27 AM

2411	4	2889
2455	4	2889
2493	4	2889
2709	4	2889
2889	4	2889
2889	4	2889
2889	4	2889
2937	4	2889
2968	4	2889
2968	4	2889
2989	4	2889
3005	4	2889
3025	4	2889
3042	4	2889
3101	4	2889
2138	5	2889
2388	5	2889
2455	5	2889
2839	5	2889
2889	5	2889
2889	5	2889
2889	5	2889
3042	5	2889
3096	5	2889
3163	5	2889
2455	6	2889
2839	6	2889
2839	6	2889
2839	6	2889
2889	6	2889
2889	6	2889
2889	6	2889
2889	6	2889
2968	6	2889
3009	6	2889
3009	6	2889
3065	6	2889
3096	6	2889


************************



Performance of Height-Balanced Trees

This paper presents the results of simulations
that investigate the performance of height-balanced 
(HB[k]) trees.  It is shown <B>that the</B> only statistic
of HB[1] trees (AVL trees) that is a function of 
the size of the tree is the time to search for an item
in the tree.  For sufficiently large trees, the 
execution times of all procedures for maintaining HB[1]
trees are independent of the size of the tree. 
 In particular, an average of .465 restructures are required
per insertion, with an average of 2.78 nodes 
revisited to restore the HB[1] property; an average of
 .214 restructures are required per deletion, with 
an average of 1.91 nodes revisited to restore the HB[1]
property.  Moreover,the execution times of procedures 
for maintaining HB[k] trees, for k>1, are also independent
of the size of the tree except for the average 
number of nodes revisited on a delete operation in
order to restore the HB[k] property on trace back. 
 The cost of maintaining HB[k] trees drops sharply as the
allowable imbalance (k) increases.  Both analytical 
and experimental results that show the cost of maintaining
HB[k] trees as a function of k are discussed.

CACM January, 1976

Karlton, P. L.
Fuller, S. H.
Scroggs, R. E.
Kaehler, E. B.

HB[k] trees, balanced trees, AVL trees,
information storage and retrieval, searching

3.7 3.72 3.74 4.49 5.39

CA760104 JB January 5, 1978  10:27 AM

2411	4	2889
2455	4	2889
2493	4	2889
2709	4	2889
2889	4	2889
2889	4	2889
2889	4	2889
2937	4	2889
2968	4	2889
2968	4	2889
2989	4	2889
3005	4	2889
3025	4	2889
3042	4	2889
3101	4	2889
2138	5	2889
2388	5	2889
2455	5	2889
2839	5	2889
2889	5	2889
2889	5	2889
2889	5	2889
3042	5	2889
3096	5	2889
3163	5	2889
2455	6	2889
2839	6	2889
2839	6	2889
2839	6	2889
2889	6	2889
2889	6	2889
2889	6	2889
2889	6	2889
2968	6	2889
3009	6	2889
3009	6	2889
3065	6	2889
3096	6	2889


************************



Performance of Height-Balanced Trees

This paper presents the results of simulations
that investigate the performance of height-balanced 
(HB[k]) trees.  It is shown that the only statistic
of HB[1] trees (AVL trees) that is a function of 
the size of the tree is the time to search for an item
in the tree.  For sufficiently large trees, the 
execution times <B>of a</B>ll procedures for maintaining HB[1]
trees are independent of the size of the tree. 
 In particular, an average of .465 restructures are required
per insertion, with an average of 2.78 nodes 
revisited to restore the HB[1] property; an average of
 .214 restructures are required per deletion, with 
an average of 1.91 nodes revisited to restore the HB[1]
property.  Moreover,the execution times of procedures 
for maintaining HB[k] trees, for k>1, are also independent
of the size of the tree except for the average 
number of nodes revisited on a delete operation in
order to restore the HB[k] property on trace back. 
 The cost of maintaining HB[k] trees drops sharply as the
allowable imbalance (k) increases.  Both analytical 
and experimental results that show the cost of maintaining
HB[k] trees as a function of k are discussed.

CACM January, 1976

Karlton, P. L.
Fuller, S. H.
Scroggs, R. E.
Kaehler, E. B.

HB[k] trees, balanced trees, AVL trees,
information storage and retrieval, searching

3.7 3.72 3.74 4.49 5.39

CA760104 JB January 5, 1978  10:27 AM

2411	4	2889
2455	4	2889
2493	4	2889
2709	4	2889
2889	4	2889
2889	4	2889
2889	4	2889
2937	4	2889
2968	4	2889
2968	4	2889
2989	4	2889
3005	4	2889
3025	4	2889
3042	4	2889
3101	4	2889
2138	5	2889
2388	5	2889
2455	5	2889
2839	5	2889
2889	5	2889
2889	5	2889
2889	5	2889
3042	5	2889
3096	5	2889
3163	5	2889
2455	6	2889
2839	6	2889
2839	6	2889
2839	6	2889
2889	6	2889
2889	6	2889
2889	6	2889
2889	6	2889
2968	6	2889
3009	6	2889
3009	6	2889
3065	6	2889
3096	6	2889


************************



Performance of Height-Balanced Trees

This paper presents the results of simulations
that investigate the performance of height-balanced 
(HB[k]) trees.  It is shown that the only statistic
of HB[1] trees (AVL trees) that <B>is a</B> function of 
the size of the tree is the time to search for an item
in the tree.  For sufficiently large trees, the 
execution times of all procedures for maintaining HB[1]
trees are independent of the size of the tree. 
 In particular, an average of .465 restructures are required
per insertion, with an average of 2.78 nodes 
revisited to restore the HB[1] property; an average of
 .214 restructures are required per deletion, with 
an average of 1.91 nodes revisited to restore the HB[1]
property.  Moreover,the execution times of procedures 
for maintaining HB[k] trees, for k>1, are also independent
of the size of the tree except for the average 
number of nodes revisited on a delete operation in
order to restore the HB[k] property on trace back. 
 The cost of maintaining HB[k] trees drops sharply as the
allowable imbalance (k) increases.  Both analytical 
and experimental results that show the cost of maintaining
HB[k] trees as a function of k are discussed.

CACM January, 1976

Karlton, P. L.
Fuller, S. H.
Scroggs, R. E.
Kaehler, E. B.

HB[k] trees, balanced trees, AVL trees,
information storage and retrieval, searching

3.7 3.72 3.74 4.49 5.39

CA760104 JB January 5, 1978  10:27 AM

2411	4	2889
2455	4	2889
2493	4	2889
2709	4	2889
2889	4	2889
2889	4	2889
2889	4	2889
2937	4	2889
2968	4	2889
2968	4	2889
2989	4	2889
3005	4	2889
3025	4	2889
3042	4	2889
3101	4	2889
2138	5	2889
2388	5	2889
2455	5	2889
2839	5	2889
2889	5	2889
2889	5	2889
2889	5	2889
3042	5	2889
3096	5	2889
3163	5	2889
2455	6	2889
2839	6	2889
2839	6	2889
2839	6	2889
2889	6	2889
2889	6	2889
2889	6	2889
2889	6	2889
2968	6	2889
3009	6	2889
3009	6	2889
3065	6	2889
3096	6	2889


************************



Performance of Height-Balanced Trees

This paper presents the results of simulations
that investigate the performance of height-balanced 
(HB[k]) trees.  It is shown that the only statistic
of HB[1] trees (AVL trees) that is a function of 
the size of the tree <B>is the</B> time to search for an item
in the tree.  For sufficiently large trees, the 
execution times of all procedures for maintaining HB[1]
trees are independent of the size of the tree. 
 In particular, an average of .465 restructures are required
per insertion, with an average of 2.78 nodes 
revisited to restore the HB[1] property; an average of
 .214 restructures are required per deletion, with 
an average of 1.91 nodes revisited to restore the HB[1]
property.  Moreover,the execution times of procedures 
for maintaining HB[k] trees, for k>1, are also independent
of the size of the tree except for the average 
number of nodes revisited on a delete operation in
order to restore the HB[k] property on trace back. 
 The cost of maintaining HB[k] trees drops sharply as the
allowable imbalance (k) increases.  Both analytical 
and experimental results that show the cost of maintaining
HB[k] trees as a function of k are discussed.

CACM January, 1976

Karlton, P. L.
Fuller, S. H.
Scroggs, R. E.
Kaehler, E. B.

HB[k] trees, balanced trees, AVL trees,
information storage and retrieval, searching

3.7 3.72 3.74 4.49 5.39

CA760104 JB January 5, 1978  10:27 AM

2411	4	2889
2455	4	2889
2493	4	2889
2709	4	2889
2889	4	2889
2889	4	2889
2889	4	2889
2937	4	2889
2968	4	2889
2968	4	2889
2989	4	2889
3005	4	2889
3025	4	2889
3042	4	2889
3101	4	2889
2138	5	2889
2388	5	2889
2455	5	2889
2839	5	2889
2889	5	2889
2889	5	2889
2889	5	2889
3042	5	2889
3096	5	2889
3163	5	2889
2455	6	2889
2839	6	2889
2839	6	2889
2839	6	2889
2889	6	2889
2889	6	2889
2889	6	2889
2889	6	2889
2968	6	2889
3009	6	2889
3009	6	2889
3065	6	2889
3096	6	2889


************************

************************
Document:  CACM-1469.html
************************


The Next 700 Programming Languages 

A family of unimplemented computing languages
is described that is intended to span differences 
of application area by a unified framework.  This framework
dictates the rules about the uses of user-coined 
names, and the conventions about characterizing functional
relationships.  Within this framework the 
design of a specific language splits into two independent
parts.  One is the choice of written appearances 
of programs (or more generally, their physical representation).
 The other is the choice <B>of the</B> abstract 
entities (such as numbers, character-strings, lists
of them, functional relations among them) that can 
be referred to in the language.  The system is biased
towards "expressions" rather than "statements." 
 It includes a nonprocedural(purely functional) subsystem
that aims to expand the class of users' needs 
that can be met by a single print-instruction, without sacrificing
the important properties that make 
conventional right-hand-side expressions easy to construct and understand.

CACM March, 1966

Landin, P. J.

CA660303 JB March 3, 1978  2:05 PM

1469	4	1469
1486	4	1469
1491	4	1469
1781	4	1469
2178	4	1469
2326	4	1469
2470	4	1469
2684	4	1469
3044	4	1469
1303	5	1469
1469	5	1469
1469	5	1469
1469	5	1469
2060	5	1469
2294	5	1469
2470	5	1469
3124	5	1469
1303	6	1469
1380	6	1469
1421	6	1469
1469	6	1469
1469	6	1469
1469	6	1469
1469	6	1469
1477	6	1469
1491	6	1469
210	6	1469
1834	6	1469
1869	6	1469
2060	6	1469
2110	6	1469
2264	6	1469


************************



The Next 700 Programming Languages 

A family of unimplemented computing languages
is described that is intended to span differences 
of application area by a unified framework.  This framework
dictates the rules about the uses of user-coined 
names, and the conventions about characterizing functional
relationships.  Within this framework the 
design of a specific language splits into two independent
parts.  One is the choice of written appearances 
of programs (or more generally, their physical representation).
 The other is the choice of the abstract 
entities (such as numbers, character-strings, lists
of them, functional relations among them) that can 
be referred to in the language.  The <B>system is</B> biased
towards "expressions" rather than "statements." 
 It includes a nonprocedural(purely functional) subsystem
that aims to expand the class of users' needs 
that can be met by a single print-instruction, without sacrificing
the important properties that make 
conventional right-hand-side expressions easy to construct and understand.

CACM March, 1966

Landin, P. J.

CA660303 JB March 3, 1978  2:05 PM

1469	4	1469
1486	4	1469
1491	4	1469
1781	4	1469
2178	4	1469
2326	4	1469
2470	4	1469
2684	4	1469
3044	4	1469
1303	5	1469
1469	5	1469
1469	5	1469
1469	5	1469
2060	5	1469
2294	5	1469
2470	5	1469
3124	5	1469
1303	6	1469
1380	6	1469
1421	6	1469
1469	6	1469
1469	6	1469
1469	6	1469
1469	6	1469
1477	6	1469
1491	6	1469
210	6	1469
1834	6	1469
1869	6	1469
2060	6	1469
2110	6	1469
2264	6	1469


************************



The Next 700 Programming Languages 

A family of unimplemented computing languages
is described that is intended to span differences 
of application area by a unified framework.  This framework
dictates the rules about the uses of user-coined 
names, <B>and the</B> conventions about characterizing functional
relationships.  Within this framework the 
design of a specific language splits into two independent
parts.  One is the choice of written appearances 
of programs (or more generally, their physical representation).
 The other is the choice of the abstract 
entities (such as numbers, character-strings, lists
of them, functional relations among them) that can 
be referred to in the language.  The system is biased
towards "expressions" rather than "statements." 
 It includes a nonprocedural(purely functional) subsystem
that aims to expand the class of users' needs 
that can be met by a single print-instruction, without sacrificing
the important properties that make 
conventional right-hand-side expressions easy to construct and understand.

CACM March, 1966

Landin, P. J.

CA660303 JB March 3, 1978  2:05 PM

1469	4	1469
1486	4	1469
1491	4	1469
1781	4	1469
2178	4	1469
2326	4	1469
2470	4	1469
2684	4	1469
3044	4	1469
1303	5	1469
1469	5	1469
1469	5	1469
1469	5	1469
2060	5	1469
2294	5	1469
2470	5	1469
3124	5	1469
1303	6	1469
1380	6	1469
1421	6	1469
1469	6	1469
1469	6	1469
1469	6	1469
1469	6	1469
1477	6	1469
1491	6	1469
210	6	1469
1834	6	1469
1869	6	1469
2060	6	1469
2110	6	1469
2264	6	1469


************************



The Next 700 Programming Languages 

A family of unimplemented computing languages
is described that is intended to span differences 
<B>of a</B>pplication area by a unified framework.  This framework
dictates the rules about the uses of user-coined 
names, and the conventions about characterizing functional
relationships.  Within this framework the 
design of a specific language splits into two independent
parts.  One is the choice of written appearances 
of programs (or more generally, their physical representation).
 The other is the choice of the abstract 
entities (such as numbers, character-strings, lists
of them, functional relations among them) that can 
be referred to in the language.  The system is biased
towards "expressions" rather than "statements." 
 It includes a nonprocedural(purely functional) subsystem
that aims to expand the class of users' needs 
that can be met by a single print-instruction, without sacrificing
the important properties that make 
conventional right-hand-side expressions easy to construct and understand.

CACM March, 1966

Landin, P. J.

CA660303 JB March 3, 1978  2:05 PM

1469	4	1469
1486	4	1469
1491	4	1469
1781	4	1469
2178	4	1469
2326	4	1469
2470	4	1469
2684	4	1469
3044	4	1469
1303	5	1469
1469	5	1469
1469	5	1469
1469	5	1469
2060	5	1469
2294	5	1469
2470	5	1469
3124	5	1469
1303	6	1469
1380	6	1469
1421	6	1469
1469	6	1469
1469	6	1469
1469	6	1469
1469	6	1469
1477	6	1469
1491	6	1469
210	6	1469
1834	6	1469
1869	6	1469
2060	6	1469
2110	6	1469
2264	6	1469


************************



The Next 700 Programming Languages 

A family of unimplemented computing languages
is described that is intended to span differences 
of application area by a unified framework.  This framework
dictates the rules about the uses of user-coined 
names, and the conventions about characterizing functional
relationships.  Within this framework the 
design of a specific language splits into two independent
parts.  One <B>is the</B> choice of written appearances 
of programs (or more generally, their physical representation).
 The other is the choice of the abstract 
entities (such as numbers, character-strings, lists
of them, functional relations among them) that can 
be referred to in the language.  The system is biased
towards "expressions" rather than "statements." 
 It includes a nonprocedural(purely functional) subsystem
that aims to expand the class of users' needs 
that can be met by a single print-instruction, without sacrificing
the important properties that make 
conventional right-hand-side expressions easy to construct and understand.

CACM March, 1966

Landin, P. J.

CA660303 JB March 3, 1978  2:05 PM

1469	4	1469
1486	4	1469
1491	4	1469
1781	4	1469
2178	4	1469
2326	4	1469
2470	4	1469
2684	4	1469
3044	4	1469
1303	5	1469
1469	5	1469
1469	5	1469
1469	5	1469
2060	5	1469
2294	5	1469
2470	5	1469
3124	5	1469
1303	6	1469
1380	6	1469
1421	6	1469
1469	6	1469
1469	6	1469
1469	6	1469
1469	6	1469
1477	6	1469
1491	6	1469
210	6	1469
1834	6	1469
1869	6	1469
2060	6	1469
2110	6	1469
2264	6	1469


************************

************************
Document:  CACM-1930.html
************************


Extremely Portable Random Number Generator

Extremely portable subroutines are sometimes
needed for which moderate quality and efficiency 
suffice.  Typically, this occurs for library functions
(like random number generation and in core sorting) 
which are not entirely universal or are not used <B>in a</B>
standardized way.  The literature on random number 
generators does not seem to contain an algorithm that
meets requirements of this sort.  An extremely 
portable 8-line FORTRAN program is provided which based
on an important paper by Coveyou and MacPherson 
(1967)sing their methods, Fourier analysis is applied
to the probability function for the consecutive 
n-tuples provided by our generator (with n less than
or equal to 4).  While the small modulus which must 
be used to maintain portability prevents the quality
of the generator from being high, the generator 
compares well with the bounds established in the above mentioned paper.

CACM February, 1969

Kruskal, J. B.

random number generators, random numbers, random
number analysis, random generators, linear sequential 
generators, random number program, pseudo random numbers 

4.49 5.19 5.5

CA690208 JB February 20, 1978  10:43 AM

1930	5	1930
1930	5	1930
1930	5	1930
2115	5	1930
1691	6	1930
1930	6	1930


************************



Extremely Portable Random Number Generator

Extremely portable subroutines are sometimes
needed for which moderate quality and efficiency 
suffice.  Typically, this occurs for library functions
(like random number generation and in core sorting) 
which are not entirely universal or are not used in a
standardized way.  The literature on random number 
generators does not seem to contain an algorithm that
meets requirements of this sort.  An extremely 
portable 8-line FORTRAN program is provided which based
on an important paper by Coveyou and MacPherson 
(1967)sing their methods, Fourier analysis <B>is a</B>pplied
to the probability function for the consecutive 
n-tuples provided by our generator (with n less than
or equal to 4).  While the small modulus which must 
be used to maintain portability prevents the quality
of the generator from being high, the generator 
compares well with the bounds established in the above mentioned paper.

CACM February, 1969

Kruskal, J. B.

random number generators, random numbers, random
number analysis, random generators, linear sequential 
generators, random number program, pseudo random numbers 

4.49 5.19 5.5

CA690208 JB February 20, 1978  10:43 AM

1930	5	1930
1930	5	1930
1930	5	1930
2115	5	1930
1691	6	1930
1930	6	1930


************************



Extremely Portable Random Number Generator

Extremely portable subroutines are sometimes
needed for which moderate quality and efficiency 
suffice.  Typically, this occurs for library functions
(like random number generation and in core sorting) 
which are not entirely universal or are not used in a
standardized way.  The literature on random number 
generators does not seem to contain an algorithm that
meets requirements of this sort.  An extremely 
portable 8-line FORTRAN program is provided which based
on an important paper by Coveyou and MacPherson 
(1967)sing their methods, Fourier analysis is applied
to the probability function for the consecutive 
n-tuples provided by our generator (with n less than
or equal to 4).  While the small modulus which must 
be used to maintain portability prevents the quality
<B>of the</B> generator from being high, the generator 
compares well with the bounds established in the above mentioned paper.

CACM February, 1969

Kruskal, J. B.

random number generators, random numbers, random
number analysis, random generators, linear sequential 
generators, random number program, pseudo random numbers 

4.49 5.19 5.5

CA690208 JB February 20, 1978  10:43 AM

1930	5	1930
1930	5	1930
1930	5	1930
2115	5	1930
1691	6	1930
1930	6	1930


************************

************************
Document:  CACM-1754.html
************************


Dynamic Storage Allocation Systems

In many recent computer system designs, hardware
facilities have been provided for easing the 
problems of storage allocation.  A method of characterizing
dynamic storage allocation systems-according 
to the functional capabilities provided and the underlying
techniques used-is presented.  The basic purpose 
<B>of the</B> paper is to provide a useful perspective from
which the utility of various hardware facilities 
may be assessed.  A brief survey of storage allocation
facilities in several representative computer 
systems is included as an appendix.

CACM May, 1968

Randell, B.
Kuehner, C. J.

segmentation, paging, multiprogramming, storage
allocation, storage management, virtual memories, 
storage fragmentation, storage hierarchies, addressing mechanisms

4.30 6.20

CA680502 JB February 23, 1978  9:49 AM

1754	4	1754
1754	4	1754
2358	4	1754
488	4	1754
274	5	1754
1754	5	1754
1754	5	1754
1754	5	1754
1879	5	1754
1884	5	1754
1901	5	1754
376	5	1754
2095	5	1754
2277	5	1754
2297	5	1754
2365	5	1754
168	6	1754
185	6	1754
987	6	1754
1728	6	1754
1728	6	1754
1751	6	1754
1751	6	1754
1751	6	1754
1754	6	1754
1754	6	1754
1754	6	1754
1754	6	1754
1754	6	1754
1754	6	1754
1754	6	1754
1879	6	1754
1924	6	1754
2362	6	1754


************************



Dynamic Storage Allocation Systems

In many recent computer system designs, hardware
facilities have been provided for easing the 
problems of storage allocation.  A method of characterizing
dynamic storage allocation systems-according 
to the functional capabilities provided <B>and the</B> underlying
techniques used-is presented.  The basic purpose 
of the paper is to provide a useful perspective from
which the utility of various hardware facilities 
may be assessed.  A brief survey of storage allocation
facilities in several representative computer 
systems is included as an appendix.

CACM May, 1968

Randell, B.
Kuehner, C. J.

segmentation, paging, multiprogramming, storage
allocation, storage management, virtual memories, 
storage fragmentation, storage hierarchies, addressing mechanisms

4.30 6.20

CA680502 JB February 23, 1978  9:49 AM

1754	4	1754
1754	4	1754
2358	4	1754
488	4	1754
274	5	1754
1754	5	1754
1754	5	1754
1754	5	1754
1879	5	1754
1884	5	1754
1901	5	1754
376	5	1754
2095	5	1754
2277	5	1754
2297	5	1754
2365	5	1754
168	6	1754
185	6	1754
987	6	1754
1728	6	1754
1728	6	1754
1751	6	1754
1751	6	1754
1751	6	1754
1754	6	1754
1754	6	1754
1754	6	1754
1754	6	1754
1754	6	1754
1754	6	1754
1754	6	1754
1879	6	1754
1924	6	1754
2362	6	1754


************************

************************
Document:  CACM-0963.html
************************


Relative Effects of Central Processor and Input-Output
Speeds Upon Throughput on the Large Computer

Presented in this paper <B>is a</B> technique for
determining the relative effects of the internal 
speed of the computer and the speed of the input-output
units upon the overall speed of the system. Equations 
are derived which permit the determination of these
effects from hardware usage measurements.

CACM December, 1964

White, P.

CA641208 JB March 9, 1978  3:34 PM

963	5	963
963	5	963
963	5	963
1653	5	963
963	6	963
1069	6	963
1417	6	963


************************



Relative Effects of Central Processor and Input-Output
Speeds Upon Throughput on the Large Computer

Presented in this paper is a technique for
determining the relative effects <B>of the</B> internal 
speed of the computer and the speed of the input-output
units upon the overall speed of the system. Equations 
are derived which permit the determination of these
effects from hardware usage measurements.

CACM December, 1964

White, P.

CA641208 JB March 9, 1978  3:34 PM

963	5	963
963	5	963
963	5	963
1653	5	963
963	6	963
1069	6	963
1417	6	963


************************



Relative Effects of Central Processor and Input-Output
Speeds Upon Throughput on the Large Computer

Presented in this paper is a technique for
determining the relative effects of the internal 
speed of the computer <B>and the</B> speed of the input-output
units upon the overall speed of the system. Equations 
are derived which permit the determination of these
effects from hardware usage measurements.

CACM December, 1964

White, P.

CA641208 JB March 9, 1978  3:34 PM

963	5	963
963	5	963
963	5	963
1653	5	963
963	6	963
1069	6	963
1417	6	963


************************

************************
Document:  CACM-1179.html
************************


PUFFT-The Purdue University Fast FORTRAN Translator

A core resident, compile-and-go system designed
for the IBM 7090/7094 computer is described. 
 In little more than half <B>of the</B> 32k word core memory
PUFFT provides a monitor for job sequencing, a 
translator for the full FORTRAN IV language, the FORTRAN
subroutine library, an input--output system 
for use at compile time and at execute time, and a rather
elaborate diagnostic message writing routine. 
 Batches of small- and medium-sized FORTRAN IV source
language programs are processed at very high speeds. 
 Language compatibility has been maintained so that
programs may be debugged in the PUFFT system and 
then recompiled and run in the IBJOB-IBFTC system supplied by the manufacturer.

CACM November, 1965

Rosen, S.
Spurgeon, A.
Donnelly, J. K.

CA651102 JB March 6, 1978  6:17 PM

1134	4	1179
1179	4	1179
1179	4	1179
1288	4	1179
1544	4	1179
1646	4	1179
1861	4	1179
2111	4	1179
2534	4	1179
2556	4	1179
2650	4	1179
1179	5	1179
1179	5	1179
1179	5	1179
1646	5	1179
1647	5	1179
408	5	1179
830	5	1179
830	6	1179
987	6	1179
1072	6	1179
1179	6	1179
1179	6	1179
1647	6	1179
224	6	1179
680	6	1179


************************

************************
Document:  CACM-1230.html
************************


Method for Hyphenating at the End <B>of a</B> Printed Line

A description of a method of hyphenation is
presented as a result of application of several 
general rules.  The character sets considered by the
routine and the method are briefly outlined.

CACM July, 1965

Rich, R. P.
Stone, A. G.

CA650705 JB March 6, 1978  9:03 PM

1230	5	1230
1230	5	1230
1230	5	1230


************************



Method for Hyphenating at the End of a Printed Line

A description of a method of hyphenation is
presented as a result of application of several 
general rules.  The character sets considered by the
routine <B>and the</B> method are briefly outlined.

CACM July, 1965

Rich, R. P.
Stone, A. G.

CA650705 JB March 6, 1978  9:03 PM

1230	5	1230
1230	5	1230
1230	5	1230


************************

************************
Document:  CACM-2676.html
************************


Zeros <B>of a</B> Complex Polynomial (Algorithm R419)

CACM March, 1973

Withers, D. H.

CA740307 JB January 18, 1978  11:11 AM 

2676	5	2676
2676	5	2676
2676	5	2676


************************

************************
Document:  CACM-0248.html
************************


What is Proprietary In Mathematical Programming?-Impressions
<B>of a</B> Panel Discussion

A panel discussion on "What is Proprietary
in Mathematical Programming?" was sponsored by the 
Special Interest Committee on Mathematical Programming
of the ACM during a Hall of Discussion/on September 
7th at the 16th National ACM meeting in Los Angeles.  This
note consists solely of the impressions garnered 
by the moderator of the panel and does not necessarily
represent the position of any of the panelists 
or other participants in the discussion.

CACM December, 1961

Smith, L. W.

CA611202 JB March 15, 1978  10:31 PM

248	5	248
248	5	248
248	5	248


************************



What is Proprietary In Mathematical Programming?-Impressions
of a Panel Discussion

A panel discussion on "What is Proprietary
in Mathematical Programming?" was sponsored by the 
Special Interest Committee on Mathematical Programming
<B>of the</B> ACM during a Hall of Discussion/on September 
7th at the 16th National ACM meeting in Los Angeles.  This
note consists solely of the impressions garnered 
by the moderator of the panel and does not necessarily
represent the position of any of the panelists 
or other participants in the discussion.

CACM December, 1961

Smith, L. W.

CA611202 JB March 15, 1978  10:31 PM

248	5	248
248	5	248
248	5	248


************************

************************
Document:  CACM-1415.html
************************


Automatic Derivation of Microsentences

The decomposition of long complex English sentences
into shorter kernel-like constituent sentences 
(microsentences)has often been suggested as an avenue
toward conducting automatic retrieval of natural 
language messages.  To explore the prospects of such
a step, the authors attempted in 1963 to prepare 
a general program for deriving microsentences from longer
sentences that had been syntactically analyzed 
by the Harvard Multipath Analysis Program.  The basic
idea was to extract the subject, verb and object 
(if any) of each clause and to reassemble these materials
into a grammatical microsentence.  A program 
is described in this paper, which was designed to operate
on the tree structure output of the analyzer, 
<B>and the</B> microsentences that were produced are exhibited.
 The authors conclude that while microsentences 
of the quality achieved do not open up immediate prospects
for improving the performance of automatic 
message retrieval systems, they may have practical
value in man-machine systems using human monitors 
to select the preferred syntactic interpretation of a sentence.

CACM June, 1966

Carmody, B. T
Jones Jr., P. E.

CA660606 JB March 3, 1978  8:47 AM

1415	5	1415
1415	5	1415
1415	5	1415


************************



Automatic Derivation of Microsentences

The decomposition of long complex English sentences
into shorter kernel-like constituent sentences 
(microsentences)has often been suggested as an avenue
toward conducting automatic retrieval of natural 
language messages.  To explore the prospects of such
a step, the authors attempted in 1963 to prepare 
a general program for deriving microsentences from longer
sentences that had been syntactically analyzed 
by the Harvard Multipath Analysis Program.  The basic
idea was to extract the subject, verb and object 
(if any) of each clause and to reassemble these materials
into a grammatical microsentence.  A program 
is described in this paper, which was designed to operate
on the tree structure output <B>of the</B> analyzer, 
and the microsentences that were produced are exhibited.
 The authors conclude that while microsentences 
of the quality achieved do not open up immediate prospects
for improving the performance of automatic 
message retrieval systems, they may have practical
value in man-machine systems using human monitors 
to select the preferred syntactic interpretation of a sentence.

CACM June, 1966

Carmody, B. T
Jones Jr., P. E.

CA660606 JB March 3, 1978  8:47 AM

1415	5	1415
1415	5	1415
1415	5	1415


************************



Automatic Derivation of Microsentences

The decomposition of long complex English sentences
into shorter kernel-like constituent sentences 
(microsentences)has often been suggested as an avenue
toward conducting automatic retrieval of natural 
language messages.  To explore the prospects of such
a step, the authors attempted in 1963 to prepare 
a general program for deriving microsentences from longer
sentences that had been syntactically analyzed 
by the Harvard Multipath Analysis Program.  The basic
idea was to extract the subject, verb and object 
(if any) of each clause and to reassemble these materials
into a grammatical microsentence.  A program 
is described in this paper, which was designed to operate
on the tree structure output of the analyzer, 
and the microsentences that were produced are exhibited.
 The authors conclude that while microsentences 
of the quality achieved do not open up immediate prospects
for improving the performance <B>of a</B>utomatic 
message retrieval systems, they may have practical
value in man-machine systems using human monitors 
to select the preferred syntactic interpretation of a sentence.

CACM June, 1966

Carmody, B. T
Jones Jr., P. E.

CA660606 JB March 3, 1978  8:47 AM

1415	5	1415
1415	5	1415
1415	5	1415


************************

************************
Document:  CACM-2307.html
************************


Dynamic Document Processing

The current role of computers <B>in a</B>utomatic
document processing is briefly outlined, and some 
reasons are given why the early promise of library automation
and of the mechanization of documentation 
processes has not been fulfilled.  A new dynamic document
environment is then outlined in which clustered
files are searched and information is retrieved following
an interactive user-controlled search process. 
 Methods are described for an automatic query modification
based on user needs, and for a continuous 
reorganization of the stored information as a function of
earlier file processing and of normal collection 
growth.  The proposed procedures provide powerful tools
for information retrieval and for the control 
of dynamic library collections in which new items
are continually added and old ones are retired.

CACM July, 1972

Salton, G.

automatic indexing, automatic search and retrieval,
iterative searching, mechanized library processing, 
collection growth, collection retirement, feedback search

3.62 3.71 3.73 3.74

CA720721 JB January 30, 1978  10:59 AM

2307	5	2307
2307	5	2307
2307	5	2307


************************



Dynamic Document Processing

The current role of computers in automatic
document processing is briefly outlined, and some 
reasons are given why the early promise of library automation
and of the mechanization of documentation 
processes has not been fulfilled.  A new dynamic document
environment <B>is the</B>n outlined in which clustered
files are searched and information is retrieved following
an interactive user-controlled search process. 
 Methods are described for an automatic query modification
based on user needs, and for a continuous 
reorganization of the stored information as a function of
earlier file processing and of normal collection 
growth.  The proposed procedures provide powerful tools
for information retrieval and for the control 
of dynamic library collections in which new items
are continually added and old ones are retired.

CACM July, 1972

Salton, G.

automatic indexing, automatic search and retrieval,
iterative searching, mechanized library processing, 
collection growth, collection retirement, feedback search

3.62 3.71 3.73 3.74

CA720721 JB January 30, 1978  10:59 AM

2307	5	2307
2307	5	2307
2307	5	2307


************************



Dynamic Document Processing

The current role of computers in automatic
document processing is briefly outlined, and some 
reasons are given why the early promise of library automation
and <B>of the</B> mechanization of documentation 
processes has not been fulfilled.  A new dynamic document
environment is then outlined in which clustered
files are searched and information is retrieved following
an interactive user-controlled search process. 
 Methods are described for an automatic query modification
based on user needs, and for a continuous 
reorganization of the stored information as a function of
earlier file processing and of normal collection 
growth.  The proposed procedures provide powerful tools
for information retrieval and for the control 
of dynamic library collections in which new items
are continually added and old ones are retired.

CACM July, 1972

Salton, G.

automatic indexing, automatic search and retrieval,
iterative searching, mechanized library processing, 
collection growth, collection retirement, feedback search

3.62 3.71 3.73 3.74

CA720721 JB January 30, 1978  10:59 AM

2307	5	2307
2307	5	2307
2307	5	2307


************************

************************
Document:  CACM-3118.html
************************


Permutation of Data Blocks in a Bubble Memory

A common internal organization of bubble memories consists <B>of a</B> set of (minor) 
loops, connected through another (major) loop.  The problem of obtaining any 
give n permutation of the minor loop contents in minimum time is studied
in this paper.  A lower bound to the number of steps required buy
a permutation algorithm is derived, and the class of optimum algorithms is 
identified.

CACM January, 1979

Bongiovanni, G.
Luccio, F.

Bubble memory, memory loops, permutation algorithm, data block shift

4.34 5.30 6.34

CA790103 DH April 10, 1979  12:04 PM

3118	5	3118
3118	5	3118
3118	5	3118


************************



Permutation of Data Blocks in a Bubble Memory

A common internal organization of bubble memories consists of a set of (minor) 
loops, connected through another (major) loop.  The problem of obtaining any 
give n permutation of the minor loop contents in minimum time is studied
in this paper.  A lower bound to the number of steps required buy
a permutation algorithm is derived, <B>and the</B> class of optimum algorithms is 
identified.

CACM January, 1979

Bongiovanni, G.
Luccio, F.

Bubble memory, memory loops, permutation algorithm, data block shift

4.34 5.30 6.34

CA790103 DH April 10, 1979  12:04 PM

3118	5	3118
3118	5	3118
3118	5	3118


************************



Permutation of Data Blocks in a Bubble Memory

A common internal organization of bubble memories consists of a set of (minor) 
loops, connected through another (major) loop.  The problem of obtaining any 
give n permutation <B>of the</B> minor loop contents in minimum time is studied
in this paper.  A lower bound to the number of steps required buy
a permutation algorithm is derived, and the class of optimum algorithms is 
identified.

CACM January, 1979

Bongiovanni, G.
Luccio, F.

Bubble memory, memory loops, permutation algorithm, data block shift

4.34 5.30 6.34

CA790103 DH April 10, 1979  12:04 PM

3118	5	3118
3118	5	3118
3118	5	3118


************************



Permutation of Data Blocks <B>in a</B> Bubble Memory

A common internal organization of bubble memories consists of a set of (minor) 
loops, connected through another (major) loop.  The problem of obtaining any 
give n permutation of the minor loop contents in minimum time is studied
in this paper.  A lower bound to the number of steps required buy
a permutation algorithm is derived, and the class of optimum algorithms is 
identified.

CACM January, 1979

Bongiovanni, G.
Luccio, F.

Bubble memory, memory loops, permutation algorithm, data block shift

4.34 5.30 6.34

CA790103 DH April 10, 1979  12:04 PM

3118	5	3118
3118	5	3118
3118	5	3118


************************

************************
Document:  CACM-2651.html
************************


The Treatment of Data Types in EL1

In constructing a general purpose programming
language, a key issue is providing a sufficient 
set of data types and associated operations <B>in a</B> manner
that permits both natural problem-oriented notation 
and efficient implementation.  The EL1 language contains
a number of features specifically designed to 
simultaneously satisfy both requirements.  The resulting
treatment of data types includes provision for 
programmer-defined data types data types and generic
routines, programmer control over type conversion, 
and very flexible data type behavior, in a context that
allows efficient compiled code and compact data 
representation.

CACM May, 1974

Wegbreit, B.

data types, modes, mode unions, type conversion,
coercion, generic functions, extensible languages, 
data type definition, data description language, compilation

4.12 4.13 4.22

CA740502 JB January 17, 1978  4:32 PM

2651	5	2651
2651	5	2651
2651	5	2651
2723	5	2651
2941	5	2651
2956	5	2651
3030	5	2651
1379	6	2651
1471	6	2651
1549	6	2651
1749	6	2651
1826	6	2651
210	6	2651
2247	6	2651
2356	6	2651
2356	6	2651
2457	6	2651
2558	6	2651
2651	6	2651
2651	6	2651
2651	6	2651
2651	6	2651
2958	6	2651
2972	6	2651
627	6	2651
731	6	2651


************************



The Treatment of Data Types in EL1

In constructing a general purpose programming
language, a key issue is providing a sufficient 
set of data <B>types and</B> associated operations in a manner
that permits both natural problem-oriented notation 
and efficient implementation.  The EL1 language contains
a number of features specifically designed to 
simultaneously satisfy both requirements.  The resulting
treatment of data types includes provision for 
programmer-defined data types data types and generic
routines, programmer control over type conversion, 
and very flexible data type behavior, in a context that
allows efficient compiled code and compact data 
representation.

CACM May, 1974

Wegbreit, B.

data types, modes, mode unions, type conversion,
coercion, generic functions, extensible languages, 
data type definition, data description language, compilation

4.12 4.13 4.22

CA740502 JB January 17, 1978  4:32 PM

2651	5	2651
2651	5	2651
2651	5	2651
2723	5	2651
2941	5	2651
2956	5	2651
3030	5	2651
1379	6	2651
1471	6	2651
1549	6	2651
1749	6	2651
1826	6	2651
210	6	2651
2247	6	2651
2356	6	2651
2356	6	2651
2457	6	2651
2558	6	2651
2651	6	2651
2651	6	2651
2651	6	2651
2651	6	2651
2958	6	2651
2972	6	2651
627	6	2651
731	6	2651


************************



The Treatment of Data Types in EL1

In constructing a general purpose programming
language, a key issue is providing a sufficient 
set of <B>data types</B> and associated operations in a manner
that permits both natural problem-oriented notation 
and efficient implementation.  The EL1 language contains
a number of features specifically designed to 
simultaneously satisfy both requirements.  The resulting
treatment of data types includes provision for 
programmer-defined data types data types and generic
routines, programmer control over type conversion, 
and very flexible data type behavior, in a context that
allows efficient compiled code and compact data 
representation.

CACM May, 1974

Wegbreit, B.

data types, modes, mode unions, type conversion,
coercion, generic functions, extensible languages, 
data type definition, data description language, compilation

4.12 4.13 4.22

CA740502 JB January 17, 1978  4:32 PM

2651	5	2651
2651	5	2651
2651	5	2651
2723	5	2651
2941	5	2651
2956	5	2651
3030	5	2651
1379	6	2651
1471	6	2651
1549	6	2651
1749	6	2651
1826	6	2651
210	6	2651
2247	6	2651
2356	6	2651
2356	6	2651
2457	6	2651
2558	6	2651
2651	6	2651
2651	6	2651
2651	6	2651
2651	6	2651
2958	6	2651
2972	6	2651
627	6	2651
731	6	2651


************************

************************
Document:  CACM-2925.html
************************


Optimal Surface Reconstruction from Planar Contours

In many scientific and technical endeavors,
a three-dimensional solid must be reconstructed 
from serial sections, either to aid in the comprehension
<B>of the</B> object's structure or to facilitate its 
automatic manipulation and analysis.  This paper presents
a general solution to the problem of constructing 
a surface over a set of cross-sectional contours. 
This surface, to be composed of triangular tiles, 
is constructed by separately determining an optimal
surface between each pair of consecutive contours.
 Determining such a surface is reduced to the problem
of finding certain minimum cost cycles in a directed 
toroidal graph.  A new fast algorithm for finding such
cycles is utilized.  Also developed is a closed-form 
expression, in term of the number of contour poin ts, for
an upper bound on the number of operations required 
to execute the algorithm.  An illustrated example which
involves the construction of a minimum area surface 
describing a human head is included.

CACM October, 1977

Fuchs, H.
Kedem,Z. M.
Uselton, S. P.

surface reconstruction, contour data, serial sections,
three-dimensional computer graphics, minimum 
cost paths, continuous tone displays

5.25 5.32 8.2

CA771001 JB December 27, 1977  12:40 PM

2925	5	2925
2925	5	2925
2925	5	2925


************************



Optimal Surface Reconstruction from Planar Contours

In many scientific and technical endeavors,
a three-dimensional solid must be reconstructed 
from serial sections, either to aid in the comprehension
of the object's structure or to facilitate its 
automatic manipulation and analysis.  This paper presents
a general solution to the problem of constructing 
a surface over a set of cross-sectional contours. 
This surface, to be composed of triangular tiles, 
is constructed by separately determining an optimal
surface between each pair of consecutive contours.
 Determining such a surface is reduced to the problem
of finding certain minimum cost cycles in a directed 
toroidal graph.  A new fast algorithm for finding such
cycles is utilized.  Also developed is a closed-form 
expression, in term of the number of contour poin ts, for
an upper bound on the number of operations required 
to execute the algorithm.  An illustrated example which
involves the construction <B>of a</B> minimum area surface 
describing a human head is included.

CACM October, 1977

Fuchs, H.
Kedem,Z. M.
Uselton, S. P.

surface reconstruction, contour data, serial sections,
three-dimensional computer graphics, minimum 
cost paths, continuous tone displays

5.25 5.32 8.2

CA771001 JB December 27, 1977  12:40 PM

2925	5	2925
2925	5	2925
2925	5	2925


************************



Optimal Surface Reconstruction from Planar Contours

In many scientific and technical endeavors,
a three-dimensional solid must be reconstructed 
from serial sections, either to aid in the comprehension
of the object's structure or to facilitate its 
automatic manipulation and analysis.  This paper presents
a general solution to the problem of constructing 
a surface over a set of cross-sectional contours. 
This surface, to be composed of triangular tiles, 
is constructed by separately determining an optimal
surface between each pair of consecutive contours.
 Determining such a surface is reduced to the problem
of finding certain minimum cost cycles in a directed 
toroidal graph.  A new fast algorithm for finding such
cycles is utilized.  Also developed <B>is a</B> closed-form 
expression, in term of the number of contour poin ts, for
an upper bound on the number of operations required 
to execute the algorithm.  An illustrated example which
involves the construction of a minimum area surface 
describing a human head is included.

CACM October, 1977

Fuchs, H.
Kedem,Z. M.
Uselton, S. P.

surface reconstruction, contour data, serial sections,
three-dimensional computer graphics, minimum 
cost paths, continuous tone displays

5.25 5.32 8.2

CA771001 JB December 27, 1977  12:40 PM

2925	5	2925
2925	5	2925
2925	5	2925


************************



Optimal Surface Reconstruction from Planar Contours

In many scientific and technical endeavors,
a three-dimensional solid must be reconstructed 
from serial sections, either to aid in the comprehension
of the object's structure or to facilitate its 
automatic manipulation and analysis.  This paper presents
a general solution to the problem of constructing 
a surface over a set of cross-sectional contours. 
This surface, to be composed of triangular tiles, 
is constructed by separately determining an optimal
surface between each pair of consecutive contours.
 Determining such a surface is reduced to the problem
of finding certain minimum cost cycles <B>in a</B> directed 
toroidal graph.  A new fast algorithm for finding such
cycles is utilized.  Also developed is a closed-form 
expression, in term of the number of contour poin ts, for
an upper bound on the number of operations required 
to execute the algorithm.  An illustrated example which
involves the construction of a minimum area surface 
describing a human head is included.

CACM October, 1977

Fuchs, H.
Kedem,Z. M.
Uselton, S. P.

surface reconstruction, contour data, serial sections,
three-dimensional computer graphics, minimum 
cost paths, continuous tone displays

5.25 5.32 8.2

CA771001 JB December 27, 1977  12:40 PM

2925	5	2925
2925	5	2925
2925	5	2925


************************

************************
Document:  CACM-3124.html
************************


Recursive Data Structures in APL

A mathematical study of three approaches for defining nested
arrays in APL is presented.  Theorems exhibiting the relationships
between the definitional systems are given and illustrated through graph
representations.  One <B>of the</B> approaches is used to define an
APL array to be a recursive data structure equivalent to a tree structure
in which all data is stored at the leaves as homogeneous
arrays of numbers and characters.  An extension of APL is proposed that
includes new primitive functions to manipulate the nesting
level of arrays and new operators to assist in the
construction of data-driven algorithms.  

CACM February, 1979

Gull,W.
Jenkins, M.

Nested arrays, APL arrays, recursive data structures,
trees, data-driven algorithms, theory of arrays

4.22 5.29

CA790203 DH April 10, 1979  3:41 PM

2060	4	3124
2294	4	3124
2470	4	3124
3124	4	3124
1469	5	3124
3124	5	3124
3124	5	3124
3124	5	3124


************************



Recursive Data Structures in APL

A mathematical study of three approaches for defining nested
arrays in APL is presented.  Theorems exhibiting <B>the relationship</B>s
between the definitional systems are given and illustrated through graph
representations.  One of the approaches is used to define an
APL array to be a recursive data structure equivalent to a tree structure
in which all data is stored at the leaves as homogeneous
arrays of numbers and characters.  An extension of APL is proposed that
includes new primitive functions to manipulate the nesting
level of arrays and new operators to assist in the
construction of data-driven algorithms.  

CACM February, 1979

Gull,W.
Jenkins, M.

Nested arrays, APL arrays, recursive data structures,
trees, data-driven algorithms, theory of arrays

4.22 5.29

CA790203 DH April 10, 1979  3:41 PM

2060	4	3124
2294	4	3124
2470	4	3124
3124	4	3124
1469	5	3124
3124	5	3124
3124	5	3124
3124	5	3124


************************



Recursive Data Structures in APL

A mathematical study of three approaches for defining nested
arrays in APL is presented.  Theorems exhibiting the relationships
between the definitional systems are given and illustrated through graph
representations.  One of the approaches is used to define an
APL array to be a recursive data structure equivalent to a tree structure
in which all data is stored at the leaves as homogeneous
arrays of numbers and characters.  An extension of APL is proposed that
includes new primitive functions to manipulate the nesting
level <B>of a</B>rrays and new operators to assist in the
construction of data-driven algorithms.  

CACM February, 1979

Gull,W.
Jenkins, M.

Nested arrays, APL arrays, recursive data structures,
trees, data-driven algorithms, theory of arrays

4.22 5.29

CA790203 DH April 10, 1979  3:41 PM

2060	4	3124
2294	4	3124
2470	4	3124
3124	4	3124
1469	5	3124
3124	5	3124
3124	5	3124
3124	5	3124


************************

************************
Document:  CACM-1427.html
************************


Simulation of Radioisotope Scans by Computer

In radioisotope scanning, a field which <B>is a</B>ssuming
increasing importance in medical diagnosis, 
the scan is a two-dimensional pattern made up of dots.
 Areas of increased source activity are represented 
on the scan by areas of increased dot density.  To study
the output of scanners with various characteristics, 
a program which simulates radioisotope scans has been
written  for a PDP-1 computer with auxiliary disk 
storage and cathode ray tube display.  Past and present
research using the output of the simulator has 
shown the flexibility of the system to be important.
 The structure of this program can be useful in 
the simulation of the output of any quantum-limited system.

CACM May, 1966

Pizer, S. M.

CA660510 JB March 3, 1978  9:47 AM

1427	5	1427
1427	5	1427
1427	5	1427


************************



Simulation of Radioisotope Scans by Computer

In radioisotope scanning, a field which is assuming
increasing importance in medical diagnosis, 
the scan is a two-dimensional pattern made up of dots.
 Areas of increased source activity are represented 
on the scan by areas of increased dot density.  To study
the output of scanners with various characteristics, 
a program which simulates radioisotope scans has been
written  for a PDP-1 computer with auxiliary disk 
storage and cathode ray tube display.  Past and present
research using the output of the simulator has 
shown the flexibility of the system to be important.
 The structure of this program can be useful in 
the simulation of the output <B>of a</B>ny quantum-limited system.

CACM May, 1966

Pizer, S. M.

CA660510 JB March 3, 1978  9:47 AM

1427	5	1427
1427	5	1427
1427	5	1427


************************



Simulation of Radioisotope Scans by Computer

In radioisotope scanning, a field which is assuming
increasing importance in medical diagnosis, 
the scan is a two-dimensional pattern made up of dots.
 Areas of increased source activity are represented 
on the scan by areas of increased dot density.  To study
the output of scanners with various characteristics, 
a program which simulates radioisotope scans has been
written  for a PDP-1 computer with auxiliary disk 
storage and cathode ray tube display.  Past and present
research using the output <B>of the</B> simulator has 
shown the flexibility of the system to be important.
 The structure of this program can be useful in 
the simulation of the output of any quantum-limited system.

CACM May, 1966

Pizer, S. M.

CA660510 JB March 3, 1978  9:47 AM

1427	5	1427
1427	5	1427
1427	5	1427


************************

************************
Document:  CACM-1235.html
************************


A Stochastic Approach to the Grammatical Coding of English

A computer program is described which will
assign each word <B>in a</B>n English text to its form 
class or part of speech.  The program operates at relatively
high speed in only a limited storage space. 
 About half of the word-events in a corpus are identified
through the use of a small dictionary of function 
words and frequently occurring lexical words.  Some suffix
tests and logical-decision rules are employed 
to code additional words.  Finally, the remaining words
are assigned to one class or another on the basis 
of the most probable form classes to occur within the already
identified contexts.  The conditional probabilities 
used as a basis for this coding were empirically derived
from a separate hand-coded corpusn preliminary 
trials, the accuracy of the coder was 91% to 93%, with
obvious ways of improving the algorithm being 
suggested by an analysis of the results.

CACM June, 1965

Stolz, W. S.
Tannenbaum, H.
Carstensen, F. V.

CA650620 JB March 6, 1978  9:35 PM

1235	5	1235
1235	5	1235
1235	5	1235


************************



A Stochastic Approach to the Grammatical Coding of English

A computer program is described which will
assign each word in an English text to its form 
class or part of speech.  The program operates at relatively
high speed in only a limited storage space. 
 About half <B>of the</B> word-events in a corpus are identified
through the use of a small dictionary of function 
words and frequently occurring lexical words.  Some suffix
tests and logical-decision rules are employed 
to code additional words.  Finally, the remaining words
are assigned to one class or another on the basis 
of the most probable form classes to occur within the already
identified contexts.  The conditional probabilities 
used as a basis for this coding were empirically derived
from a separate hand-coded corpusn preliminary 
trials, the accuracy of the coder was 91% to 93%, with
obvious ways of improving the algorithm being 
suggested by an analysis of the results.

CACM June, 1965

Stolz, W. S.
Tannenbaum, H.
Carstensen, F. V.

CA650620 JB March 6, 1978  9:35 PM

1235	5	1235
1235	5	1235
1235	5	1235


************************



A Stochastic Approach to the Grammatical Coding of English

A computer program is described which will
assign each word in an English text to its form 
class or part of speech.  The program operates at relatively
high speed in only a limited storage space. 
 About half of the word-events in a corpus are identified
through the use <B>of a</B> small dictionary of function 
words and frequently occurring lexical words.  Some suffix
tests and logical-decision rules are employed 
to code additional words.  Finally, the remaining words
are assigned to one class or another on the basis 
of the most probable form classes to occur within the already
identified contexts.  The conditional probabilities 
used as a basis for this coding were empirically derived
from a separate hand-coded corpusn preliminary 
trials, the accuracy of the coder was 91% to 93%, with
obvious ways of improving the algorithm being 
suggested by an analysis of the results.

CACM June, 1965

Stolz, W. S.
Tannenbaum, H.
Carstensen, F. V.

CA650620 JB March 6, 1978  9:35 PM

1235	5	1235
1235	5	1235
1235	5	1235


************************

************************
Document:  CACM-3144.html
************************


A Model for and DIscussion of Multi-Interpreter Systems

A multi-interpreter system <B>is a</B> system in which programs execute
by virtue of being interpreted by other programs, which themselves may
either be interpreted (i.e. nested interpreters) or run directly on
the host machine.  The model reveals the anatomy of interpreters
and how these differ from procedures, and exhibits links
to protection domains and multiprocessor architectures.

CACM May, 1979

Manthey, M.

Interpreters, transfer-of-control, hierarchies

4.13 3.65

CA790505 DH August 21, 19791:14 PM

1458	4	3144
1523	4	3144
1603	4	3144
1698	4	3144
1747	4	3144
1748	4	3144
1854	4	3144
1877	4	3144
1960	4	3144
2377	4	3144
2378	4	3144
2497	4	3144
2558	4	3144
2625	4	3144
2626	4	3144
2632	4	3144
2748	4	3144
2840	4	3144
2865	4	3144
2866	4	3144
2868	4	3144
2868	4	3144
2870	4	3144
2876	4	3144
2898	4	3144
2941	4	3144
2972	4	3144
3043	4	3144
3105	4	3144
3105	4	3144
3105	4	3144
3128	4	3144
3144	4	3144
3144	4	3144
3144	4	3144
3144	4	3144
3144	4	3144
3144	4	3144
3144	4	3144
1471	5	3144
2298	5	3144
2491	5	3144
2597	5	3144
2624	5	3144
2625	5	3144
2632	5	3144
3144	5	3144
3144	5	3144
3144	5	3144


************************



A Model for and DIscussion of Multi-Interpreter Systems

A multi-interpreter <B>system is</B> a system in which programs execute
by virtue of being interpreted by other programs, which themselves may
either be interpreted (i.e. nested interpreters) or run directly on
the host machine.  The model reveals the anatomy of interpreters
and how these differ from procedures, and exhibits links
to protection domains and multiprocessor architectures.

CACM May, 1979

Manthey, M.

Interpreters, transfer-of-control, hierarchies

4.13 3.65

CA790505 DH August 21, 19791:14 PM

1458	4	3144
1523	4	3144
1603	4	3144
1698	4	3144
1747	4	3144
1748	4	3144
1854	4	3144
1877	4	3144
1960	4	3144
2377	4	3144
2378	4	3144
2497	4	3144
2558	4	3144
2625	4	3144
2626	4	3144
2632	4	3144
2748	4	3144
2840	4	3144
2865	4	3144
2866	4	3144
2868	4	3144
2868	4	3144
2870	4	3144
2876	4	3144
2898	4	3144
2941	4	3144
2972	4	3144
3043	4	3144
3105	4	3144
3105	4	3144
3105	4	3144
3128	4	3144
3144	4	3144
3144	4	3144
3144	4	3144
3144	4	3144
3144	4	3144
3144	4	3144
3144	4	3144
1471	5	3144
2298	5	3144
2491	5	3144
2597	5	3144
2624	5	3144
2625	5	3144
2632	5	3144
3144	5	3144
3144	5	3144
3144	5	3144


************************

************************
Document:  CACM-1390.html
************************


CONVERT

A programming language is described which
<B>is a</B>pplicable to problems conveniently described 
by transformation rules.  By this is meant that patterns
may be prescribed, each being associated with 
a skeleton, so that a series of such pairs may be searched
until a pattern is found which matches an 
expression to be transformed.  The conditions for a match
are governed by a code which also allows subexpressions 
to be identified and eventually substituted into the
corresponding skeleton.  The primitive patterns 
and primitive skeletons are described, as well as the
principle which allow their elaboration in to more 
complicated patterns and skeletons.  The advantages of the
language are that it allows one to apply transformation 
rules to lists and arrays as easily as strings, that both
patterns and skeletons may be defined recursively, 
and that as a consequence programs may be stated quite concisely.

CACM August, 1966

Guzman, A.
McIntosh, H. V.

CA660808 JB March 2, 1978  7:32 PM

1024	4	1390
1051	4	1390
1102	4	1390
1132	4	1390
1390	4	1390
1486	4	1390
1549	4	1390
1706	4	1390
1826	4	1390
1878	4	1390
378	4	1390
2060	4	1390
2155	4	1390
2168	4	1390
2719	4	1390
2723	4	1390
2838	4	1390
2842	4	1390
2855	4	1390
2879	4	1390
3077	4	1390
3080	4	1390
3106	4	1390
627	4	1390
106	4	1390
210	5	1390
1390	5	1390
1390	5	1390
1390	5	1390


************************



CONVERT

A programming language is described which
is applicable to problems conveniently described 
by transformation rules.  By this is meant that patterns
may be prescribed, each being associated with 
a skeleton, so that a series of such pairs may be searched
until a pattern is found which matches an 
expression to be transformed.  The conditions for a match
are governed by a code which also allows subexpressions 
to be identified and eventually substituted into the
corresponding skeleton.  The primitive patterns 
and primitive skeletons are described, as well as the
principle which allow their elaboration in to more 
complicated patterns and skeletons.  The advantages <B>of the</B>
language are that it allows one to apply transformation 
rules to lists and arrays as easily as strings, that both
patterns and skeletons may be defined recursively, 
and that as a consequence programs may be stated quite concisely.

CACM August, 1966

Guzman, A.
McIntosh, H. V.

CA660808 JB March 2, 1978  7:32 PM

1024	4	1390
1051	4	1390
1102	4	1390
1132	4	1390
1390	4	1390
1486	4	1390
1549	4	1390
1706	4	1390
1826	4	1390
1878	4	1390
378	4	1390
2060	4	1390
2155	4	1390
2168	4	1390
2719	4	1390
2723	4	1390
2838	4	1390
2842	4	1390
2855	4	1390
2879	4	1390
3077	4	1390
3080	4	1390
3106	4	1390
627	4	1390
106	4	1390
210	5	1390
1390	5	1390
1390	5	1390
1390	5	1390


************************

************************
Document:  CACM-0895.html
************************


A Computational Extension <B>of the</B> Variate Difference Method

Presented here is a computational extension
of the variate difference method as developed by 
G. Tintner [1].

CACM March, 1963

Scheinok, P. A.

CA630325 JB March 14, 1978  12:57 PM

895	5	895
895	5	895
895	5	895


************************



A Computational Extension of the Variate Difference Method

Presented here <B>is a</B> computational extension
of the variate difference method as developed by 
G. Tintner [1].

CACM March, 1963

Scheinok, P. A.

CA630325 JB March 14, 1978  12:57 PM

895	5	895
895	5	895
895	5	895


************************

************************
Document:  CACM-3134.html
************************


The Use of Normal Multiplication Tables
for Information Storage and Retrieval

This paper describes a method for the organization and retrieval <B>of a</B>ttribute 
based information systems, using the normal multiplication table as a directory
for the information system.  Algorithms for the organization an
d retrieval of information are described.  This method is particularly
suitable for queries requesting a group of information items,
 all of which possess a particular set of attributes (and possibly
some other attributes as well).  Several examples are given; the
results with respect to the number of disk accesses and disk space
are compared to other common approaches.  Algorithms evaluating
the appropriateness of the above approach to a given information system
are described.  For a certain class of information systems,
the normal multiplication table method yields far more rapid retrieval
with a more economical space requirement than conventional systems.  
Moreover this method incorporates an improved modification of the inverted 
file technique.

CACM March, 1979

Motzkin, D.

Information retrieval, inverted files, multiattribute retrieval,
multilist file, normal multiplication table, queries,
rapid retrieval, space economy

3.70 3.73 3.79

CA790305 DH May 21, 1979  9:46 AM

2140	4	3134
2452	4	3134
2575	4	3134
2765	4	3134
2901	4	3134
2966	4	3134
3134	4	3134
3134	4	3134
3134	4	3134
3134	4	3134
1976	5	3134
2160	5	3134
2524	5	3134
2990	5	3134
3134	5	3134
3134	5	3134
3134	5	3134


************************



The Use of Normal Multiplication Tables
for Information Storage and Retrieval

This paper describes a method for the organization and retrieval of attribute 
based information systems, using the normal multiplication table as a directory
for the information system.  Algorithms for the organization an
d retrieval of information are described.  This method is particularly
suitable for queries requesting a group of information items,
 all of which possess a particular set of attributes (and possibly
some other attributes as well).  Several examples are given; the
results with respect to the number of disk accesses and disk space
are compared to other common approaches.  Algorithms evaluating
the appropriateness <B>of the</B> above approach to a given information system
are described.  For a certain class of information systems,
the normal multiplication table method yields far more rapid retrieval
with a more economical space requirement than conventional systems.  
Moreover this method incorporates an improved modification of the inverted 
file technique.

CACM March, 1979

Motzkin, D.

Information retrieval, inverted files, multiattribute retrieval,
multilist file, normal multiplication table, queries,
rapid retrieval, space economy

3.70 3.73 3.79

CA790305 DH May 21, 1979  9:46 AM

2140	4	3134
2452	4	3134
2575	4	3134
2765	4	3134
2901	4	3134
2966	4	3134
3134	4	3134
3134	4	3134
3134	4	3134
3134	4	3134
1976	5	3134
2160	5	3134
2524	5	3134
2990	5	3134
3134	5	3134
3134	5	3134
3134	5	3134


************************

************************
Document:  CACM-1453.html
************************


A Nonrecursive Method of Syntax Specification

The use of the Kleene regular expression notation
for describing algebraic language syntax, 
in particular of ALGOL, is described in this paper. 
A FORTRAN II computer program for carrying out the 
elimination algorithm of Gorn,similar to Gaussian elimination
for linear systems <B>of a</B>lgebraic equations, 
is described.  This was applied to numerous smaller
languages, including some sublanguage of ALGOL.  
A hand calculation result of the application of the algorithm
to all of ALGOL is given, thus expressing 
the Revised ALGOL 1960 syntax in completely nonrecursive
terms, as far as its context-free portion is 
concerned.  This description in many ways is far more
intuitively understood than the previous recursive 
description, it is suggested.  The paper also includes
results of the machine program, which does not 
include a simplification algorithm.

CACM April, 1966

Carr III, J. W.
Weiland, J.

CA660402 JB March 3, 1978  11:02 AM

1086	4	1453
1132	4	1453
1234	4	1453
1263	4	1453
1263	4	1453
1265	4	1453
1270	4	1453
1323	4	1453
1358	4	1453
1379	4	1453
1380	4	1453
1453	4	1453
1453	4	1453
1464	4	1453
1484	4	1453
1491	4	1453
1498	4	1453
1613	4	1453
1614	4	1453
1781	4	1453
1825	4	1453
1860	4	1453
1945	4	1453
2083	4	1453
2178	4	1453
2179	4	1453
2252	4	1453
2325	4	1453
2341	4	1453
2546	4	1453
2645	4	1453
2652	4	1453
2684	4	1453
2842	4	1453
2929	4	1453
2934	4	1453
3069	4	1453
669	4	1453
679	4	1453
691	4	1453
761	4	1453
949	4	1453
989	4	1453
989	5	1453
1453	5	1453
1453	5	1453
1453	5	1453
1613	5	1453
3184	5	1453
987	6	1453
1086	6	1453
1134	6	1453
1453	6	1453
3184	6	1453


************************



A Nonrecursive Method of Syntax Specification

The use of the Kleene regular expression notation
for describing algebraic language syntax, 
in particular of ALGOL, is described in this paper. 
A FORTRAN II computer program for carrying out the 
elimination algorithm of Gorn,similar to Gaussian elimination
for linear systems of algebraic equations, 
is described.  This was applied to numerous smaller
languages, including some sublanguage of ALGOL.  
A hand calculation result of the application of the algorithm
to all of ALGOL is given, thus expressing 
the Revised ALGOL 1960 syntax in completely nonrecursive
terms, as far as its context-free portion is 
concerned.  This description in m<B>any way</B>s is far more
intuitively understood than the previous recursive 
description, it is suggested.  The paper also includes
results of the machine program, which does not 
include a simplification algorithm.

CACM April, 1966

Carr III, J. W.
Weiland, J.

CA660402 JB March 3, 1978  11:02 AM

1086	4	1453
1132	4	1453
1234	4	1453
1263	4	1453
1263	4	1453
1265	4	1453
1270	4	1453
1323	4	1453
1358	4	1453
1379	4	1453
1380	4	1453
1453	4	1453
1453	4	1453
1464	4	1453
1484	4	1453
1491	4	1453
1498	4	1453
1613	4	1453
1614	4	1453
1781	4	1453
1825	4	1453
1860	4	1453
1945	4	1453
2083	4	1453
2178	4	1453
2179	4	1453
2252	4	1453
2325	4	1453
2341	4	1453
2546	4	1453
2645	4	1453
2652	4	1453
2684	4	1453
2842	4	1453
2929	4	1453
2934	4	1453
3069	4	1453
669	4	1453
679	4	1453
691	4	1453
761	4	1453
949	4	1453
989	4	1453
989	5	1453
1453	5	1453
1453	5	1453
1453	5	1453
1613	5	1453
3184	5	1453
987	6	1453
1086	6	1453
1134	6	1453
1453	6	1453
3184	6	1453


************************



A Nonrecursive Method of Syntax Specification

The use <B>of the</B> Kleene regular expression notation
for describing algebraic language syntax, 
in particular of ALGOL, is described in this paper. 
A FORTRAN II computer program for carrying out the 
elimination algorithm of Gorn,similar to Gaussian elimination
for linear systems of algebraic equations, 
is described.  This was applied to numerous smaller
languages, including some sublanguage of ALGOL.  
A hand calculation result of the application of the algorithm
to all of ALGOL is given, thus expressing 
the Revised ALGOL 1960 syntax in completely nonrecursive
terms, as far as its context-free portion is 
concerned.  This description in many ways is far more
intuitively understood than the previous recursive 
description, it is suggested.  The paper also includes
results of the machine program, which does not 
include a simplification algorithm.

CACM April, 1966

Carr III, J. W.
Weiland, J.

CA660402 JB March 3, 1978  11:02 AM

1086	4	1453
1132	4	1453
1234	4	1453
1263	4	1453
1263	4	1453
1265	4	1453
1270	4	1453
1323	4	1453
1358	4	1453
1379	4	1453
1380	4	1453
1453	4	1453
1453	4	1453
1464	4	1453
1484	4	1453
1491	4	1453
1498	4	1453
1613	4	1453
1614	4	1453
1781	4	1453
1825	4	1453
1860	4	1453
1945	4	1453
2083	4	1453
2178	4	1453
2179	4	1453
2252	4	1453
2325	4	1453
2341	4	1453
2546	4	1453
2645	4	1453
2652	4	1453
2684	4	1453
2842	4	1453
2929	4	1453
2934	4	1453
3069	4	1453
669	4	1453
679	4	1453
691	4	1453
761	4	1453
949	4	1453
989	4	1453
989	5	1453
1453	5	1453
1453	5	1453
1453	5	1453
1613	5	1453
3184	5	1453
987	6	1453
1086	6	1453
1134	6	1453
1453	6	1453
3184	6	1453


************************

************************
Document:  CACM-2670.html
************************


Efficient Implementation <B>of a</B> Variable Projection
Algorithm for Nonlinear Least Squares Problems

Nonlinear least squares frequently arise for which
the variables to be solved for can be separated 
into a linear and a nonlinear part.  A variable projection
algorithm has been developed recently which 
is designed to take advantage of the structure of a problem
whose variables separate in this way.  This 
paper gives a slightly more efficient and slightly more
general version of this algorithm than has appeared 
earlier.

CACM March, 1974

Krogh, F. T.

nonlinear least squares, parameter estimation, variable projection

5.14 5.15

CA740313 JB January 18, 1978  10:49 AM

2670	5	2670
2670	5	2670
2670	5	2670


************************



Efficient Implementation of a Variable Projection
Algorithm for Nonlinear Least Squares Problems

Nonlinear least squares frequently arise for which
the variables to be solved for can be separated 
into a linear and a nonlinear part.  A variable projection
algorithm has been developed recently which 
is designed to take advantage <B>of the</B> structure of a problem
whose variables separate in this way.  This 
paper gives a slightly more efficient and slightly more
general version of this algorithm than has appeared 
earlier.

CACM March, 1974

Krogh, F. T.

nonlinear least squares, parameter estimation, variable projection

5.14 5.15

CA740313 JB January 18, 1978  10:49 AM

2670	5	2670
2670	5	2670
2670	5	2670


************************



Efficient Implementation of a Variable Projection
Algorithm for Nonlinear Least Squares Problems

Nonlinear least squares frequently arise for which
the variables to be solved for can be separated 
into a linear and a nonlinear part.  A variable projection
algorithm has been developed recently which 
is designed to take advantage of the structure of a problem
whose variables separate in this way.  This 
paper gives a slightly more efficient and slightly more
general version of th<B>is a</B>lgorithm than has appeared 
earlier.

CACM March, 1974

Krogh, F. T.

nonlinear least squares, parameter estimation, variable projection

5.14 5.15

CA740313 JB January 18, 1978  10:49 AM

2670	5	2670
2670	5	2670
2670	5	2670


************************

************************
Document:  CACM-1008.html
************************


Scheduling Meetings with a Computer

Computer scheduling of papers as it was developed
for the 1960 meeting <B>of the</B> Federation of 
American Societies for Experimental Biology (FASEB) is described.
 The FASEB meeting is the largest scientific 
meeting held in the United States each year.  The technique
developed for FASEB can be applied to schedule 
any meeting with parallel sessions.

CACM September, 1964

Schultz, C. K.
Brooks, A.
Schwartz, P.

CA640903 JB March 9, 1978  6:16 PM

1008	5	1008
1008	5	1008
1008	5	1008
2052	5	1008
1008	6	1008
1013	6	1008
1504	6	1008
1540	6	1008


************************



Scheduling Meetings with a Computer

Computer scheduling of papers as it was developed
for the 1960 meeting of the Federation of 
American Societies for Experimental Biology (FASEB) is described.
 The FASEB meeting <B>is the</B> largest scientific 
meeting held in the United States each year.  The technique
developed for FASEB can be applied to schedule 
any meeting with parallel sessions.

CACM September, 1964

Schultz, C. K.
Brooks, A.
Schwartz, P.

CA640903 JB March 9, 1978  6:16 PM

1008	5	1008
1008	5	1008
1008	5	1008
2052	5	1008
1008	6	1008
1013	6	1008
1504	6	1008
1540	6	1008


************************

************************
Document:  CACM-2758.html
************************


A Note on the LU Factorization <B>of a</B> Symmetric Matrix

CACM May, 1975

Evans, D. J.
Hatzopoulos, M.

symmetric matrices, factorization, test matrices,
matrix inversion, separable systems

5.14

CA750509 JB January 9, 1978  2:26 PM

2758	5	2758
2758	5	2758
2758	5	2758


************************

************************
Document:  CACM-2919.html
************************


The Programmer's Workbench-A Machine for Software Development

On almost all software development projects the
assumption is made that the program development 
function will be done on the same machine on which the
eventual system will run.  It is only when this 
production machine is unavailable or when its programming
environment is totally inadequate that alternatives 
are considered.  In this paper it is suggested that
there are many other situations where it would be 
advantageous to separate the program development and
main tenance function onto a specialized computer 
which is dedicated to that purpose.  Such a computer
is here called a Programmer's Workbench.  The four 
basic sections <B>of the</B> paper in troduce the subject,outline
the general concept, discuss areas where such 
an approach may prove beneficial, and describe
an operational system utilizing this concept.

CACM October, 1977

Ivie, E. L.

computer configurations, computer networks, software
development, software engineering, software 
main tenance, UNIX

3.2 3.5 3.7 3.8 4.0

CA771007 JB December 27, 1977  10:37 AM

2626	4	2919
2786	4	2919
2840	4	2919
2919	4	2919
2919	4	2919
2919	4	2919
3017	4	2919
3110	4	2919
3174	4	2919
2536	5	2919
2593	5	2919
2629	5	2919
2919	5	2919
2919	5	2919
2919	5	2919


************************



The Programmer's Workbench-A Machine for Software Development

On almost all software development projects the
assumption is made <B>that the</B> program development 
function will be done on the same machine on which the
eventual system will run.  It is only when this 
production machine is unavailable or when its programming
environment is totally inadequate that alternatives 
are considered.  In this paper it is suggested that
there are many other situations where it would be 
advantageous to separate the program development and
main tenance function onto a specialized computer 
which is dedicated to that purpose.  Such a computer
is here called a Programmer's Workbench.  The four 
basic sections of the paper in troduce the subject,outline
the general concept, discuss areas where such 
an approach may prove beneficial, and describe
an operational system utilizing this concept.

CACM October, 1977

Ivie, E. L.

computer configurations, computer networks, software
development, software engineering, software 
main tenance, UNIX

3.2 3.5 3.7 3.8 4.0

CA771007 JB December 27, 1977  10:37 AM

2626	4	2919
2786	4	2919
2840	4	2919
2919	4	2919
2919	4	2919
2919	4	2919
3017	4	2919
3110	4	2919
3174	4	2919
2536	5	2919
2593	5	2919
2629	5	2919
2919	5	2919
2919	5	2919
2919	5	2919


************************

************************
Document:  CACM-1497.html
************************


On the Normalization Requirement of
Divisor in Divide- and- Correct Methods

This paper presents an analysis on the normalization
requirement <B>of the</B> divisor in a divide-and-correct 
method.  This analysis is made subject to the condition
that not more than one correction is required 
to obtain the true quotient character, from the trial
estimate got from the division of a two-precision 
segment of every partial remainder by a suitably rounded
single-precision divisor.  (This segmented division 
is denoted here as a (2, 1) precision basic division.)
 It is found that the normalization requirement 
could be narrowed down to a smaller range of divisors,
provided the magnitude of the character next to 
the leading character of the divisor is known.  If,
however, the normalization is to be eliminated one 
has to choose proper higher precision segments of operands
for the basic division.  Also considered is 
the possibility of eliminating the normalization by an
increase on the number of corrections on the quotient 
estimate got from a (2, 1) precision basic division.
 It is shown that such a scheme is economical only 
for small radices.

CACM December, 1967

Krishnamurthy, E. V.
Nandi, S. K.

CA671210 JB February 26, 1978  2:15 PM

1026	4	1497
1258	4	1497
1258	4	1497
1292	4	1497
1292	4	1497
1497	4	1497
1497	4	1497
1497	4	1497
1497	4	1497
1593	4	1497
1975	4	1497
1975	4	1497
2605	4	1497
107	5	1497
1026	5	1497
1292	5	1497
1497	5	1497
1497	5	1497
1497	5	1497
1593	5	1497
1975	5	1497
1026	6	1497
1292	6	1497
1497	6	1497


************************



On the Normalization Requirement of
Divisor in Divide- and- Correct Methods

This paper presents an analysis on the normalization
requirement of the divisor in a divide-and-correct 
method.  Th<B>is a</B>nalysis is made subject to the condition
that not more than one correction is required 
to obtain the true quotient character, from the trial
estimate got from the division of a two-precision 
segment of every partial remainder by a suitably rounded
single-precision divisor.  (This segmented division 
is denoted here as a (2, 1) precision basic division.)
 It is found that the normalization requirement 
could be narrowed down to a smaller range of divisors,
provided the magnitude of the character next to 
the leading character of the divisor is known.  If,
however, the normalization is to be eliminated one 
has to choose proper higher precision segments of operands
for the basic division.  Also considered is 
the possibility of eliminating the normalization by an
increase on the number of corrections on the quotient 
estimate got from a (2, 1) precision basic division.
 It is shown that such a scheme is economical only 
for small radices.

CACM December, 1967

Krishnamurthy, E. V.
Nandi, S. K.

CA671210 JB February 26, 1978  2:15 PM

1026	4	1497
1258	4	1497
1258	4	1497
1292	4	1497
1292	4	1497
1497	4	1497
1497	4	1497
1497	4	1497
1497	4	1497
1593	4	1497
1975	4	1497
1975	4	1497
2605	4	1497
107	5	1497
1026	5	1497
1292	5	1497
1497	5	1497
1497	5	1497
1497	5	1497
1593	5	1497
1975	5	1497
1026	6	1497
1292	6	1497
1497	6	1497


************************



On the Normalization Requirement of
Divisor in Divide- and- Correct Methods

This paper presents an analysis on the normalization
requirement of the divisor <B>in a</B> divide-and-correct 
method.  This analysis is made subject to the condition
that not more than one correction is required 
to obtain the true quotient character, from the trial
estimate got from the division of a two-precision 
segment of every partial remainder by a suitably rounded
single-precision divisor.  (This segmented division 
is denoted here as a (2, 1) precision basic division.)
 It is found that the normalization requirement 
could be narrowed down to a smaller range of divisors,
provided the magnitude of the character next to 
the leading character of the divisor is known.  If,
however, the normalization is to be eliminated one 
has to choose proper higher precision segments of operands
for the basic division.  Also considered is 
the possibility of eliminating the normalization by an
increase on the number of corrections on the quotient 
estimate got from a (2, 1) precision basic division.
 It is shown that such a scheme is economical only 
for small radices.

CACM December, 1967

Krishnamurthy, E. V.
Nandi, S. K.

CA671210 JB February 26, 1978  2:15 PM

1026	4	1497
1258	4	1497
1258	4	1497
1292	4	1497
1292	4	1497
1497	4	1497
1497	4	1497
1497	4	1497
1497	4	1497
1593	4	1497
1975	4	1497
1975	4	1497
2605	4	1497
107	5	1497
1026	5	1497
1292	5	1497
1497	5	1497
1497	5	1497
1497	5	1497
1593	5	1497
1975	5	1497
1026	6	1497
1292	6	1497
1497	6	1497


************************



On the Normalization Requirement of
Divisor in Divide- and- Correct Methods

This paper presents an analysis on the normalization
requirement of the divisor in a divide-and-correct 
method.  This analysis is made subject to the condition
that not more than one correction is required 
to obtain the true quotient character, from the trial
estimate got from the division <B>of a</B> two-precision 
segment of every partial remainder by a suitably rounded
single-precision divisor.  (This segmented division 
is denoted here as a (2, 1) precision basic division.)
 It is found that the normalization requirement 
could be narrowed down to a smaller range of divisors,
provided the magnitude of the character next to 
the leading character of the divisor is known.  If,
however, the normalization is to be eliminated one 
has to choose proper higher precision segments of operands
for the basic division.  Also considered is 
the possibility of eliminating the normalization by an
increase on the number of corrections on the quotient 
estimate got from a (2, 1) precision basic division.
 It is shown that such a scheme is economical only 
for small radices.

CACM December, 1967

Krishnamurthy, E. V.
Nandi, S. K.

CA671210 JB February 26, 1978  2:15 PM

1026	4	1497
1258	4	1497
1258	4	1497
1292	4	1497
1292	4	1497
1497	4	1497
1497	4	1497
1497	4	1497
1497	4	1497
1593	4	1497
1975	4	1497
1975	4	1497
2605	4	1497
107	5	1497
1026	5	1497
1292	5	1497
1497	5	1497
1497	5	1497
1497	5	1497
1593	5	1497
1975	5	1497
1026	6	1497
1292	6	1497
1497	6	1497


************************



On the Normalization Requirement of
Divisor in Divide- and- Correct Methods

This paper presents an analysis on the normalization
requirement of the divisor in a divide-and-correct 
method.  This analysis is made subject to the condition
that not more than one correction is required 
to obtain the true quotient character, from the trial
estimate got from the division of a two-precision 
segment of every partial remainder by a suitably rounded
single-precision divisor.  (This segmented division 
is denoted here as a (2, 1) precision basic division.)
 It is found <B>that the</B> normalization requirement 
could be narrowed down to a smaller range of divisors,
provided the magnitude of the character next to 
the leading character of the divisor is known.  If,
however, the normalization is to be eliminated one 
has to choose proper higher precision segments of operands
for the basic division.  Also considered is 
the possibility of eliminating the normalization by an
increase on the number of corrections on the quotient 
estimate got from a (2, 1) precision basic division.
 It is shown that such a scheme is economical only 
for small radices.

CACM December, 1967

Krishnamurthy, E. V.
Nandi, S. K.

CA671210 JB February 26, 1978  2:15 PM

1026	4	1497
1258	4	1497
1258	4	1497
1292	4	1497
1292	4	1497
1497	4	1497
1497	4	1497
1497	4	1497
1497	4	1497
1593	4	1497
1975	4	1497
1975	4	1497
2605	4	1497
107	5	1497
1026	5	1497
1292	5	1497
1497	5	1497
1497	5	1497
1497	5	1497
1593	5	1497
1975	5	1497
1026	6	1497
1292	6	1497
1497	6	1497


************************

************************
Document:  CACM-2151.html
************************


User Program Measurement <B>in a</B> Time-Shared Environment

A general discussion of the measurement of
software systems is followed by a description of 
a hardware and software scheme for measuring user programs
in a time-shared environment.  The TX-2 computer 
at MIT Lincoln Laboratory was used for the implementation
of such a system and the characteristics of 
this implementation are reported.  A scenario showing
the system in use is presented.  Finally, it is 
shown how other time-sharing systems may provide similar measuring facilities.

CACM October, 1971

Nemeth, A. G.
Rovner, P. D.

operating systems, multiprogramming systems, time-sharing
systems, software measurement, user program 
measurement, measurement technology, TX-2 computer,
virtual computers, performance improvement

4.30 4.32 4.42 4.43

CA711005 JB February 2, 1978  1:05 PM

1957	4	2151
2151	4	2151
2151	4	2151
2151	4	2151
2318	4	2151
3103	4	2151
3148	4	2151
1653	5	2151
1747	5	2151
1860	5	2151
2151	5	2151
2151	5	2151
2151	5	2151
2719	5	2151
2967	5	2151
1626	6	2151
210	6	2151
2151	6	2151
2151	6	2151
2167	6	2151
2210	6	2151
2645	6	2151
2657	6	2151


************************



User Program Measurement in a Time-Shared Environment

A general discussion <B>of the</B> measurement of
software systems is followed by a description of 
a hardware and software scheme for measuring user programs
in a time-shared environment.  The TX-2 computer 
at MIT Lincoln Laboratory was used for the implementation
of such a system and the characteristics of 
this implementation are reported.  A scenario showing
the system in use is presented.  Finally, it is 
shown how other time-sharing systems may provide similar measuring facilities.

CACM October, 1971

Nemeth, A. G.
Rovner, P. D.

operating systems, multiprogramming systems, time-sharing
systems, software measurement, user program 
measurement, measurement technology, TX-2 computer,
virtual computers, performance improvement

4.30 4.32 4.42 4.43

CA711005 JB February 2, 1978  1:05 PM

1957	4	2151
2151	4	2151
2151	4	2151
2151	4	2151
2318	4	2151
3103	4	2151
3148	4	2151
1653	5	2151
1747	5	2151
1860	5	2151
2151	5	2151
2151	5	2151
2151	5	2151
2719	5	2151
2967	5	2151
1626	6	2151
210	6	2151
2151	6	2151
2151	6	2151
2167	6	2151
2210	6	2151
2645	6	2151
2657	6	2151


************************



User Program Measurement in a Time-Shared Environment

A general discussion of the measurement of
software systems is followed by a description of 
a hardware and software scheme for measuring user programs
in a time-shared environment.  The TX-2 computer 
at MIT Lincoln Laboratory was used for the implementation
of such a system <B>and the</B> characteristics of 
this implementation are reported.  A scenario showing
the system in use is presented.  Finally, it is 
shown how other time-sharing systems may provide similar measuring facilities.

CACM October, 1971

Nemeth, A. G.
Rovner, P. D.

operating systems, multiprogramming systems, time-sharing
systems, software measurement, user program 
measurement, measurement technology, TX-2 computer,
virtual computers, performance improvement

4.30 4.32 4.42 4.43

CA711005 JB February 2, 1978  1:05 PM

1957	4	2151
2151	4	2151
2151	4	2151
2151	4	2151
2318	4	2151
3103	4	2151
3148	4	2151
1653	5	2151
1747	5	2151
1860	5	2151
2151	5	2151
2151	5	2151
2151	5	2151
2719	5	2151
2967	5	2151
1626	6	2151
210	6	2151
2151	6	2151
2151	6	2151
2167	6	2151
2210	6	2151
2645	6	2151
2657	6	2151


************************

************************
Document:  CACM-1454.html
************************


A Simple User-Oriented Compiler Source Language
for Programming Automatic Test Equipment

For the nonprogrammer, difficulty in using
a language increases rapidly with the number of 
nonproblem-oriented conventions.  A simple language, even
if inelegant, which considers the user's background 
as part of the problem may be more effective than a source
language containing subtle and more powerful 
capabilities.  The language described in this paper is
used to write computer programs which test electronic 
equipment.  Because this testing process contains few
complex ideas, there is little need for the elegance 
and redundancy <B>of a</B> highly syntax-oriented language.
 A simple and direct language will suffice for the 
problem.  The eventual users of this language are military
depot personnel who cannot he expected to 
have computer programming skill or significant programming
training.  For this nonprogramming-oriented 
user, it was essential to create a language using familiar
engineering statements; programming-oriented 
conventions would have unnecessarily complicated his task.

CACM April, 1966

Scheff, B. H.

CA660401 JB March 3, 1978  11:09 AM

1454	5	1454
1454	5	1454
1454	5	1454


************************



A Simple User-Oriented Compiler Source Language
for Programming Automatic Test Equipment

For the nonprogrammer, difficulty in using
a language increases rapidly with the number of 
nonproblem-oriented conventions.  A simple language, even
if inelegant, which considers the user's background 
as part <B>of the</B> problem may be more effective than a source
language containing subtle and more powerful 
capabilities.  The language described in this paper is
used to write computer programs which test electronic 
equipment.  Because this testing process contains few
complex ideas, there is little need for the elegance 
and redundancy of a highly syntax-oriented language.
 A simple and direct language will suffice for the 
problem.  The eventual users of this language are military
depot personnel who cannot he expected to 
have computer programming skill or significant programming
training.  For this nonprogramming-oriented 
user, it was essential to create a language using familiar
engineering statements; programming-oriented 
conventions would have unnecessarily complicated his task.

CACM April, 1966

Scheff, B. H.

CA660401 JB March 3, 1978  11:09 AM

1454	5	1454
1454	5	1454
1454	5	1454


************************

************************
Document:  CACM-2083.html
************************


Creation and Control of Internal Data Bases
Under a Fortran Programming Environment

A method is described for the definition of a user's COMMON structure
and the automatic generation <B>of the</B> necessary COMMON, DIMENSION, EQUIVALENCE,
and type declarations for each of the user's routines.  The definition
for the COMMON is contained in an easy to modify form, thus
allowing the control of general communications of data between routines.
The described system has been implemented on the IBM 7094,
CDC 6000 series, and the IBM 360.  The method has proved to be invaluable
for the definition and control of COMMON in many large-scale programs.

CACM April, 1970

DeSalvio, A. J.
Purdy, J. G.
Rau, J.

data base, Fortran, common, common equivalencing,
subroutine communication, data communication

3.73 4.12 4.43

CA700401 JB February 13, 1978  3:34 PM

1086	4	2083
1132	4	2083
1234	4	2083
1263	4	2083
1265	4	2083
1270	4	2083
1323	4	2083
1358	4	2083
1379	4	2083
1380	4	2083
1453	4	2083
1464	4	2083
1484	4	2083
1491	4	2083
1498	4	2083
1613	4	2083
1614	4	2083
1781	4	2083
1825	4	2083
1845	4	2083
1860	4	2083
1900	4	2083
2083	4	2083
2083	4	2083
2154	4	2083
2178	4	2083
2179	4	2083
2252	4	2083
2270	4	2083
2325	4	2083
2341	4	2083
2546	4	2083
2645	4	2083
2652	4	2083
2684	4	2083
2693	4	2083
2842	4	2083
2929	4	2083
2934	4	2083
3069	4	2083
669	4	2083
679	4	2083
691	4	2083
761	4	2083
949	4	2083
989	4	2083
988	5	2083
2083	5	2083
2083	5	2083
2083	5	2083
3184	5	2083


************************



Creation and Control of Internal Data Bases
Under a Fortran Programming Environment

A method is described for the definition of a user's COMMON structure
and the automatic generation of the necessary COMMON, DIMENSION, EQUIVALENCE,
and type declarations for each of the user's routines.  The definition
for the COMMON is contained <B>in a</B>n easy to modify form, thus
allowing the control of general communications of data between routines.
The described system has been implemented on the IBM 7094,
CDC 6000 series, and the IBM 360.  The method has proved to be invaluable
for the definition and control of COMMON in many large-scale programs.

CACM April, 1970

DeSalvio, A. J.
Purdy, J. G.
Rau, J.

data base, Fortran, common, common equivalencing,
subroutine communication, data communication

3.73 4.12 4.43

CA700401 JB February 13, 1978  3:34 PM

1086	4	2083
1132	4	2083
1234	4	2083
1263	4	2083
1265	4	2083
1270	4	2083
1323	4	2083
1358	4	2083
1379	4	2083
1380	4	2083
1453	4	2083
1464	4	2083
1484	4	2083
1491	4	2083
1498	4	2083
1613	4	2083
1614	4	2083
1781	4	2083
1825	4	2083
1845	4	2083
1860	4	2083
1900	4	2083
2083	4	2083
2083	4	2083
2154	4	2083
2178	4	2083
2179	4	2083
2252	4	2083
2270	4	2083
2325	4	2083
2341	4	2083
2546	4	2083
2645	4	2083
2652	4	2083
2684	4	2083
2693	4	2083
2842	4	2083
2929	4	2083
2934	4	2083
3069	4	2083
669	4	2083
679	4	2083
691	4	2083
761	4	2083
949	4	2083
989	4	2083
988	5	2083
2083	5	2083
2083	5	2083
2083	5	2083
3184	5	2083


************************



Creation and Control of Internal Data Bases
Under a Fortran Programming Environment

A method is described for the definition <B>of a</B> user's COMMON structure
and the automatic generation of the necessary COMMON, DIMENSION, EQUIVALENCE,
and type declarations for each of the user's routines.  The definition
for the COMMON is contained in an easy to modify form, thus
allowing the control of general communications of data between routines.
The described system has been implemented on the IBM 7094,
CDC 6000 series, and the IBM 360.  The method has proved to be invaluable
for the definition and control of COMMON in many large-scale programs.

CACM April, 1970

DeSalvio, A. J.
Purdy, J. G.
Rau, J.

data base, Fortran, common, common equivalencing,
subroutine communication, data communication

3.73 4.12 4.43

CA700401 JB February 13, 1978  3:34 PM

1086	4	2083
1132	4	2083
1234	4	2083
1263	4	2083
1265	4	2083
1270	4	2083
1323	4	2083
1358	4	2083
1379	4	2083
1380	4	2083
1453	4	2083
1464	4	2083
1484	4	2083
1491	4	2083
1498	4	2083
1613	4	2083
1614	4	2083
1781	4	2083
1825	4	2083
1845	4	2083
1860	4	2083
1900	4	2083
2083	4	2083
2083	4	2083
2154	4	2083
2178	4	2083
2179	4	2083
2252	4	2083
2270	4	2083
2325	4	2083
2341	4	2083
2546	4	2083
2645	4	2083
2652	4	2083
2684	4	2083
2693	4	2083
2842	4	2083
2929	4	2083
2934	4	2083
3069	4	2083
669	4	2083
679	4	2083
691	4	2083
761	4	2083
949	4	2083
989	4	2083
988	5	2083
2083	5	2083
2083	5	2083
2083	5	2083
3184	5	2083


************************



Creation and Control of Internal Data Bases
Under a Fortran Programming Environment

A method is described for the definition of a user's COMMON structure
<B>and the</B> automatic generation of the necessary COMMON, DIMENSION, EQUIVALENCE,
and type declarations for each of the user's routines.  The definition
for the COMMON is contained in an easy to modify form, thus
allowing the control of general communications of data between routines.
The described system has been implemented on the IBM 7094,
CDC 6000 series, and the IBM 360.  The method has proved to be invaluable
for the definition and control of COMMON in many large-scale programs.

CACM April, 1970

DeSalvio, A. J.
Purdy, J. G.
Rau, J.

data base, Fortran, common, common equivalencing,
subroutine communication, data communication

3.73 4.12 4.43

CA700401 JB February 13, 1978  3:34 PM

1086	4	2083
1132	4	2083
1234	4	2083
1263	4	2083
1265	4	2083
1270	4	2083
1323	4	2083
1358	4	2083
1379	4	2083
1380	4	2083
1453	4	2083
1464	4	2083
1484	4	2083
1491	4	2083
1498	4	2083
1613	4	2083
1614	4	2083
1781	4	2083
1825	4	2083
1845	4	2083
1860	4	2083
1900	4	2083
2083	4	2083
2083	4	2083
2154	4	2083
2178	4	2083
2179	4	2083
2252	4	2083
2270	4	2083
2325	4	2083
2341	4	2083
2546	4	2083
2645	4	2083
2652	4	2083
2684	4	2083
2693	4	2083
2842	4	2083
2929	4	2083
2934	4	2083
3069	4	2083
669	4	2083
679	4	2083
691	4	2083
761	4	2083
949	4	2083
989	4	2083
988	5	2083
2083	5	2083
2083	5	2083
2083	5	2083
3184	5	2083


************************

************************
Document:  CACM-3002.html
************************


A Record and File Partitioning Model

One of the main objectives in the design of
a file system is the reduction of storage and data 
transfer costs.  This paper presents a model in which
several  requests access the file system, and each 
request requires information from one or more variable
length data-items.  The probabilities of access 
<B>and the</B> distribution of each data-item's length are assumed
to be known, and to be mutually independent. 
The file system uses one or more storage devices, and
each record may be partitioned into subrecords 
that are stored on different devices.  One of the subrecords
is designated as the primary record; when 
a request for a record is made, the primary record is
first accessed, and other subrecords are accessed 
only if the pertinent information is not stored in the
primary record.  The model that is presented in 
this paper, both as a nonlinear programming model and
a mixed integer programming model, is a very general 
one; several types of file systems may be derived from
it by an appropriate selection of its parameters. 
 This model has already been used in the optimization of
library routines' storage at a large scale operating 
system.

CACM January, 1977

Babad, J. M.

file system, file design, file partitioning, record partitioning

3.73

CA770103 JB January 3, 1978  12:28 AM

3002	5	3002
3002	5	3002
3002	5	3002
3168	5	3002
2965	6	3002
3002	6	3002


************************



A Record and File Partitioning Model

One <B>of the</B> main objectives in the design of
a file system is the reduction of storage and data 
transfer costs.  This paper presents a model in which
several  requests access the file system, and each 
request requires information from one or more variable
length data-items.  The probabilities of access 
and the distribution of each data-item's length are assumed
to be known, and to be mutually independent. 
The file system uses one or more storage devices, and
each record may be partitioned into subrecords 
that are stored on different devices.  One of the subrecords
is designated as the primary record; when 
a request for a record is made, the primary record is
first accessed, and other subrecords are accessed 
only if the pertinent information is not stored in the
primary record.  The model that is presented in 
this paper, both as a nonlinear programming model and
a mixed integer programming model, is a very general 
one; several types of file systems may be derived from
it by an appropriate selection of its parameters. 
 This model has already been used in the optimization of
library routines' storage at a large scale operating 
system.

CACM January, 1977

Babad, J. M.

file system, file design, file partitioning, record partitioning

3.73

CA770103 JB January 3, 1978  12:28 AM

3002	5	3002
3002	5	3002
3002	5	3002
3168	5	3002
2965	6	3002
3002	6	3002


************************



A Record and File Partitioning Model

One of the main objectives in the design of
a file <B>system is</B> the reduction of storage and data 
transfer costs.  This paper presents a model in which
several  requests access the file system, and each 
request requires information from one or more variable
length data-items.  The probabilities of access 
and the distribution of each data-item's length are assumed
to be known, and to be mutually independent. 
The file system uses one or more storage devices, and
each record may be partitioned into subrecords 
that are stored on different devices.  One of the subrecords
is designated as the primary record; when 
a request for a record is made, the primary record is
first accessed, and other subrecords are accessed 
only if the pertinent information is not stored in the
primary record.  The model that is presented in 
this paper, both as a nonlinear programming model and
a mixed integer programming model, is a very general 
one; several types of file systems may be derived from
it by an appropriate selection of its parameters. 
 This model has already been used in the optimization of
library routines' storage at a large scale operating 
system.

CACM January, 1977

Babad, J. M.

file system, file design, file partitioning, record partitioning

3.73

CA770103 JB January 3, 1978  12:28 AM

3002	5	3002
3002	5	3002
3002	5	3002
3168	5	3002
2965	6	3002
3002	6	3002


************************



A Record and File Partitioning Model

One of the main objectives in the design of
a file system is the reduction of storage and data 
transfer costs.  This paper presents a model in which
several  requests access the file system, and each 
request requires information from one or more variable
length data-items.  The probabilities of access 
and the distribution of each data-item's length are assumed
to be known, and to be mutually independent. 
The file system uses one or more storage devices, and
each record may be partitioned into subrecords 
that are stored on different devices.  One of the subrecords
is designated as the primary record; when 
a request for a record is made, the primary record is
first accessed, and other subrecords are accessed 
only if the pertinent information is not stored in the
primary record.  The model that is presented in 
this paper, both as a nonlinear programming model and
a mixed integer programming model, <B>is a</B> very general 
one; several types of file systems may be derived from
it by an appropriate selection of its parameters. 
 This model has already been used in the optimization of
library routines' storage at a large scale operating 
system.

CACM January, 1977

Babad, J. M.

file system, file design, file partitioning, record partitioning

3.73

CA770103 JB January 3, 1978  12:28 AM

3002	5	3002
3002	5	3002
3002	5	3002
3168	5	3002
2965	6	3002
3002	6	3002


************************



A Record and File Partitioning Model

One of the main objectives in the design of
a file system <B>is the</B> reduction of storage and data 
transfer costs.  This paper presents a model in which
several  requests access the file system, and each 
request requires information from one or more variable
length data-items.  The probabilities of access 
and the distribution of each data-item's length are assumed
to be known, and to be mutually independent. 
The file system uses one or more storage devices, and
each record may be partitioned into subrecords 
that are stored on different devices.  One of the subrecords
is designated as the primary record; when 
a request for a record is made, the primary record is
first accessed, and other subrecords are accessed 
only if the pertinent information is not stored in the
primary record.  The model that is presented in 
this paper, both as a nonlinear programming model and
a mixed integer programming model, is a very general 
one; several types of file systems may be derived from
it by an appropriate selection of its parameters. 
 This model has already been used in the optimization of
library routines' storage at a large scale operating 
system.

CACM January, 1977

Babad, J. M.

file system, file design, file partitioning, record partitioning

3.73

CA770103 JB January 3, 1978  12:28 AM

3002	5	3002
3002	5	3002
3002	5	3002
3168	5	3002
2965	6	3002
3002	6	3002


************************



A Record and File Partitioning Model

One of the main objectives in the design of
a file system is the reduction of storage and data 
transfer costs.  This paper presents a model in which
several  requests access the file system, and each 
request requires information from one or more variable
length data-items.  The probabilities <B>of a</B>ccess 
and the distribution of each data-item's length are assumed
to be known, and to be mutually independent. 
The file system uses one or more storage devices, and
each record may be partitioned into subrecords 
that are stored on different devices.  One of the subrecords
is designated as the primary record; when 
a request for a record is made, the primary record is
first accessed, and other subrecords are accessed 
only if the pertinent information is not stored in the
primary record.  The model that is presented in 
this paper, both as a nonlinear programming model and
a mixed integer programming model, is a very general 
one; several types of file systems may be derived from
it by an appropriate selection of its parameters. 
 This model has already been used in the optimization of
library routines' storage at a large scale operating 
system.

CACM January, 1977

Babad, J. M.

file system, file design, file partitioning, record partitioning

3.73

CA770103 JB January 3, 1978  12:28 AM

3002	5	3002
3002	5	3002
3002	5	3002
3168	5	3002
2965	6	3002
3002	6	3002


************************



A Record and File Partitioning Model

One of the main objectives in the design of
a file system is the reduction of storage and data 
transfer costs.  This paper presents a model in which
several  requests access the file system, and each 
request requires information from one or more variable
length data-items.  The probabilities of access 
and the distribution of each data-item's length are assumed
to be known, and to be mutually independent. 
The file system uses one or more storage devices, and
each record may be partitioned into subrecords 
that are stored on different devices.  One of the subrecords
is designated as the primary record; when 
a request for a record is made, the primary record is
first accessed, and other subrecords are accessed 
only if the pertinent information is not stored in the
primary record.  The model that is presented in 
this paper, both as a nonlinear programming model and
a mixed integer programming model, is a very general 
one; several <B>types of</B> file systems may be derived from
it by an appropriate selection of its parameters. 
 This model has already been used in the optimization of
library routines' storage at a large scale operating 
system.

CACM January, 1977

Babad, J. M.

file system, file design, file partitioning, record partitioning

3.73

CA770103 JB January 3, 1978  12:28 AM

3002	5	3002
3002	5	3002
3002	5	3002
3168	5	3002
2965	6	3002
3002	6	3002


************************

************************
Document:  CACM-1046.html
************************


A Compiler-Building System Developed by Brooker and Morris

In a number of articles published during the
past two years, R. A. Brooker and D. Morris (joined 
by J. Rohl in their most recent paper have presented
a very interesting programming system <B>that the</B>y 
have developed for the Ferranti Atlas computer.  The
present paper describes some of the major features 
of their system. it expands on some points that the original
authors cover briefly, and treats only very 
lightly some topics to which they devote considerable space.
 The purpose of this paper is purely expository. 
 Except in some very small details, and in some comments,
it does not intentionally depart from or add 
to the material published in the listed references.

CACM July, 1964

Rosen, S.

CA640701 JB March 9, 1978  8:47 PM

1046	4	1046
1105	4	1046
1139	4	1046
1140	4	1046
1234	4	1046
1263	4	1046
1265	4	1046
1496	4	1046
1781	4	1046
1824	4	1046
2126	4	1046
2546	4	1046
464	4	1046
584	4	1046
631	4	1046
653	4	1046
680	4	1046
763	4	1046
795	4	1046
799	4	1046
945	4	1046
1046	5	1046
1046	5	1046
1046	5	1046
1781	5	1046
404	5	1046
123	6	1046
196	6	1046
919	6	1046
990	6	1046
1007	6	1046
1046	6	1046
1131	6	1046
1139	6	1046
1140	6	1046
1149	6	1046
1198	6	1046
1215	6	1046
1223	6	1046
1265	6	1046
1303	6	1046
1323	6	1046
1358	6	1046
1366	6	1046
1421	6	1046
1460	6	1046
1462	6	1046
1463	6	1046
1467	6	1046
1468	6	1046
1477	6	1046
1491	6	1046
1496	6	1046
1531	6	1046
1535	6	1046
1565	6	1046
1601	6	1046
1602	6	1046
1613	6	1046
1614	6	1046
1626	6	1046
1641	6	1046
1787	6	1046
1788	6	1046
205	6	1046
224	6	1046
249	6	1046
288	6	1046
316	6	1046
381	6	1046
398	6	1046
11	6	1046
404	6	1046
410	6	1046
463	6	1046
464	6	1046
483	6	1046
3184	6	1046
3188	6	1046
584	6	1046
600	6	1046
680	6	1046
691	6	1046
763	6	1046
799	6	1046


************************



A Compiler-Building System Developed by Brooker and Morris

In a number of articles published during the
past two years, R. A. Brooker and D. Morris (joined 
by J. Rohl in their most recent paper have presented
a very interesting programming system that they 
have developed for the Ferranti Atlas computer.  The
present paper describes some <B>of the</B> major features 
of their system. it expands on some points that the original
authors cover briefly, and treats only very 
lightly some topics to which they devote considerable space.
 The purpose of this paper is purely expository. 
 Except in some very small details, and in some comments,
it does not intentionally depart from or add 
to the material published in the listed references.

CACM July, 1964

Rosen, S.

CA640701 JB March 9, 1978  8:47 PM

1046	4	1046
1105	4	1046
1139	4	1046
1140	4	1046
1234	4	1046
1263	4	1046
1265	4	1046
1496	4	1046
1781	4	1046
1824	4	1046
2126	4	1046
2546	4	1046
464	4	1046
584	4	1046
631	4	1046
653	4	1046
680	4	1046
763	4	1046
795	4	1046
799	4	1046
945	4	1046
1046	5	1046
1046	5	1046
1046	5	1046
1781	5	1046
404	5	1046
123	6	1046
196	6	1046
919	6	1046
990	6	1046
1007	6	1046
1046	6	1046
1131	6	1046
1139	6	1046
1140	6	1046
1149	6	1046
1198	6	1046
1215	6	1046
1223	6	1046
1265	6	1046
1303	6	1046
1323	6	1046
1358	6	1046
1366	6	1046
1421	6	1046
1460	6	1046
1462	6	1046
1463	6	1046
1467	6	1046
1468	6	1046
1477	6	1046
1491	6	1046
1496	6	1046
1531	6	1046
1535	6	1046
1565	6	1046
1601	6	1046
1602	6	1046
1613	6	1046
1614	6	1046
1626	6	1046
1641	6	1046
1787	6	1046
1788	6	1046
205	6	1046
224	6	1046
249	6	1046
288	6	1046
316	6	1046
381	6	1046
398	6	1046
11	6	1046
404	6	1046
410	6	1046
463	6	1046
464	6	1046
483	6	1046
3184	6	1046
3188	6	1046
584	6	1046
600	6	1046
680	6	1046
691	6	1046
763	6	1046
799	6	1046


************************



A Compiler-Building System Developed by Brooker and Morris

In a number <B>of a</B>rticles published during the
past two years, R. A. Brooker and D. Morris (joined 
by J. Rohl in their most recent paper have presented
a very interesting programming system that they 
have developed for the Ferranti Atlas computer.  The
present paper describes some of the major features 
of their system. it expands on some points that the original
authors cover briefly, and treats only very 
lightly some topics to which they devote considerable space.
 The purpose of this paper is purely expository. 
 Except in some very small details, and in some comments,
it does not intentionally depart from or add 
to the material published in the listed references.

CACM July, 1964

Rosen, S.

CA640701 JB March 9, 1978  8:47 PM

1046	4	1046
1105	4	1046
1139	4	1046
1140	4	1046
1234	4	1046
1263	4	1046
1265	4	1046
1496	4	1046
1781	4	1046
1824	4	1046
2126	4	1046
2546	4	1046
464	4	1046
584	4	1046
631	4	1046
653	4	1046
680	4	1046
763	4	1046
795	4	1046
799	4	1046
945	4	1046
1046	5	1046
1046	5	1046
1046	5	1046
1781	5	1046
404	5	1046
123	6	1046
196	6	1046
919	6	1046
990	6	1046
1007	6	1046
1046	6	1046
1131	6	1046
1139	6	1046
1140	6	1046
1149	6	1046
1198	6	1046
1215	6	1046
1223	6	1046
1265	6	1046
1303	6	1046
1323	6	1046
1358	6	1046
1366	6	1046
1421	6	1046
1460	6	1046
1462	6	1046
1463	6	1046
1467	6	1046
1468	6	1046
1477	6	1046
1491	6	1046
1496	6	1046
1531	6	1046
1535	6	1046
1565	6	1046
1601	6	1046
1602	6	1046
1613	6	1046
1614	6	1046
1626	6	1046
1641	6	1046
1787	6	1046
1788	6	1046
205	6	1046
224	6	1046
249	6	1046
288	6	1046
316	6	1046
381	6	1046
398	6	1046
11	6	1046
404	6	1046
410	6	1046
463	6	1046
464	6	1046
483	6	1046
3184	6	1046
3188	6	1046
584	6	1046
600	6	1046
680	6	1046
691	6	1046
763	6	1046
799	6	1046


************************

************************
Document:  CACM-1268.html
************************


Logarithm <B>of a</B> Complex Number (Algorithm 243 [B3])

CACM May, 1965

Boothroyd, J.

CA650502 JB March 7, 1978  3:11 PM

1268	5	1268
1268	5	1268
1268	5	1268
1858	5	1268
1268	6	1268
1857	6	1268


************************

************************
Document:  CACM-2666.html
************************


On Lions' Counter Example for Gotlieb's Method
for the Construction of School Timetables

The timetable problem <B>is a</B>n essentially discrete
problem. Although the discrete problem may 
have no feasible solution, there may exist a solution
to the equivalent continuous problem.  An example 
is given, for which the nondiscrete solution can be
interpreted as a set of timetables, differing from 
week to week, which together satisfy the long-term
requirements of the timetable problem.

CACM April, 1974

Smith, G.
Sefton, I. M.

combinatorial, multi-index problem, necessary
conditions, schedule, school timetable, timetable

3.51 5.39

CA740404 JB January 18, 1978  10:02 AM

2666	5	2666
2666	5	2666
2666	5	2666


************************



On Lions' Counter Example for Gotlieb's Method
for the Construction of School Timetables

The timetable problem is an essentially discrete
problem. Although the discrete problem may 
have no feasible solution, there may exist a solution
to the equivalent continuous problem.  An example 
is given, for which the nondiscrete solution can be
interpreted as a set of timetables, differing from 
week to week, which together satisfy the long-term
requirements <B>of the</B> timetable problem.

CACM April, 1974

Smith, G.
Sefton, I. M.

combinatorial, multi-index problem, necessary
conditions, schedule, school timetable, timetable

3.51 5.39

CA740404 JB January 18, 1978  10:02 AM

2666	5	2666
2666	5	2666
2666	5	2666


************************

