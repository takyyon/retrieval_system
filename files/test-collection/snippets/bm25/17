Snippets for the query:  Languages and compilers for parallel processors, especially highly horizontal microcoded machines; code compaction
************************
Total Hits:  7
************************

************************
Document:  CACM-2195.html
************************


On the Optimal Detection of Curves in Noisy Pictures

A technique for recognizing systems of lines
is presented.  In this technique the heuristic 
of the problem is not embedded in the recognition algorithm
but is expressed in a figure of merit.   
A multistage decision process is then able to recognize
in the input picture the optimal system of lines 
according to the given figure of merit.  Due to the
global approach, greater flexibility and adequacy 
in the particular problem is achieved.  The relation
between the structure of the figure of merit and 
the complexity of the optimization process is then discussed.
 The method described is suitable <B>for parallel</B> 
processing because the operations relative to each
state can be computed in parallel, and the number
of stages is equal to the length N of the curves (or
to log2 N if the approximate method is used).

CACM May, 1971

Montanari, U.

picture processing, picture recognition, picture
description, curve detection, line detection, 
edge detection,optimal detection, heuristic methods,
global recognition, parallel processing, dynamic 
programming, interaction graph, secondary optimization problem

3.63 3.66 5.42

CA710504 JB February 3, 1978  2:49 PM

1663	4	2195
2195	4	2195
2679	4	2195
1190	5	2195
2195	5	2195
2195	5	2195
2195	5	2195
2883	5	2195
2195	6	2195


************************

************************
Document:  CACM-2851.html
************************


Formal Verification of Parallel Programs

Two formal models <B>for parallel</B> computation
are presented: an abstract conceptual model and 
a parallel-program model.  The former model does not
distinguish between control and data states.  The 
latter model includes the capability for the representation
of an infinite set of control states by allowing 
there to be arbitrarily many instruction pointers (or
processes) executing the program.  An induction 
principle is presented which treats the control and
data state sets on the same ground.  Through the 
use of "place variables," it is observed that certain
correctness conditions can be expressed without 
enumeration of the set of all possible control states.
 Examples are presented in which the induction 
principle is used to demonstrate proofs of mutual exclusion.
 It is shown that assertions-oriented proof 
methods are special cases of the induction principle.
A special case of the assertions method, which 
is called parallel place assertions, is shown to be
incomplete.  A formalization of "deadlock" is then 
presented. The concept of a "norm" is introduced, which
yields an extension, to the deadlock problem, 
of Floyd's technique for proving termination.  Also discussed
is an extension of the program model which 
allows each process to have its own local variables
and permits shared global variables.  Correctness 
of certain forms of implementation is also discussed.
 An Appendix is included which relates this work 
to previous work on the satisfiability of certain logical formulas.

CACM July, 1976

Keller, R. M.

parallel program, correctness, verification,
assertions, deadlock, mutual exclusion, Petrinet

4.6 5.2 6.9 8.1

CA760702 JB January 4, 1978  1:20 PM

2228	4	2851
2280	4	2851
2379	4	2851
2320	4	2851
2482	4	2851
2597	4	2851
2740	4	2851
2777	4	2851
2851	4	2851
2851	4	2851
2895	4	2851
2912	4	2851
2920	4	2851
2946	4	2851
3128	4	2851
1877	5	2851
2150	5	2851
2851	5	2851
2851	5	2851
2851	5	2851


************************

************************
Document:  CACM-2714.html
************************


Merging with Parallel Processors

Consider two linearly ordered sets A, B, |A|=m,
|B|=n, m<=n, and p, p<=m, parallel processors 
working synchronously.  The paper presents an algorithm
for merging A and B with the p <B>parallel processors,</B> 
which requires at most 2[log2 (2m+1)]+[3m/p] + [m/p][log2
(n/m)] steps.  If n = (2^B)m (B an integer), 
the algorithm requires at most 2[log2 (m+1)] + [m/p](2+B)
steps.  In the case where m and n are of the 
same order of magnitude, i.e. n=km with k being a constant,
the algorithm requires 2[log2 (m+1)] + [m/p](3+k) 
steps.  These performances compare very favorably with
the previous best parallel merging algorithm, 
Batcher's algorithm, which requires n/p + ((m+n)/2p)log2 m
steps in the general case and km/p + ((k+1)/2)(m/p)log2 
m in the special case where n=km.

CACM October, 1975

Gavril, F.

parallel processing, parallel merging, parallel binary insertion

5.31

CA751005 JB January 6, 1978  10:50 AM

2714	4	2714
3075	4	2714
2664	5	2714
2714	5	2714
2714	5	2714
2714	5	2714
3075	5	2714
2289	6	2714
2557	6	2714
2664	6	2714
2714	6	2714


************************

************************
Document:  CACM-2685.html
************************


The Parallel Execution of DO Loops

Methods are developed for the parallel execution
of different iterations of a DO loop.  Both 
asynchronous multiprocessor computers and array computers
are considered.  Practical application to the 
design of <B>compilers for</B> such computers is discussed.

CACM February, 1974

Lamport, L.

parallel computing, multiprocessor computers,
array computers, vector computers, loops

4.12 5.24

CA740204 JB January 18, 1978  1:14 PM

2685	5	2685
2685	5	2685
2685	5	2685
2785	5	2685
2876	5	2685
2433	6	2685
2632	6	2685
2685	6	2685
2685	6	2685


************************

************************
Document:  CACM-2266.html
************************


A Highly Parallel Algorithm for Approximating
All Zeros of a Polynomial with Only Real Zeros

An algorithm is described based on Newton's
method which simultaneously approximates all zeros 
of a polynomial with only real zeros.  The algorithm, which
is conceptually suitable <B>for parallel</B> computation, 
determines its own starting values so that convergence
to the zeros is guaranteed.  Multiple zeros and 
their multiplicity are readily determined.  At no
point in the method is polynomial deflation used.

CACM November, 1972

Patrick, M. L.

parallel numerical algorithms, real polynomials,
real zeros, Newton's method, starting values, 
guaranteed convergence

5.15

CA721103 JB January 27, 1978  2:35 PM

2266	5	2266
2266	5	2266
2266	5	2266
2660	5	2266
2266	6	2266


************************

************************
Document:  CACM-2289.html
************************


Cellular Arrays for the Solution of Graph Problems

A cellular array is a two-dimensional, checkerboard
type interconnection of identical modules 
(or cells), where each cell contains a few bits of
memory and a small amount of combinational logic, 
and communicates mainly with its immediate neighbors
in the array.  The chief computational advantage 
offered by cellular arrays is the improvement in speed
achieved by virtue of the possibilities <B>for parallel</B> 
processing.  In this paper it is shown that cellular
arrays are inherently well suited for the solution 
of many graph problems.  For example, the adjacency
matrix of a graph is easily mapped onto an array; 
each matrix element is stored in one cell of the array,
and typical row and column operations are readily 
implemented by simple cell logic.  A major challenge
in the effective use of cellular arrays for the 
solution of graph problems is the determination of algorithms
that exploit the possibilities for parallelism, 
especially for problems whose solutions appear to be inherently
serial.  In particular, several parallelized 
algorithms are presented for the solution of certain
spanning tree, distance, and path problems, with 
direct applications to wire routing, PERT chart analysis,
and the analysis of many types of networks. 
 These algorithms exhibit a computation time that in
many cases grows at a rate not exceeding log2 n, 
where n is the number of nodes in the graph.  Straightforward
cellular implementations of the well-known 
serial algorithms for these problems require about n
steps, and noncellular implementations require from 
n^2 to n^3 steps.

CACM September, 1972

Levitt, K. N.
Kautz, W. H.

graph theory, cellular logic-in-memory arrays,
parallel processing, special purpose computers, 
algorithms for distance and spanning tree problems

5.32 6.22 6.5

CA720901 JB January 30, 1978  9:16 AM

2289	5	2289
2289	5	2289
2289	5	2289
3075	5	2289
3156	5	2289
2289	6	2289
2289	6	2289
2557	6	2289
2664	6	2289
2714	6	2289
2973	6	2289
3075	6	2289


************************

************************
Document:  CACM-2886.html
************************


Semantic Evaluation from Left to Right

This paper describes attribute grammars and their
use for the definition of programming languages 
<B>and compilers</B>; a formal definition of attribute grammars
and a discussion of some of its important aspects 
are included. The paper concentrates on the evaluation
of semantic attributes in a few passes from left 
to right over the derivation tree of a program.  A
condition for an attribute grammar is given which 
assures that the semantics of any program can be evaluated
in a single pass over the derivation tree, 
and an algorithm is discussed which decides how many
passes from left to right are in general necessary, 
given the attribute grammar. These notions are explained
in terms of an example grammar which describes 
the scope rules of Algol 60.  Practical questions, such
as the relative efficiency of different evaluation 
schemes, and the ease of adapting the attribute grammar
of a given programming language to the left-to-right 
evaluation scheme are discussed.

CACM February, 1976

Bochmann, G. V.

attribute grammars, semantics of programming languages,
semantic attributes, left-to-right parsing, 
multipass compilers, semantic evaluation, semantic conditions

4.10 4.20 5.23 5.24

CA760201 JB January 5, 1978  9:54 AM

2886	4	2886
2301	5	2886
2703	5	2886
2886	5	2886
2886	5	2886
2886	5	2886
2886	6	2886


************************

