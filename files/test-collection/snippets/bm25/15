Snippets for the query:  find all descriptions of file handling in operating systems based on multiple processes and message passing.
************************
Total Hits:  53
************************

************************
Document:  CACM-2542.html
************************


A Software Design and Evaluation System

A critical failure of current software system
design and implementation methodology is that 
the performance of a proposed design is not evaluated
before it is actually implemented.  In this paper 
the reasons for this failure are explored, and a new methodology
which overcomes many of the difficulties 
is proposed.  A system which integrates performance evaluation
with design and implementation is described. 
 This system is <B>based on</B> a simple, high level language
which is used to describe the evolving system 
at all stages of its development.  The source language
description is used as direct input to performance 
analysis and simulation routines.  Using the performance
information obtained from these routines as 
feedback, the problems which adversely affect performance
are detected early enough so that they can 
be corrected without costly major reimplementation of the proposed system.

CACM February, 1973

Graham, R. M.
Clancy, G. J. Jr.
DeVaney, D. B.

operating system development, language processing
software evaluation, compilers, system programming, 
supervisory systems, debugging, program maintenance,
modeling, system integration, simulation

4.0 4.12 4.22 4.30 4.42 4.43 8.1

CA730206 JB January 24, 1978  2:07 PM

2542	5	2542
2542	5	2542
2542	5	2542


************************

************************
Document:  CACM-1199.html
************************


A Computer Center Simulation Project

Today's computation centers are <B>based on</B> rapidly
changing technologies of hardware and software 
systems.  It is difficult, therefore, to base decisions
on experience; in most instances, the benefits 
of comparable experience for a given problem situation
are not available.  In this paper, a mathematical 
model of the Lockheed Central Computer Center is formulated
that describes the operation of a computation 
center in terms of information nets, decision processes,
and control functions.  Experiments performed 
with this model, the results of the experiments,
and the application of the results are discussed.

CACM September, 1965

Hutchinson, G. K.

CA650907JB March 6, 1978  7:29 PM

1199	5	1199
1199	5	1199
1199	5	1199


************************

************************
Document:  CACM-2424.html
************************


Dynamic Verification of Operating System Decisions

Dynamic verification of a decision implies
that every time the decision is made there is a 
consistency check performed on the decision using independent
hardware and software.  The dynamic verification 
of operating system decisions is used on the PRIME system
being designed and constructed at the University 
of California, Berkeley.  PRIME is an experimental time-sharing
which is to have the properties of continuous 
availability, data privacy, and cost effectiveness.
 The technique of dynamic verification allows the 
construction of an operating system which does not make certain
decisions improperly even in the presence 
of a single hardware or software fault.  Furthermore,
multiple faults lead to unreliable operation only 
if the faults happen to reinforce each other.  On PRIME,
dynamic verification is used to ensure that 
one user's information cannot become available to another
user gratuitously even in the presence of a 
single hardware or software fault.the amount of additional
hardware and software required for dynamic 
verification can be modest.

CACM November, 1973

Fabry, R. S.

<B>operating systems</B>, data security, fault tolerance,
software reliability, data privacy, program 
verification, modular computer systems

4.32

CA731102 JB January 20, 1978  10:56 AM

1828	4	2424
1854	4	2424
1877	4	2424
1960	4	2424
2150	4	2424
2317	4	2424
2319	4	2424
2377	4	2424
2342	4	2424
2376	4	2424
2379	4	2424
2424	4	2424
2482	4	2424
2618	4	2424
2632	4	2424
2704	4	2424
2723	4	2424
2738	4	2424
2740	4	2424
2741	4	2424
2867	4	2424
3184	4	2424
1749	5	2424
2424	5	2424
2424	5	2424
2424	5	2424


************************

************************
Document:  CACM-2801.html
************************


Storage-Efficient Representation of Decimal Data

Usually n decimal digits are represented by
4n bits in computers.  Actually, two BCD digits 
can be compressed optimally and reversibly into 7 bits,
and three digits into 10 bits, by a very simple 
algorithm <B>based on</B> the fixed-length combination of two
variable field-length encodings.  In over half 
of the cases the compressed code results from the conventional
BCD code by simple removal of redundant 
0 bits.  A long decimal message can be subdivided into
three-digit blocks, and separately compressed; 
the result differs from the asymptotic minimum length
by only 0.34 percent.  The hardware requirement 
is small, and the mappings can be done manually.

CACM January, 1975

Chi Chen, T.
Ho, I. T.

binary-coded decimal digits, decimal data storage

6.32 6.34

CA750110 JB January 12, 1978  9:42 AM

2729	5	2801
2801	5	2801
2801	5	2801
2801	5	2801
2288	6	2801
2801	6	2801


************************

************************
Document:  CACM-2307.html
************************


Dynamic Document Processing

The current role of computers in automatic
document processing is briefly outlined, and some 
reasons are given why the early promise of library automation
and of the mechanization of documentation 
processes has not been fulfilled.  A new dynamic document
environment is then outlined in which clustered
files are searched and information is retrieved following
an interactive user-controlled search process. 
 Methods are described for an automatic query modification
<B>based on</B> user needs, and for a continuous 
reorganization of the stored information as a function of
earlier file processing and of normal collection 
growth.  The proposed procedures provide powerful tools
for information retrieval and for the control 
of dynamic library collections in which new items
are continually added and old ones are retired.

CACM July, 1972

Salton, G.

automatic indexing, automatic search and retrieval,
iterative searching, mechanized library processing, 
collection growth, collection retirement, feedback search

3.62 3.71 3.73 3.74

CA720721 JB January 30, 1978  10:59 AM

2307	5	2307
2307	5	2307
2307	5	2307


************************

************************
Document:  CACM-3026.html
************************


The Evolution of the Sperry Univac 1100
Series: A His tory, Analysis, and Projection

The 1100 series systems are Sperry Univac's
large-scale main frame computer systems.  Beginning 
with the 1107 in 1962, the 1100 series has progressed
through a succession of eight compatible computer 
models to the latest system, the 1100/80, introduced
in 1977.  The 1100 series hardware architecture 
is <B>based on</B> a 36-bit word, ones complement structure
which obtains one operand from storage and one from 
a high-speed register, or two operands from high-speed
registers.  The 1100 Operating System is designed 
to support a symmetrical multiprocessor configuration
simultaneously providing multiprogrammed batch, 
timesharing, and transaction environments.

CACM January, 1978

Borgherson, B.
Hanson, M.
Hartley, P.

1100 computer series, computer architecture, multiprocessing
languages, data management systems, 
end user facilities, executive control software

1.3 4.0 4.20 4.30 4.32 4.33 4.35 6.0 6.21 6.30

CA780104 JB March 28, 1978  5:38 PM

3026	5	3026
3026	5	3026
3026	5	3026


************************

************************
Document:  CACM-2622.html
************************


A User Authentication Scheme Not Requiring Secrecy in the Computer

In many computer <B>operating systems</B> a user authenticates
himself by entering a secret password 
known solely to himself and the system.  The system compares
this password with one recorded in a Password 
Table which is available to only the authentication
program.  The integrity of the system depends on 
keeping the table secret.  In this paper a password
scheme is presented which does not require secrecy 
in the computer.    All aspects of the system, including
all relevant code and data bases, may be known 
by anyone attempting to intrude.  The scheme is based
on using a function H which the would-be intruder 
is unable to invert.  This function is applied to the
user's password and the result compared to a table 
entry, a match being interpreted as authentication of
the user.  The intruder may know all about H and 
have access to the table, but he can penetrate the system
only if he can invert H to determine an input 
that produces a given output.  This paper discusses
issues surrounding selection of a suitable H.  Two 
different plausible arguments are given that penetration
would be exceedingly difficult, and it is then 
argued that more rigorous results are unlikely.  Finally,
some human engineering problems relating to 
the scheme are discussed.

CACM August, 1974

Evans, A. Jr.
Kantrowitz, W.
Weiss, E.

operating system security, security, authentication,
passwords, one-way encryption, cryptology

4.39 5.39

CA740802 JB January 17, 1978  10:19 AM

2622	5	2622
2622	5	2622
2622	5	2622


************************

************************
Document:  CACM-2582.html
************************


Improving Locality by Critical Working Sets

A new approach to program locality improvement
via restructuring is described.  The method 
is particularly suited to those systems where primary memory
is managed according to a working set strategy. 
 It is <B>based on</B> the concept of critical working set, a
working set which does not contain the next memory 
reference.  The data the method operates upon are extracted from
a trace of the program to be restructured. 
 It is shown that, except in some special cases, the
method is not optimum.  However, the experimental 
results obtained by using the method to restructure an
interactive text editor and the file system module 
of an operating system have shown its substantial superiority
over the other methods proposed in the 
literature.

CACM November, 1974

Ferrari, D.

program restructuring, program segmentation, locality
improvement, memory hierarchies, virtual 
memory, multiprogramming, restructuring techniques, static
restructuring, dynamic restructuring, working 
set strategy, critical working set

4.32 4.39 4.43 4.49 4.9

CA741102 JB January 16, 1978  10:50 AM

1892	4	2582
1901	4	2582
2085	4	2582
2095	4	2582
2218	4	2582
2277	4	2582
2319	4	2582
2319	4	2582
2329	4	2582
2358	4	2582
2365	4	2582
2373	4	2582
2380	4	2582
2434	4	2582
2499	4	2582
2501	4	2582
2582	4	2582
2582	4	2582
2582	4	2582
2582	4	2582
2669	4	2582
2669	4	2582
2828	4	2582
2863	4	2582
2881	4	2582
2928	4	2582
2996	4	2582
3006	4	2582
3054	4	2582
3067	4	2582
3152	4	2582
1751	5	2582
1924	5	2582
2017	5	2582
2130	5	2582
2582	5	2582
2582	5	2582
2582	5	2582


************************

************************
Document:  CACM-3141.html
************************


An Improved Algorithm for Decentralized Extrema-Finding
in Circular Configurations of Processes

This note presents an improvement to LeLann's
algorithm for finding the largest (or smallest) of a set of uniquely
numbered processes arranged in a circle, in which no central
controller exists and the number of processes is not known a priori.
This decentralized algorithm uses a technique of selective
message extinction in order to achieve an average number of
message passes of order (n log n) rather than O(n2).  

CACM May, 1979

Chang, E.
Roberts, R.

Decentralized algorithms, distributed systems, <B>operating systems</B>

4.32 4.35 5.25 5.32

CA790502 DH June 5, 1979  2:35 PM

3141	5	3141
3141	5	3141
3141	5	3141


************************

************************
Document:  CACM-1961.html
************************


An Efficient Search Algorithm to Find the Elementary Circuits of a Graph

A theoretically most efficient search algorithm is presented
which uses an exhaustive search to <B>find all</B> of the elementary
circuits of a graph.  The algorithm can be easily modified to find all
of the elementary circuits with a particular attribute such as
length.  A rigorous proof of the algorithm is given as well as an example
of its application.  Empirical bounds are presented relating
the speed of the algorithm to the number of vertices and the number
of arcs.  The speed is also related to the number of circuits
in the graph to give a relation between speed and complexity.
Extensions to undirected and s-graphs are discussed.

CACM December, 1970

Tiernan, J. C.

algorithm, graph theory, circuit search
algorithm, path search algorithm, searching

3.74 5.32

CA701202 JB February 9, 1978 4:12 PM

1847	4	1961
1961	4	1961
1961	4	1961
1961	4	1961
2052	4	1961
2177	4	1961
2763	4	1961
1369	5	1961
1504	5	1961
1847	5	1961
1961	5	1961
1961	5	1961
1961	5	1961
2430	5	1961
1961	6	1961


************************

************************
Document:  CACM-2750.html
************************


A Cost Oriented Algorithm for Data Set Allocation in Storage Hierarchies

Data set allocation in today's multilevel
storage systems is usually <B>based on</B> qualitative, 
ad hoc decisions.  While it would be desirable to obtain
an optimal solution to this allocation problem, 
it is clear that the number of parameters involved makes
it intractable to straight-forward solution. 
 In such a situation, we must find a set of assumptions
which simplify the problem greatly, but which 
still provide a basis for considering all significant
cost elements. This paper presents such a first, 
quantitative allocation step.  It considers many of the
significant detailed costs of system utilization, 
data storage, data staging, and data migration.  Although
many avenues of further improvement are available, 
the present algorithm seems to be usefully accurate.
As such, it can aid in quantifying the problems 
of data set allocation, storage system configuration, and new device designs.

CACM June, 1975

Lum, V. Y.
Senko, M. E
Wang, C. P.
Ling, H.

data set allocation, hierarchical storage, storage
system configuration, data staging, data migration, 
storage allocation analysis

3.5 3.9 6.2

CA750603 JB January 9, 1978  1:31 PM

2750	5	2750
2750	5	2750
2750	5	2750


************************

************************
Document:  CACM-3127.html
************************


Thoth, a Portable Real-Time Operating System 

Thoth isa real-time operating system which is designed to be portable
over a large set of machines.  It is currently running on two minicomputers
with quite different architectures.  Both the system and application
programs which use it are written in a high-level language.
Because the system is implemented by the same software on different
hardware, it has the same interface to user programs.  Hence,
application programs which use Thoth are  highly portable.  Thoth
encourages structuring programs as networks of communicating processes 
by providing efficient interprocess communication primitives.

CACM February, 1979

Cheriton, D.
Malcolm, M.
Melen, L.
Sager, G.

Portability, real time, <B>operating systems</B>, minicomputer

3.80 4.30 4.35

CA790206 DH April 12, 1979  9:10 AM

2319	4	3127
2378	4	3127
2320	4	3127
2632	4	3127
2738	4	3127
2740	4	3127
2868	4	3127
2928	4	3127
3127	4	3127
3127	4	3127
2080	5	3127
2277	5	3127
3127	5	3127
3127	5	3127
3127	5	3127


************************

************************
Document:  CACM-2002.html
************************


AMESPLOT-A Higher Level Data Plotting Software System

AMESPLOT is an extensible software system designed to make the display of 
data as simple, painless, and neat as possible.  The system described is 
hardware-independent and has been implemented on a variety of installations,
of different manufacturers, having diverse configurations.  The elements 
common to all types of data plots are outlined and the way in which these 
elements may be combined into a system <B>based on</B> simple modules is demonstrated.
These modules are specified independently and are independent of the axis
systems or other attributes of the plot.  This enables plots of any
complexity to be constructed by adding or replacing modules.  The
basic syntax of AMESPLOT is outlined, and a brief description is given
of its current utility software, consisting of "macros" to produce
self-scaled plots, formal tablets of text-interspersed with subplots,
map coastlines, and 3-D plots.  The system was formulate
d in a way such that the user could supply the minimum of information,
and it should be fully integrable with user's program written
in most conventional higher languages.  The functions of positioning,
locating, and scaling (in the layout of multiple subplots) of
axes, labels, and all other elements of the plot are handled automatically
by the software system unless the user specifies otherwise.  The structuring 
of plots from multiple, independent, self-contained subplots is described.
Transformation, projection, scaling, rotation, or shifting of entire plots or 
subplots by the action of one or more simple modules is possible.  The user 
may interact freely with AMESPLOT at three levels, enabling him to construct 
his own data markers, alphabetic characters, and transformations, and
to produce a variety of artistic and other effects.

CACM September, 1970

Hirschsoln, I.

computer graphics, data potting, data display
syntax, hardware independent software,
display device independent software, plot elements, self-scaled plots,
user interaction, tablet organization, map display, projection

4.13 4.29 4.49 4.9

CA700903 JB February 10, 1978 2:08 PM

2003	4	2002
2002	4	2002
2002	4	2002
2152	4	2002
1767	5	2002
1937	5	2002
2002	5	2002
2002	5	2002
2002	5	2002


************************

************************
Document:  CACM-3068.html
************************


A Model for Verification of Data Security in Operating Systems

Program verification applied to kernel architectures
forms a promising method for providing 
uncircumventably secure, shared computer systems.  A
precise definition of data security is developed 
here in terms of a general model for <B>operating systems</B>.
 This model is suitable as a basis for verifying 
many of those properties of an operating system which
are necessary to assure reliable enforcement of 
security.  The application of this approach to the
UCLA secure operating system is also discussed. 

CACM September, 1978

Popek, G..
Farber, D.

Operating systems, security, protection, program verification

4.35 5.24

CA780904 DH February 5, 1979  2:40 PM

2021	4	3068
2222	4	3068
2227	4	3068
2315	4	3068
2326	4	3068
2470	4	3068
2732	4	3068
2865	4	3068
2896	4	3068
2943	4	3068
3014	4	3068
3068	4	3068
3068	4	3068
3077	4	3068
3143	4	3068
1834	5	3068
2869	5	3068
3068	5	3068
3068	5	3068
3068	5	3068
3105	5	3068
1471	6	3068
2625	6	3068
2632	6	3068
2868	6	3068
2939	6	3068
3068	6	3068


************************

************************
Document:  CACM-2740.html
************************


A Large Semaphore Based Operating System

The paper describes the internal structure of
a large operating system as a set of cooperating 
sequential processes.  The processes synchronize by
means of semaphores and extended semaphores (queue 
semaphores).  The number of parallel processes is carefully
justified, and the various semaphore constructions 
are explained.  The system is proved to be free of "deadly
embrace" (deadlock).  The design principle 
is an alternative to Dijkstra's hierarchical structuring
of <B>operating systems</B>.  The project management 
and the performance are discussed, too.  The operating
system is the first large one using the RC 4000 
multiprogramming system.

CACM July, 1975

Lauesen, S.

cooperating processes, operating system, semaphores,
semaphore applications, queue semaphores, 
deadlock, deadly embrace, hierarchical structuring, multiprogramming,
operating system structure, asynchronous 
structuring, buffering, parallel processes, synchronizing
primitives, reentrant code, RC 4000, project 
management, time schedule, debugging, project planning,
project scheduling, reliability, program proving, 
coroutines, correctness, program maintenance, software paging

4.30 4.31 4.32 4.42 4.43 5.24

CA750702 JB January 9, 1978  10:32 AM

1828	4	2740
1854	4	2740
1877	4	2740
1960	4	2740
2150	4	2740
2228	4	2740
2280	4	2740
2317	4	2740
2319	4	2740
2319	4	2740
2377	4	2740
2378	4	2740
2342	4	2740
2376	4	2740
2379	4	2740
2379	4	2740
2320	4	2740
2424	4	2740
2482	4	2740
2482	4	2740
2618	4	2740
2632	4	2740
2632	4	2740
2704	4	2740
2723	4	2740
2738	4	2740
2738	4	2740
2740	4	2740
2740	4	2740
2740	4	2740
2741	4	2740
2851	4	2740
2867	4	2740
2868	4	2740
2920	4	2740
3127	4	2740
3184	4	2740
1749	5	2740
1877	5	2740
2080	5	2740
2740	5	2740
2740	5	2740
2740	5	2740


************************

************************
Document:  CACM-2379.html
************************


The Design of the Venus Operating System

The Venus Operating System is an experimental
multiprogramming system which supports five or 
six concurrent users on a small computer.  The system was
produced to test the effect of machine architecture 
on complexity of software.  The system is defined by
a combination of microprograms and software.  The 
microprogram defines a machine with some unusual architectural
feature; the software exploits these features 
to define the operating system as simply as possible.
 In this paper the development of the system is 
described, with particular emphasis on the principles which guided the design.

CACM March, 1972

Liskov, B. H.

<B>operating systems</B>, system design, levels of abstraction,
machine architecture, microprogramming, 
segments, semaphores, multiprogramming, virtual machines,
processes, process communication, virtual devices, 
data sharing, resource management, deadlock

4.30 4.32 4.41 6.21

CA720302 JB January 31, 1978  3:16 PM

1828	4	2379
1854	4	2379
1877	4	2379
1960	4	2379
2150	4	2379
2228	4	2379
2280	4	2379
2280	4	2379
2317	4	2379
2319	4	2379
2377	4	2379
2342	4	2379
2376	4	2379
2379	4	2379
2379	4	2379
2379	4	2379
2424	4	2379
2482	4	2379
2482	4	2379
2482	4	2379
2500	4	2379
2618	4	2379
2632	4	2379
2704	4	2379
2723	4	2379
2738	4	2379
2740	4	2379
2740	4	2379
2741	4	2379
2851	4	2379
2867	4	2379
2920	4	2379
3184	4	2379
1749	5	2379
1877	5	2379
2228	5	2379
2379	5	2379
2379	5	2379
2379	5	2379
2704	5	2379
2867	5	2379
1247	6	2379
1552	6	2379
1749	6	2379
1749	6	2379
2247	6	2379
2356	6	2379
2379	6	2379
2379	6	2379
2673	6	2379


************************

************************
Document:  CACM-1750.html
************************


Considerations in the Design of a Multiple
Computer System with Extended Core Storage

The use of large quantities of addressable
(but not executable) fast random access memory to 
heighten the multiprogramming performance of a multicomputer system
is discussed.  The general design 
of the hardware arrangement and the software components
and functions of such a system are based on a 
planned configuration of dual CDC 6600's that share one
million words of extended core storage.  In the 
generalization of such a design, special emphasis is
placed on estimating expected gains when compared 
with the traditional configuration of separate and independent
computers without extended core storage. 
 An observation is made on the use of conventional, slower
speed, random access storage devices in place 
of the faster memory.

CACM May, 1968

Fuchel, K.
Heller, S.

multiple computer systems, extended core storage,
multiprogrammed <B>operating systems</B>, multiprocessor 
operating systems, control data corporation 6600, operating system with ECS

4.30 4.32

CA680506 JB February 23, 1978  9:27 AM

1750	5	1750
1750	5	1750
1750	5	1750
2988	5	1750
1750	6	1750


************************



Considerations in the Design of a Multiple
Computer System with Extended Core Storage

The use of large quantities of addressable
(but not executable) fast random access memory to 
heighten the multiprogramming performance of a multicomputer system
is discussed.  The general design 
of the hardware arrangement and the software components
and functions of such a system are <B>based on</B> a 
planned configuration of dual CDC 6600's that share one
million words of extended core storage.  In the 
generalization of such a design, special emphasis is
placed on estimating expected gains when compared 
with the traditional configuration of separate and independent
computers without extended core storage. 
 An observation is made on the use of conventional, slower
speed, random access storage devices in place 
of the faster memory.

CACM May, 1968

Fuchel, K.
Heller, S.

multiple computer systems, extended core storage,
multiprogrammed operating systems, multiprocessor 
operating systems, control data corporation 6600, operating system with ECS

4.30 4.32

CA680506 JB February 23, 1978  9:27 AM

1750	5	1750
1750	5	1750
1750	5	1750
2988	5	1750
1750	6	1750


************************

************************
Document:  CACM-1135.html
************************


A General Business-Oriented Language Based on Decision Expressions*

The structure of a digital compute programming
language which covers a wide class of business 
and file processing applications is presented.  Such
a structure, <B>based on</B> identifying and incorporating 
into a compiler the aspects common to all processes
of such class, permits writing extremely compact 
programs, even for comparatively complex applications,
in terms of tables of control expressions which 
express only information characteristic of the particular
application.  Furthermore,local changes of 
a process (e.g. changes affecting only one of the output
files involved) can be effected by local modifications 
in the program (e.g. modification of only one entry of the
tables).  This structure also allows for inexpensive 
preparation of loading-speed compilers which translate the
source programs into efficient machine codes. 
 The approach adopted here departs from conventional mechanical
language design philosophies.  It stresses 
the structural analysis of the class of processes to be represented
in the languages, as opposed to emphasizing 
formal (i.e., contents-independent) syntactical definitions.
 It relies exclusively on nonprocedural 
representation of process as sets (tables) of relations
between data and results (there are no control 
statements such as GO TO, etc.), instead of using procedure
descriptions (which are one-to-one translations 
of flowcharts).  Here an invariant pattern of procedure
is identified as characteristic of the class 
of all batch file processes.  This new philosophy has
the potential to overcome well-known deficiencies 
of other business-oriented languages and fully meets
the requirements set by CODASYL for such languages, 
including machine-independence.

CACM February, 1964

Lombardi, L. A.

CA640208 JB March 10, 1978  4:08 AM

1135	4	1135
1136	4	1135
493	4	1135
2710	4	1135
2765	4	1135
2888	4	1135
2906	4	1135
729	4	1135
1135	5	1135
1135	5	1135
1135	5	1135
1959	5	1135
616	5	1135
1135	6	1135


************************

************************
Document:  CACM-2950.html
************************


A Unifying Approach to Scheduling

This paper presents a scheme for classifying
scheduling algorithms based on an abstract model 
of a scheduling system which formalizes the notion of
priority.  Various classes of scheduling algorithms
are defined and related to existing algorithms.  A
criterion for the implementation efficiency of an 
algorithm is developed and results in the definition
of time-invariant algorithms, which include most 
of the commonly implemented ones.  For time-invariant
algorithms, the dependence of processing rates 
on priorities is derived.  The abstract model provides
a framework for implementing flexible schedulers 
in real <B>operating systems</B>.  The policy-driven scheduler
of Bernstein and Sharp is discussed as an example 
of such an implementation

CACM July, 1977

Ruschitzka, M.
Fabry, R. S.

scheduling algorithms, scheduling models, priority,
operating systems,processor sharing, implementation 
efficiency

4.31 4.32 4.34 4.35 8.1

CA770702 JB December 28, 1977  12:32 PM

2950	4	2950
3072	4	2950
2219	5	2950
2950	5	2950
2950	5	2950
2950	5	2950


************************



A Unifying Approach to Scheduling

This paper presents a scheme for classifying
scheduling algorithms <B>based on</B> an abstract model 
of a scheduling system which formalizes the notion of
priority.  Various classes of scheduling algorithms
are defined and related to existing algorithms.  A
criterion for the implementation efficiency of an 
algorithm is developed and results in the definition
of time-invariant algorithms, which include most 
of the commonly implemented ones.  For time-invariant
algorithms, the dependence of processing rates 
on priorities is derived.  The abstract model provides
a framework for implementing flexible schedulers 
in real operating systems.  The policy-driven scheduler
of Bernstein and Sharp is discussed as an example 
of such an implementation

CACM July, 1977

Ruschitzka, M.
Fabry, R. S.

scheduling algorithms, scheduling models, priority,
operating systems,processor sharing, implementation 
efficiency

4.31 4.32 4.34 4.35 8.1

CA770702 JB December 28, 1977  12:32 PM

2950	4	2950
3072	4	2950
2219	5	2950
2950	5	2950
2950	5	2950
2950	5	2950


************************

************************
Document:  CACM-2378.html
************************


An Operating System Based on the Concept of a Supervisory Computer

An operating system which is organized as a
small supervisor and a set of independent processes 
are described.  The supervisor handles I/O with external
devices-the file and directory system-schedules 
active processes and manages memory, handle errors, and
provides a small set of primitive functions which 
it will execute for a process.  A process is able to
specify a request for a complicated action on the 
part of the supervisor (usually a wait on the occurrence
of a compound event in the system) by combining 
these primitives into a "supervisory computer program."
 The part of the supervisor which executes these 
programs may be viewed as a software implemented "supervisory
computer."  The paper develops these concepts 
in detail, outlines the remainder of the supervisor, and
discusses some of the advantages of this approach.

CACM March, 1972

Gaines, R. S.

<B>operating systems</B>, supervisors, multiprogramming,
time-sharing, cooperating processes

4.30 4.31 4.32

CA720303 JB January 31, 1978  3:08 PM

1458	4	2378
1523	4	2378
1603	4	2378
1698	4	2378
1747	4	2378
1748	4	2378
1854	4	2378
1877	4	2378
1960	4	2378
2319	4	2378
2377	4	2378
2378	4	2378
2378	4	2378
2320	4	2378
2497	4	2378
2558	4	2378
2625	4	2378
2632	4	2378
2632	4	2378
2738	4	2378
2740	4	2378
2840	4	2378
2868	4	2378
2941	4	2378
3105	4	2378
3127	4	2378
3144	4	2378
1471	5	2378
2080	5	2378
2378	5	2378
2378	5	2378
2378	5	2378


************************



An Operating System Based on the Concept of a Supervisory Computer

An operating system which is organized as a
small supervisor and a set of independent processes 
are described.  The supervisor handles I/O with external
devices-the file and directory system-schedules 
active <B>processes and</B> manages memory, handle errors, and
provides a small set of primitive functions which 
it will execute for a process.  A process is able to
specify a request for a complicated action on the 
part of the supervisor (usually a wait on the occurrence
of a compound event in the system) by combining 
these primitives into a "supervisory computer program."
 The part of the supervisor which executes these 
programs may be viewed as a software implemented "supervisory
computer."  The paper develops these concepts 
in detail, outlines the remainder of the supervisor, and
discusses some of the advantages of this approach.

CACM March, 1972

Gaines, R. S.

operating systems, supervisors, multiprogramming,
time-sharing, cooperating processes

4.30 4.31 4.32

CA720303 JB January 31, 1978  3:08 PM

1458	4	2378
1523	4	2378
1603	4	2378
1698	4	2378
1747	4	2378
1748	4	2378
1854	4	2378
1877	4	2378
1960	4	2378
2319	4	2378
2377	4	2378
2378	4	2378
2378	4	2378
2320	4	2378
2497	4	2378
2558	4	2378
2625	4	2378
2632	4	2378
2632	4	2378
2738	4	2378
2740	4	2378
2840	4	2378
2868	4	2378
2941	4	2378
3105	4	2378
3127	4	2378
3144	4	2378
1471	5	2378
2080	5	2378
2378	5	2378
2378	5	2378
2378	5	2378


************************

************************
Document:  CACM-1514.html
************************


On the Expected Gain From Adjust ing Matched Term Retrieval Systems

A file adjustment procedure <B>based on</B> maximizing
the Bayes expected gain proposed for matched 
term retrieval systems.  The expected gain and its probability
distribution are derived as a function 
of: (1) the prior proportion of omitted terms, and (2) the
coefficient of separation between two distributions 
corresponding to values of an adjustment statistic.  An
example evaluates the gain parameters for a typical 
information retrieval system.

CACM November, 1967

Shumway, R. H.

CA671106 JB February 26, 1978  2:59 PM

1514	5	1514
1514	5	1514
1514	5	1514


************************

************************
Document:  CACM-2317.html
************************


Programming Systems and Languages 1965-1975

In spite of impressive gains by PL/I, Fortran
and Cobol remain the languages in which most 
of the world's production programs are written and will
remain so into the foreseeable future.  There 
is a great deal of theoretical interest in Algol 68
and in extensible languages, but so far at least 
they have had little practical impact.  Problem-oriented
languages may very well become the most important 
language development area in the next five to ten years.
 In the operating system area all major computer 
manufacturers set out to produce very ambitious multiprogramming
systems, and they all ran into similar 
problems.  A number of university projects,though not
directly comparable to those of the manufacturers, 
have contributed greatly to a better understanding
of operating system principles.  Important trends 
include the increased interest in the development of
system measurement and evaluation techniques,and 
increased use of microprogramming for some programming system functions.

CACM July, 1972

Rosen, S.

languages, <B>operating systems</B>, programming
systems, multiprogramming, history

1.2 4.22 4.32

CA720711 JB January 30, 1978  1:47 PM

1665	4	2317
1768	4	2317
1781	4	2317
1787	4	2317
1805	4	2317
1824	4	2317
1825	4	2317
1828	4	2317
1836	4	2317
1846	4	2317
1854	4	2317
1861	4	2317
1877	4	2317
1892	4	2317
1960	4	2317
2015	4	2317
2110	4	2317
2126	4	2317
2127	4	2317
2150	4	2317
2150	4	2317
2187	4	2317
2188	4	2317
2218	4	2317
2228	4	2317
2256	4	2317
2314	4	2317
2317	4	2317
2317	4	2317
2317	4	2317
2317	4	2317
2317	4	2317
2317	4	2317
2317	4	2317
2317	4	2317
2319	4	2317
2358	4	2317
2377	4	2317
2342	4	2317
2342	4	2317
2376	4	2317
2376	4	2317
2379	4	2317
2424	4	2317
2482	4	2317
2545	4	2317
2546	4	2317
2618	4	2317
2618	4	2317
2625	4	2317
2632	4	2317
2698	4	2317
2704	4	2317
2723	4	2317
2733	4	2317
2738	4	2317
2740	4	2317
2741	4	2317
2842	4	2317
2867	4	2317
3184	4	2317
3184	4	2317
1198	5	2317
1572	5	2317
1693	5	2317
1749	5	2317
1753	5	2317
1781	5	2317
2126	5	2317
2148	5	2317
2317	5	2317
2317	5	2317
2317	5	2317
2874	5	2317
1682	6	2317
2227	6	2317
2317	6	2317
2683	6	2317
2871	6	2317
521	6	2317


************************

************************
Document:  CACM-3049.html
************************


A Simply Extended and Modified Batch
Environment Graphical System (SEMBEGS)

SEMBEGS is a complete batch environment graphical
system containing components for handling 
graphical data files, for displaying the contents of
these files on a variety of graphical hardware, 
and for performing graphical batch input operations.
 SEMBEGS is easy to extend and modify to meet the 
growing needs of a large batch environment, and is even
extendable to a fully interactive system.  The 
paper presents the conceptual view of graphics leading
to the design of SEMBEGS and outlines the major 
components of the system.  The design of SEMBEGS is founded
upon the basic assumption that the true aim 
of computer graphics is to describe graphical entities,
rather than, as commonly held, to provide graphical 
input and output functional capabilities.  SEMBEGS
is built around a Basic Graphical Data Management 
System (BAGDAMS) which provides a common means of communicating
the <B>descriptions of</B> graphical entities 
 between the various components of SEMBEGS.  BAGDAMS
provides facilities for storing, retrieving, and 
manipulating the descriptions of graphical entities
provided by, and received by application programs,
graphics packages, and graphical devices. 

CACM November, 1978

Wendorf, J.

Computer graphics, data structures, graphic display,
graphic input, graphical database, device 
independent graphics

4.33 4.34 8.2

CA781102 DH January 26, 1979  1:30 PM

3030	4	3049
3031	4	3049
3049	4	3049
3049	4	3049
3049	4	3049
3049	4	3049
2956	5	3049
2957	5	3049
2958	5	3049
2960	5	3049
3049	5	3049
3049	5	3049
3049	5	3049


************************

************************
Document:  CACM-2482.html
************************


Mixed Solutions for the Deadlock Problem

Mixtures of detection, avoidance, and prevention
provide more effective and practical solutions 
to the deadlock problem than any one of these alone.  The
individual techniques can be tailored for subproblems 
of resource allocation and still operate together to
prevent deadlocks.  This paper presents a method, 
based on the concept of the hierarchical operating
system, for constructing appropriate mixtures and 
suggests appropriate subsystems for the most frequently
occurring resource allocation problems

CACM July, 1973

Howard, J. H. Jr.

deadlocks, resource allocation, <B>operating systems</B>,
multiprogramming, hierarchical systems

4.30 4.32

CA730704 JB January 23, 1978  12:46 PM

1828	4	2482
1854	4	2482
1877	4	2482
1960	4	2482
2150	4	2482
2228	4	2482
2280	4	2482
2280	4	2482
2317	4	2482
2319	4	2482
2377	4	2482
2342	4	2482
2376	4	2482
2379	4	2482
2379	4	2482
2379	4	2482
2424	4	2482
2482	4	2482
2482	4	2482
2482	4	2482
2500	4	2482
2618	4	2482
2632	4	2482
2704	4	2482
2723	4	2482
2738	4	2482
2740	4	2482
2740	4	2482
2741	4	2482
2851	4	2482
2867	4	2482
2920	4	2482
3184	4	2482
1749	5	2482
1877	5	2482
2228	5	2482
2482	5	2482
2482	5	2482
2482	5	2482


************************



Mixed Solutions for the Deadlock Problem

Mixtures of detection, avoidance, and prevention
provide more effective and practical solutions 
to the deadlock problem than any one of these alone.  The
individual techniques can be tailored for subproblems 
of resource allocation and still operate together to
prevent deadlocks.  This paper presents a method, 
<B>based on</B> the concept of the hierarchical operating
system, for constructing appropriate mixtures and 
suggests appropriate subsystems for the most frequently
occurring resource allocation problems

CACM July, 1973

Howard, J. H. Jr.

deadlocks, resource allocation, operating systems,
multiprogramming, hierarchical systems

4.30 4.32

CA730704 JB January 23, 1978  12:46 PM

1828	4	2482
1854	4	2482
1877	4	2482
1960	4	2482
2150	4	2482
2228	4	2482
2280	4	2482
2280	4	2482
2317	4	2482
2319	4	2482
2377	4	2482
2342	4	2482
2376	4	2482
2379	4	2482
2379	4	2482
2379	4	2482
2424	4	2482
2482	4	2482
2482	4	2482
2482	4	2482
2500	4	2482
2618	4	2482
2632	4	2482
2704	4	2482
2723	4	2482
2738	4	2482
2740	4	2482
2740	4	2482
2741	4	2482
2851	4	2482
2867	4	2482
2920	4	2482
3184	4	2482
1749	5	2482
1877	5	2482
2228	5	2482
2482	5	2482
2482	5	2482
2482	5	2482


************************

************************
Document:  CACM-2174.html
************************


The Stable Marriage Problem

The original work of Gale and Shapley on an assignment
method using the stable marriage criterion 
has been extended to <B>find all</B> the stable marriage assignments.
 The algorithm derived for finding all 
the stable marriage assignments is proved to satisfy
all the conditions of the problem.  Algorithm 411 
applies to this paper.

CACM July, 1971

McVitie, D. G.
Wilson,L. B.

assignment problems, assignment procedures, combinatorics,
discrete mathematics, operational research, 
stable marriage problem, university entrance

5.30

CA710708 JB February 2, 1978  4:40 PM

2174	4	2174
2173	5	2174
2174	5	2174
2174	5	2174
2174	5	2174


************************

************************
Document:  CACM-2160.html
************************


Canonical Structure in Attribute Based File Organization

A new file structure for attribute based retrieval
is proposed in this paper.  It allows queries 
involving arbitrary Boolean functions of the attribute-value
pairs to be processed without taking intersections 
of lists.  The structure is highly dependent on the
way in which the file is to be used and is uniquely 
determined by the specification of the allowed queries.
 Thus, for example, the structure for retrieval 
on the basis of ranges of values of a given attribute would
be very different from one where only retrieval 
on the basis of a single value is permitted.  The file
organization being proposed is <B>based on</B> the atoms 
of a Boolean algebra generated by the queries.  The desirable
properties claimed for this structure are 
proved, and file maintenance questions are discussed.

CACM September, 1971

Wong, E.
Chiang, T. C.

address calculation, atoms of Boolean algebra,
attributes, Boolean functions, Boolean queries, 
file organization, information retrieval, inverted
file, key words, multilist, queries, searches 

3.70 3.73 3.74

CA710904 JB February 2, 1978  2:22 PM

2160	4	2160
2688	4	2160
2114	5	2160
2160	5	2160
2160	5	2160
2160	5	2160
3134	5	2160
1976	6	2160
2160	6	2160
2524	6	2160
2990	6	2160


************************

************************
Document:  CACM-2266.html
************************


A Highly Parallel Algorithm for Approximating
All Zeros of a Polynomial with Only Real Zeros

An algorithm is described <B>based on</B> Newton's
method which simultaneously approximates all zeros 
of a polynomial with only real zeros.  The algorithm, which
is conceptually suitable for parallel computation, 
determines its own starting values so that convergence
to the zeros is guaranteed.  Multiple zeros and 
their multiplicity are readily determined.  At no
point in the method is polynomial deflation used.

CACM November, 1972

Patrick, M. L.

parallel numerical algorithms, real polynomials,
real zeros, Newton's method, starting values, 
guaranteed convergence

5.15

CA721103 JB January 27, 1978  2:35 PM

2266	5	2266
2266	5	2266
2266	5	2266
2660	5	2266
2266	6	2266


************************

************************
Document:  CACM-2080.html
************************


The Nucleus of a Multiprogramming System

This paper describes the philosophy and structure of a multiprogramming system 
that can be extended with a hierarchy of <B>operating systems</B> to suit diverse 
requirements of program scheduling and resource allocation.  The system
nucleus simulates an environment in which program execution and input/output
are handled uniformly as parallel, cooperating process
es.  A fundamental set of primitives allows the dynamic creation and control
of a hierarchy of processes as well as the communication among them.

CACM April, 1970

Hansen, P. B.

multiprogramming, operating systems, parallel processes, process concept,
process communication, message buffering, process
hierarchy, process creation, process removal

4.30 4.31 4.32 4.41

CA700404 JB February 13, 1978  3:10 PM

1657	4	2080
2080	4	2080
2357	4	2080
2536	4	2080
1523	5	2080
2080	5	2080
2080	5	2080
2080	5	2080
2319	5	2080
2320	5	2080
2378	5	2080
2632	5	2080
2738	5	2080
2740	5	2080
2868	5	2080
3127	5	2080
1408	6	2080
1471	6	2080
1471	6	2080
1719	6	2080
1749	6	2080
1749	6	2080
1749	6	2080
1749	6	2080
1751	6	2080
1877	6	2080
2016	6	2080
2017	6	2080
2080	6	2080
2080	6	2080
2080	6	2080
2080	6	2080
2080	6	2080
2080	6	2080
2080	6	2080
2080	6	2080
2150	6	2080
2188	6	2080
2203	6	2080
2204	6	2080
2247	6	2080
2277	6	2080
2356	6	2080
2377	6	2080
2380	6	2080
2558	6	2080
2625	6	2080
2632	6	2080
2777	6	2080


************************

************************
Document:  CACM-3002.html
************************


A Record and File Partitioning Model

One of the main objectives in the design of
a file system is the reduction of storage and data 
transfer costs.  This paper presents a model in which
several  requests access the file system, and each 
request requires information from one or more variable
length data-items.  The probabilities of access 
and the distribution of each data-item's length are assumed
to be known, and to be mutually independent. 
The file system uses one or more storage devices, and
each record may be partitioned into subrecords 
that are stored on different devices.  One of the subrecords
is designated as the primary record; when 
a request for a record is made, the primary record is
first accessed, and other subrecords are accessed 
only if the pertinent information is not stored in the
primary record.  The model that is presented in 
this paper, both as a nonlinear programming model and
a mixed integer programming model, is a very general 
one; several types <B>of file</B> systems may be derived from
it by an appropriate selection of its parameters. 
 This model has already been used in the optimization of
library routines' storage at a large scale operating 
system.

CACM January, 1977

Babad, J. M.

file system, file design, file partitioning, record partitioning

3.73

CA770103 JB January 3, 1978  12:28 AM

3002	5	3002
3002	5	3002
3002	5	3002
3168	5	3002
2965	6	3002
3002	6	3002


************************

************************
Document:  CACM-1032.html
************************


Theoretical Considerations in Information Retrieval Systems

Information storage and retrieval systems are composed
of three major components: (a) identification 
of information and tagging it for effective retrieval,
(b) searching strategy, how to enter the file 
to circumvent the scanning of nonrelevant material, and
(c) file organization to make access to information 
efficient.  For identification of information the paper
suggests that a metalanguage (recently discussed 
in a paper by Goffman, Verhoeff and Belzer) associated
with an object language be used.  For searching 
strategy, a linear model for an evaluation function
of relevancy is developed which rewards the system 
for retrieving relevant documents and not retrieving
the nonrelevant, and penalizes the system for the 
escaped relevant documents and false drops.  The inadequacies
of a linear model are indicated.  Two approaches 
to file organization are discussed.  One is self-organization
of the file <B>based on</B> its history and past 
performance, and the second is a self-generating subset
of the file with a high probability of being 
relevant.

CACM July, 1964

Belzer, J.
Goffman, W.

CA640715 JB March 9, 1978  7:55 PM

1032	5	1032
1032	5	1032
1032	5	1032


************************

************************
Document:  CACM-2069.html
************************


Comments on a Paper by Wallace and Mason

CACM April, 1970

Heess Jr., W. F.

page-on-demand, demand paging, time-sharing multiprogramming,
Markovian computer models, scheduling strategies,
<B>operating systems</B>, memory management

2.44 4.32 4.39 6.20 6.21

CA700415 JB February 13, 1978  2:36 PM

2069	5	2069
2069	5	2069
2069	5	2069


************************

************************
Document:  CACM-1854.html
************************


On Multiprogramming, Machine Coding, and Computer Organization

The author feels that the interrupt feature
which is available in most modern computers is 
a potent source of programming pitfalls and errors, and
that it therefore may heavily contribute to the 
unreliability of programs making use of it.  A programming
scheme is presented which avoids the concept 
of the interrupt and permits the specification of concurrent
(or pseudoconcurrent) activities in a supposedly 
more perspicuous manner.  It is intended to serve as
a basis for the construction of <B>operating systems</B>, 
which are prime examples of programs with concurrent
activities.  The scheme includes a set of basic 
instructions for the generation, termination, and synchronization
of parallel processes.  A set of routines 
representing these instructions and thereby simulating a
hypothetical machine organization has been implemented 
and test on the IBM System/360.  Two programs using these
instructions, written in PL360, are presented. 

CACM September, 1969

Wirth, N.

multiprogramming, parallelism, interrupt, input-output,
computer organization, file handling, PL360

4.21 4.22 4.32 4.41 6.21

CA690901 JB February 15, 1978  5:14 PM

1380	4	1854
1458	4	1854
1523	4	1854
1552	4	1854
1603	4	1854
1693	4	1854
1698	4	1854
1747	4	1854
1748	4	1854
1781	4	1854
1805	4	1854
1828	4	1854
1828	4	1854
1854	4	1854
1854	4	1854
1854	4	1854
1854	4	1854
1860	4	1854
1877	4	1854
1877	4	1854
1960	4	1854
1960	4	1854
2060	4	1854
2150	4	1854
2187	4	1854
2317	4	1854
2319	4	1854
2377	4	1854
2377	4	1854
2378	4	1854
2342	4	1854
2376	4	1854
2379	4	1854
2424	4	1854
2482	4	1854
2497	4	1854
2558	4	1854
2618	4	1854
2625	4	1854
2632	4	1854
2632	4	1854
2704	4	1854
2723	4	1854
2738	4	1854
2740	4	1854
2741	4	1854
2840	4	1854
2867	4	1854
2941	4	1854
557	4	1854
3105	4	1854
3144	4	1854
3184	4	1854
1421	5	1854
1471	5	1854
1748	5	1854
1749	5	1854
1854	5	1854
1854	5	1854
1854	5	1854
1960	5	1854
1471	6	1854
1749	6	1854
1854	6	1854


************************



On Multiprogramming, Machine Coding, and Computer Organization

The author feels that the interrupt feature
which is available in most modern computers is 
a potent source of programming pitfalls and errors, and
that it therefore may heavily contribute to the 
unreliability of programs making use of it.  A programming
scheme is presented which avoids the concept 
of the interrupt and permits the specification of concurrent
(or pseudoconcurrent) activities in a supposedly 
more perspicuous manner.  It is intended to serve as
a basis for the construction of operating systems, 
which are prime examples of programs with concurrent
activities.  The scheme includes a set of basic 
instructions for the generation, termination, and synchronization
of parallel processes.  A set of routines 
representing these instructions and thereby simulating a
hypothetical machine organization has been implemented 
and test on the IBM System/360.  Two programs using these
instructions, written in PL360, are presented. 

CACM September, 1969

Wirth, N.

multiprogramming, parallelism, interrupt, input-output,
computer organization, <B>file handling</B>, PL360

4.21 4.22 4.32 4.41 6.21

CA690901 JB February 15, 1978  5:14 PM

1380	4	1854
1458	4	1854
1523	4	1854
1552	4	1854
1603	4	1854
1693	4	1854
1698	4	1854
1747	4	1854
1748	4	1854
1781	4	1854
1805	4	1854
1828	4	1854
1828	4	1854
1854	4	1854
1854	4	1854
1854	4	1854
1854	4	1854
1860	4	1854
1877	4	1854
1877	4	1854
1960	4	1854
1960	4	1854
2060	4	1854
2150	4	1854
2187	4	1854
2317	4	1854
2319	4	1854
2377	4	1854
2377	4	1854
2378	4	1854
2342	4	1854
2376	4	1854
2379	4	1854
2424	4	1854
2482	4	1854
2497	4	1854
2558	4	1854
2618	4	1854
2625	4	1854
2632	4	1854
2632	4	1854
2704	4	1854
2723	4	1854
2738	4	1854
2740	4	1854
2741	4	1854
2840	4	1854
2867	4	1854
2941	4	1854
557	4	1854
3105	4	1854
3144	4	1854
3184	4	1854
1421	5	1854
1471	5	1854
1748	5	1854
1749	5	1854
1854	5	1854
1854	5	1854
1854	5	1854
1960	5	1854
1471	6	1854
1749	6	1854
1854	6	1854


************************

************************
Document:  CACM-1752.html
************************


Resource Management for a Medium Scale Time-Sharing Operating system

Task scheduling and resource balancing for
a medium size virtual memory paging machine are 
discussed in relation to a combined batch processing
and time-sharing environment.  A synopsis is given 
of the task scheduling and paging algorithms that were implemented,
and the results of comparative simulation 
are given by tracing the development of the algorithms
through six predecessor versions.  Throughout 
the discussion particular emphasis is placed on balancing
the system performance relative to the characteristics 
of all the system resources.  Simulation results relative
to alternate hardware characteristics and the 
effects of program mix and loading variations are also presented.

CACM May, 1968

Oppenheimer, G.
Weizer, N.

time-sharing, <B>operating systems</B>, resource management,
task scheduling, paging, system simulation, 
memory management, virtual memories

4.30 4.31 4.32

CA680504 JB February 23, 1978  9:39 AM

1751	5	1752
1752	5	1752
1752	5	1752
1752	5	1752
1892	5	1752
2128	5	1752
2218	5	1752
1380	6	1752
1526	6	1752
1572	6	1752
1572	6	1752
1728	6	1752
1728	6	1752
1751	6	1752
1751	6	1752
1752	6	1752
1752	6	1752
1752	6	1752
1752	6	1752
1810	6	1752
1879	6	1752
2095	6	1752


************************

************************
Document:  CACM-2342.html
************************


Interference Between Communicating Parallel Processes

Various kinds of interference between communicating
parallel processes have been examined by 
Dijkstra, Knuth, and others.  Solutions have been given
for the mutual exclusion problem and associated 
subproblems, in the form of parallel programs, and informal
proofs of correctness have been given for 
these solutions.  In this paper a system of parallel
processes is regarded as a machine which proceeds 
from one state S (i.e. a collection of pertinent data
values and process configurations) to a next state 
S' in accordance with a transition rule S --> S'.  A
set of such rules yields sequences of states, which 
dictate the system's behavior.  The mutual exclusion problem
and the associated subproblems are formulated 
as questions of inclusion between sets of states, or
of the existence of certain sequences.  A mechanical 
proof procedure is shown, which will either verify (prove
the correctness of ) or discredit (prove the 
incorrectness of) an attempted solution, with respect
to any of the interference properties.  It is shown 
how to calculate transition rules from the "partial
rules" by which the individual processes operate. 
 The formation of partial rules and the calculation of
transition rules are both applicable to hardware 
processes as well as to software processes, and
symmetry between processes is not required.

CACM June, 1972

Gilbert, P.
Chandler, W. J.

concurrent programming control, cooperating processes,
formal programs, interference, mutual exclusion, 
<B>operating systems</B>, parallel processes

4.0 4.10 4.30 4.32 4.42 5.24 6.20

CA720603 JB January 31, 1978  8:44 AM

1781	4	2342
1828	4	2342
1854	4	2342
1877	4	2342
1960	4	2342
2150	4	2342
2150	4	2342
2150	4	2342
2228	4	2342
2228	4	2342
2256	4	2342
2256	4	2342
2317	4	2342
2317	4	2342
2319	4	2342
2377	4	2342
2342	4	2342
2342	4	2342
2342	4	2342
2376	4	2342
2376	4	2342
2379	4	2342
2424	4	2342
2482	4	2342
2618	4	2342
2618	4	2342
2618	4	2342
2632	4	2342
2704	4	2342
2723	4	2342
2738	4	2342
2740	4	2342
2741	4	2342
2867	4	2342
3184	4	2342
3184	4	2342
1198	5	2342
1338	5	2342
1749	5	2342
2342	5	2342
2342	5	2342
2342	5	2342


************************

************************
Document:  CACM-1226.html
************************


The Organization of Structured Files

A data file is an integral part of a data processing
system.  In many systems, the selection 
of an organization for the data within the file can
be critical to the system's operating efficiency. 
 This paper provides the systems designer with an information
source which describes ten techniques that 
may be employed for organizing structured data.  The
characteristics of the organizations described are 
application independent, thus providing the designer with
a reference which allows him to limit the number 
<B>of file</B> organizations he must consider for his system.

CACM July, 1965

Dzubak, B. J.
Warburton, C. R.

CA650709 JB March 6, 1978  8:57 PM

1050	4	1226
1226	4	1226
441	4	1226
758	4	1226
1226	5	1226
1226	5	1226
1226	5	1226
367	5	1226


************************

************************
Document:  CACM-1747.html
************************


Three Criteria for Designing Computing Systems to Facilitate Debugging

The designer of a computing system should adopt
explicit criteria for accepting or rejecting 
proposed system features.  Three possible criteria of this
kind are input recordability, input specifiability, 
and asynchronous reproducibility of output.  These criteria
imply that a user can, if he desires, either 
know or control all the influences affecting the content
and extent of his computer's output.  To define 
the scope of the criteria, the notion of an abstract
machine of a programming language and the notion 
of a virtual computer are explained.  Examples of applications
of the criteria concern the reading of 
a time-of-day clock,  the synchronization of parallel
processes, protection in multiprogrammed systems, 
and the assignment of capability indexes.

CACM May, 1968

Van Horn, E. C.

computer design, computer design criteria, computer
systems, computer systems design, input equipment, 
input equipment design, <B>operating systems</B>, operating
systems design, multiprogramming, multiprogrammed 
systems, multiprogrammed system design, virtual computers,
programming languages, programming language 
design, program semantics, programming language semantics,
determinism, reproducibility, repeatability, 
deterministic computers, protection, memory protection,
information security, information privacy, computing 
reliability, debugging, program debugging, program testing,
parallel processing, parallel programming, 
multiprocessing

2.11 4.12 4.13 4.20 4.30 4.42 4.43 5.24 6.20 6.35

CA680509 JB February 23, 1978  9:06 AM

1458	4	1747
1523	4	1747
1603	4	1747
1698	4	1747
1747	4	1747
1748	4	1747
1854	4	1747
1877	4	1747
1960	4	1747
2377	4	1747
2378	4	1747
2497	4	1747
2558	4	1747
2625	4	1747
2632	4	1747
2840	4	1747
2941	4	1747
3105	4	1747
3144	4	1747
1471	5	1747
1747	5	1747
1747	5	1747
1747	5	1747
2151	5	1747
1653	6	1747
1747	6	1747
1860	6	1747


************************

************************
Document:  CACM-2949.html
************************


A Correctness Proof of a Topology Information
Main tenance Protocol for a Distributed Computer 
Network

In order for the nodes of a distributed computer
network to communicate, each node must have 
information about the network's topology.  Since nodes
and links sometimes crash, a scheme is needed 
to update this information.  One of the major constrain ts
on such a topology information scheme is that 
it may not involve a central controller.  The Topology
Information Protocol that was implemented on the 
MERIT Computer Network is presented and explained; this
protocol is quite general and could be implemented 
on any computer network.  It is <B>based on</B> Baran's "Hot
Potato Heuristic Routing Doctrine."  A correctness 
proof of this Topology Information Protocol is also presented.

CACM July, 1977

Tajibnapis, W. D.

distributed computer network, correctness proofs,
computer networks, distributed control, network 
topology, routing problem in networks, distributed operating
system, store and forward packet switching, 
store and forward message switching, traffic control

3.81 4.32

CA770703 JB December 28, 1977  11:59 AM

2949	5	2949
2949	5	2949
2949	5	2949


************************

************************
Document:  CACM-0409.html
************************


CL-1, An Environment for a Compiler

A flexible, large-scale programming system to
facilitate the solution of information processing 
problems and to provide intercommunication between programs
and/or programmers has been developed and 
realized on the IBM 709/7090 computer.  The system is
<B>based on</B> a master file concept and has provisions 
for accepting, storing, and retrieving both descriptions
and instances of large and complex data sets, 
as well as algorithms defined on these data sets.  Both
data and algorithms may be expressed in a family 
of command and descriptive languages.  The concept
of distinct data descriptions and the content and 
use of such descriptions are discussed in some detail.

CACM January, 1961

Cheatham Jr., T. E.
Collins Jr., G. O.
Leonard, G. F.

CA610105 JB March 17, 1978  1:26 AM

409	5	409
409	5	409
409	5	409
657	5	409
279	6	409
409	6	409


************************

************************
Document:  CACM-2320.html
************************


Structured Multiprogramming

This paper presents a proposal for structured
representation of multiprogramming in a high 
level language.  The notation used explicitly associates
a data structure shared by concurrent processes 
with operations defined on it.  This clarifies the meaning
of programs and permits a large class of time-dependent 
errors to be caught at compile time.  A combination of
critical regions and event variables enables the 
programmer to control scheduling of resources among
competing processes to any degree desired.  These 
concepts are sufficiently safe to use not only within
<B>operating systems</B> but also within user programs.

CACM July, 1972

Hansen, P. B.

structured multiprogramming, programming languages,
operating systems, concurrent processes, shared 
data, mutual exclusion, critical regions, process
communication, synchronizing events.

4.2 4.3

CA720708 JB January 30, 1978  2:39 PM

2319	4	2320
2378	4	2320
2320	4	2320
2320	4	2320
2597	4	2320
2632	4	2320
2738	4	2320
2740	4	2320
2777	4	2320
2851	4	2320
2868	4	2320
2895	4	2320
2912	4	2320
2946	4	2320
3127	4	2320
3128	4	2320
2080	5	2320
2150	5	2320
2320	5	2320
2320	5	2320
2320	5	2320
2597	5	2320
2150	6	2320
2320	6	2320


************************

************************
Document:  CACM-2288.html
************************


File Organization: The Consecutive Retrieval Property

The consecutive retrieval property is an important
relation between a query set and record 
set.  Its existence enables the design of an information
retrieval system with a minimal search time 
and no redundant storage.  Some important theorems on
the consecutive retrieval property are proved in 
this paper.  Conditions under which the consecutive retrieval
property exists and remain invariant have 
been established.  An outline for designing an information
retrieval system <B>based on</B> the consecutive 
retrieval property is also discussed.

CACM September, 1972

Ghosh, S. P.

file organization, consecutive storage, consecutive
retrieval, information retrieval, record organization, 
query structure, record structure, storage on
tapes, storage space, minimum access time

3.70 3.73 3.74

CA720902 JB January 27,1978  4:52 PM

2288	5	2288
2288	5	2288
2288	5	2288
2729	5	2288
2288	6	2288
2801	6	2288


************************

************************
Document:  CACM-1680.html
************************


A General-Purpose Display Processing and Tutorial System

ADEPT (A display-Expedited Processing and Tutorial)
system is described.  This system was designed 
to improve man-computer communications by employing
a display unit to interleave tutoring with other 
computer operations such as simulation, programming, and
information retrieval.  It is written in FORTRAN 
IV (G) for the IBM System/360, Model 40, and the IBM 2250
display Unit under Operating System/360.  Adept 
is a cataloged program that controls the standard operating
system by terminating and rescheduling itself 
automatically, relinquishing computer resources allocated
to it, and surrendering control to the operating 
system to perform other jobs.  It expands the power
and flexibility of computer-assisted instruction 
by making immediately available to students, teachers,
and other users, the full resources (system-cataloged 
programs) of the operating system.  Language processors
and compilers, simulation models, mathematical 
solution techniques, stored data, and all other library and
user programs can be incorporated into instructional 
material without reprogramming.  Illustrations of the various
applications are presented and their implications 
are discussed.

CACM October, 1968

Engvold, K. J.
Hughes, J. L.

computer-assisted instruction, tutorial systems,
programming, simulation, modeling, information 
retrieval <B>operating systems</B>, graphics, displays, man-machine
interface, on-line computing, graphic programming

1.5 3.3 3.5 3.8 4.0 4.3

CA681007 JB February 21, 1978  3:36 PM

1680	4	1680
1591	5	1680
1680	5	1680
1680	5	1680
1680	5	1680


************************

************************
Document:  CACM-2629.html
************************


The UNIX Time-Sharing system 

UNIX is a general-purpose, multi-user, interactive
operating system for the Digital Equipment 
Corporation PDP-11/40 and 11/45 computers.  It offers
a number of features seldom found even in larger 
<B>operating systems</B>, including: (1) a hierarchical file system
incorporating demountable volumes; (2) compatible 
file, device, and inter-process I/O; (3) the ability to
initiate asynchronous processes; (4) system command 
language selectable on a per-user basis; and (5) over
100 subsystems including a dozen languageshis 
paper discusses the nature and implementation of the
file system and of the user command interface.

CACM July, 1974

Ritchie, D. M.
Thompson, K.

time-sharing, operating system, file system, command language, PDP-11

4.30 4.32

CA740702 JB January 17, 1978  1:40 PM

2299	4	2629
2501	4	2629
2629	4	2629
2629	4	2629
2868	4	2629
2915	4	2629
2928	4	2629
2951	4	2629
3114	4	2629
1502	5	2629
2380	5	2629
2626	5	2629
2629	5	2629
2629	5	2629
2629	5	2629
2786	5	2629
2840	5	2629
2919	5	2629
3017	5	2629
3110	5	2629
3174	5	2629
1471	6	2629
1746	6	2629
1746	6	2629
2194	6	2629
2358	6	2629
2377	6	2629
2436	6	2629
2536	6	2629
2593	6	2629
2625	6	2629
2626	6	2629
2629	6	2629
2629	6	2629
2629	6	2629
2629	6	2629
2629	6	2629
2629	6	2629
2629	6	2629
2858	6	2629


************************

************************
Document:  CACM-2522.html
************************


The Design, Implementation, and Evaluation of a Working Set Dispatcher

The behavior of a computer system is largely
dependent upon the algorithms employed to allocate 
the system resources to the processes competing for them.
 Recent research in time-sharing paging systems 
has developed the working set model for program behavior,
and are source allocation strategy based on 
this model has been proposed.  Two implementations
along these principles have been reported, but it 
seems that in neither case have further results been
announced.  This report discusses the design and 
implementation of a dispatcher based on the working set
principle, presents data to permit analysis of 
its behavior, and indicates future directions of research
on methods of controlling a computer system.

CACM April, 1973

Rodriguez-Rosell, J.
Dupuy, J. P.

working set, dispatcher, scheduler, time-sharing
systems, resource allocation, software evaluation, 
<B>operating systems</B>, supervisory systems

4.31 4.32

CA730406 JB January 24, 1978  9:36 AM

2522	5	2522
2522	5	2522
2522	5	2522
2928	5	2522
1751	6	2522
2277	6	2522
2380	6	2522
2522	6	2522
2569	6	2522


************************



The Design, Implementation, and Evaluation of a Working Set Dispatcher

The behavior of a computer system is largely
dependent upon the algorithms employed to allocate 
the system resources to the processes competing for them.
 Recent research in time-sharing paging systems 
has developed the working set model for program behavior,
and are source allocation strategy <B>based on</B> 
this model has been proposed.  Two implementations
along these principles have been reported, but it 
seems that in neither case have further results been
announced.  This report discusses the design and 
implementation of a dispatcher based on the working set
principle, presents data to permit analysis of 
its behavior, and indicates future directions of research
on methods of controlling a computer system.

CACM April, 1973

Rodriguez-Rosell, J.
Dupuy, J. P.

working set, dispatcher, scheduler, time-sharing
systems, resource allocation, software evaluation, 
operating systems, supervisory systems

4.31 4.32

CA730406 JB January 24, 1978  9:36 AM

2522	5	2522
2522	5	2522
2522	5	2522
2928	5	2522
1751	6	2522
2277	6	2522
2380	6	2522
2522	6	2522
2569	6	2522


************************

************************
Document:  CACM-1462.html
************************


Multilevel Operating Systems

The Basic software for all newer computers
is built on the well-established need for standard 
<B>operating systems</B>. This implies that all applications-no
matter how large, complex or time consuming-must 
operate under (or, more precisely, on top of) the standard
system.  Large applications require supervisory 
monitors which handle problems similar to those of
the operating systems, but at a different level.  
Sometimes, still a third or even a fourth such level
is required or desirable.  This leads naturally 
to the concept of multilevel systems-similar vertically,
but different horizontally.  Proper division 
of responsibility between levels leads to greater efficiency and
less logical complexity, while actually 
enhancing capability.

CACM March, 1966

Orchard-Hays, W.

CA660310 JB March 3, 1978  1:31 PM

1462	5	1462
1462	5	1462
1462	5	1462
1781	5	1462
123	6	1462
196	6	1462
919	6	1462
990	6	1462
1007	6	1462
1046	6	1462
1131	6	1462
1139	6	1462
1140	6	1462
1149	6	1462
1198	6	1462
1215	6	1462
1223	6	1462
1265	6	1462
1303	6	1462
1323	6	1462
1358	6	1462
1366	6	1462
1421	6	1462
1460	6	1462
1462	6	1462
1463	6	1462
1467	6	1462
1468	6	1462
1477	6	1462
1491	6	1462
1496	6	1462
1531	6	1462
1535	6	1462
1565	6	1462
1601	6	1462
1602	6	1462
1613	6	1462
1614	6	1462
1626	6	1462
1641	6	1462
1787	6	1462
1788	6	1462
205	6	1462
224	6	1462
249	6	1462
288	6	1462
316	6	1462
381	6	1462
398	6	1462
11	6	1462
404	6	1462
410	6	1462
463	6	1462
464	6	1462
483	6	1462
3184	6	1462
3188	6	1462
584	6	1462
600	6	1462
680	6	1462
691	6	1462
763	6	1462
799	6	1462


************************

************************
Document:  CACM-2777.html
************************


On a Solution to the Cigarette Smoker's
Problem (Without Conditional Statements)

This report discusses a problem first introduced
by Patil, who has claimed that the cigarette 
smoker's problem cannot be solved using the P and V operations
introduced by Dijkstra unless conditional 
statements are used.  An examination of Patil's proof
shows that he has established this claim only under 
strong restrictions on the use of P and V.  These restrictions
eliminate programming techniques used 
by Dijkstra and others since the first introduction
of the semaphore concept.  This paper contains a 
solution to the problem.  It also discusses the need
for the generalized operators suggested by Patil.

CACM March, 1975

Parnas, D. L.

<B>operating systems</B>, co-operating processes,process
synchronization primitives

4.3

CA750311 JB January 9, 1978  4:24 PM 

2320	4	2777
2597	4	2777
2777	4	2777
2851	4	2777
2895	4	2777
2912	4	2777
2946	4	2777
3128	4	2777
2150	5	2777
2738	5	2777
2777	5	2777
2777	5	2777
2777	5	2777
1749	6	2777
2080	6	2777
2247	6	2777
2356	6	2777
2777	6	2777


************************

************************
Document:  CACM-2794.html
************************


State-Space, Problem-Reduction, and Theorem Proving-Some Relationships

This paper suggests a bidirectional relationship
between state-space and problem-reduction 
representations. It presents a formalism based <B>on multiple</B>-input
and multiple-output operators which 
provides a basis for viewing the two types of representations
in this manner.  A representation of the 
language recognition problem which is based on the Cocke
parsing algorithm is used as an illustration. 
 A method for representing problems in first-order logic
in such a way that the inference system employed 
by a resolution-based theorem prover determines whether
the set of clauses is interpreted in the state-spacer 
mode or in the problem-reduction mode is presented.
 The analogous concepts in problem-reduction and 
theorem proving, and the terminology used to refer to them,
are noted.  The relationship between problem-reduction, 
input resolution, and linear resolution is discussed.

CACM February, 1975

VanderBrug, G. J.
Minker, J.

artificial intelligence, state-space representation,
problem-reduction representation, theorem 
proving, language recognition

3.64

CA750205 JB January 12, 1978  8:27 AM

2794	5	2794
2794	5	2794
2794	5	2794


************************



State-Space, Problem-Reduction, and Theorem Proving-Some Relationships

This paper suggests a bidirectional relationship
between state-space and problem-reduction 
representations. It presents a formalism <B>based on</B> multiple-input
and multiple-output operators which 
provides a basis for viewing the two types of representations
in this manner.  A representation of the 
language recognition problem which is based on the Cocke
parsing algorithm is used as an illustration. 
 A method for representing problems in first-order logic
in such a way that the inference system employed 
by a resolution-based theorem prover determines whether
the set of clauses is interpreted in the state-spacer 
mode or in the problem-reduction mode is presented.
 The analogous concepts in problem-reduction and 
theorem proving, and the terminology used to refer to them,
are noted.  The relationship between problem-reduction, 
input resolution, and linear resolution is discussed.

CACM February, 1975

VanderBrug, G. J.
Minker, J.

artificial intelligence, state-space representation,
problem-reduction representation, theorem 
proving, language recognition

3.64

CA750205 JB January 12, 1978  8:27 AM

2794	5	2794
2794	5	2794
2794	5	2794


************************

