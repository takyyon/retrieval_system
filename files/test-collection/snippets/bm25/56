Snippets for the query:  Abstracts of articles: J. Backus, "Can programming be liberated from the Von Neumann style? A functional style and its algebra of programs", CACM 21 Re Millo, R. Lipton, A. Perlis, letter to ACM Forum, CACM 22 (1979), 629-630 Backus, J. De Millo, R. Lipton, R. Perlis, A.
************************
Total Hits:  32
************************

************************
Document:  CACM-2842.html
************************


The Denotational Semantics of Programming Languages

This paper is a tutorial introduction to the
theory of programming language semantics developed 
by D. Scott and C. Strachey.  The application of the theory
to formal language specification is demonstrated 
and other applications are surveyed. The first language
considered, LOOP, is very elementary <B>and its</B> 
definition merely introduces the notation and methodology
of the approach.  Then the semantic concepts
of environments, stores, and continuations are introduced
to model classes of programming language features 
and the underlying mathematical theory of computation
due to Scott is motivated and outlined.  Finally, 
the paper presents a formal definition of the language GEDANKEN.

CACM August, 1976

Tennent, R. D.

semantics, programming language, applicative, imperative,
environment, store, continuation, theory 
of computation, higher-order function, recursive definition, LOOP, GEDANKEN

4.22 5.24

CA760802 JB January 4, 1978  10:33 AM

1024	4	2842
1051	4	2842
1086	4	2842
1102	4	2842
1132	4	2842
1132	4	2842
1234	4	2842
1263	4	2842
1265	4	2842
1270	4	2842
1323	4	2842
1358	4	2842
1379	4	2842
1380	4	2842
1390	4	2842
1453	4	2842
1464	4	2842
1484	4	2842
1486	4	2842
1491	4	2842
1498	4	2842
1549	4	2842
1613	4	2842
1614	4	2842
1706	4	2842
1781	4	2842
1825	4	2842
1826	4	2842
1860	4	2842
1878	4	2842
378	4	2842
2060	4	2842
2083	4	2842
2155	4	2842
2155	4	2842
2168	4	2842
2178	4	2842
2179	4	2842
2252	4	2842
2294	4	2842
2314	4	2842
2317	4	2842
2325	4	2842
2326	4	2842
2341	4	2842
2457	4	2842
2546	4	2842
2558	4	2842
2645	4	2842
2652	4	2842
2684	4	2842
2719	4	2842
2723	4	2842
2838	4	2842
2842	4	2842
2842	4	2842
2842	4	2842
2842	4	2842
2842	4	2842
2855	4	2842
2879	4	2842
2903	4	2842
2929	4	2842
2934	4	2842
3069	4	2842
3077	4	2842
3077	4	2842
3080	4	2842
3106	4	2842
3150	4	2842
627	4	2842
669	4	2842
679	4	2842
691	4	2842
761	4	2842
106	4	2842
949	4	2842
989	4	2842
210	5	2842
2060	5	2842
2148	5	2842
2192	5	2842
2837	5	2842
2842	5	2842
2842	5	2842
2842	5	2842
3150	5	2842
3184	5	2842
2060	6	2842
2704	6	2842
2784	6	2842
2842	6	2842
2842	6	2842
2939	6	2842
2940	6	2842
2941	6	2842
2943	6	2842
3073	6	2842
3148	6	2842


************************

************************
Document:  CACM-2684.html
************************


Production Systems: or Can We Do Better than BNF?

Since the development of BNF, the definition
of the syntax of programming languages has been 
almost universally associated with context-free requirements.
 Yet numerous interesting and difficult 
issues in syntax stem from the context-sensitive requirements,
notably the compatibility between the 
declaration of an identifier <B>and its</B> uses, the correspondence
between actual and formal parameters, and 
issues arising from block structure.  This paper explores
the use of a formal notation called Production 
Systems in providing a readable and complete formal definition
of syntax.  As a practical illustration, 
a small but significant subset of PL/I is considered.  A
more detailed presentation, as well as the application 
to define abstract syntax and translations between languages,
is given in a previous paper by the author.

CACM February, 1974

Ledgard, H. F.

syntax, translation, context-sensitive grammars,
compilers, formal definition, PL/I standards

4.2 5.21 5.23

CA740205 JB January 18, 1978  1:07 PM

1086	4	2684
1132	4	2684
1234	4	2684
1263	4	2684
1265	4	2684
1270	4	2684
1323	4	2684
1358	4	2684
1379	4	2684
1380	4	2684
1453	4	2684
1464	4	2684
1469	4	2684
1484	4	2684
1486	4	2684
1491	4	2684
1491	4	2684
1498	4	2684
1613	4	2684
1614	4	2684
1781	4	2684
1781	4	2684
1781	4	2684
1825	4	2684
1860	4	2684
2083	4	2684
2178	4	2684
2178	4	2684
2178	4	2684
2179	4	2684
2252	4	2684
2325	4	2684
2326	4	2684
2326	4	2684
2341	4	2684
2470	4	2684
2546	4	2684
2645	4	2684
2652	4	2684
2684	4	2684
2684	4	2684
2684	4	2684
2842	4	2684
2929	4	2684
2934	4	2684
3044	4	2684
3069	4	2684
669	4	2684
679	4	2684
691	4	2684
761	4	2684
949	4	2684
989	4	2684
1303	5	2684
1323	5	2684
2684	5	2684
2684	5	2684
2684	5	2684
3184	5	2684


************************



Production Systems: or Can We Do Better than BNF?

Since the development of BNF, the definition
of the syntax of programming languages has been 
almost universally associated with context-free requirements.
 Yet numerous interesting and difficult 
issues in syntax stem <B>from the</B> context-sensitive requirements,
notably the compatibility between the 
declaration of an identifier and its uses, the correspondence
between actual and formal parameters, and 
issues arising from block structure.  This paper explores
the use of a formal notation called Production 
Systems in providing a readable and complete formal definition
of syntax.  As a practical illustration, 
a small but significant subset of PL/I is considered.  A
more detailed presentation, as well as the application 
to define abstract syntax and translations between languages,
is given in a previous paper by the author.

CACM February, 1974

Ledgard, H. F.

syntax, translation, context-sensitive grammars,
compilers, formal definition, PL/I standards

4.2 5.21 5.23

CA740205 JB January 18, 1978  1:07 PM

1086	4	2684
1132	4	2684
1234	4	2684
1263	4	2684
1265	4	2684
1270	4	2684
1323	4	2684
1358	4	2684
1379	4	2684
1380	4	2684
1453	4	2684
1464	4	2684
1469	4	2684
1484	4	2684
1486	4	2684
1491	4	2684
1491	4	2684
1498	4	2684
1613	4	2684
1614	4	2684
1781	4	2684
1781	4	2684
1781	4	2684
1825	4	2684
1860	4	2684
2083	4	2684
2178	4	2684
2178	4	2684
2178	4	2684
2179	4	2684
2252	4	2684
2325	4	2684
2326	4	2684
2326	4	2684
2341	4	2684
2470	4	2684
2546	4	2684
2645	4	2684
2652	4	2684
2684	4	2684
2684	4	2684
2684	4	2684
2842	4	2684
2929	4	2684
2934	4	2684
3044	4	2684
3069	4	2684
669	4	2684
679	4	2684
691	4	2684
761	4	2684
949	4	2684
989	4	2684
1303	5	2684
1323	5	2684
2684	5	2684
2684	5	2684
2684	5	2684
3184	5	2684


************************

************************
Document:  CACM-1700.html
************************


PEEKABIT, Computer Offspring of Punched
Card PEEKABOO, for Natural Language Searching

The "peekaboo" idea from punched card information
retrieval methods has been mated with the 
idea of superimposed punching to produce a programming
technique which cuts computer run time in half 
on a test search of 33,000 subject index entries.  A search
program using the device has been operational 
since late 1963.  As an item is entered in the store,
an 18-byte mask is created <B>from the</B> item's meaningful 
words using the inclusive OR operation.  If, at search
time, the logical product (using the AND operation) 
of this mask and a similarly constructed question mask
is not equal to the question mask, then one or 
more question words are not present in the store item.
 An equality is in conclusive; the words of the 
store item must be unpacked and compared with question
words.  The present store is made up of over 600,000 
subject index entries estimated to average 60 characters
each.  Longer texts, such as abstracts, could 
be handled by multiple masks.

CACM September,1968

Hutton, F. C.

peekaboo, superimposed coding, natural language
searching text searching, information compaction, 
computer search technique

3.74

CA680901 JB February 22, 1978  9:38 AM

1700	5	1700
1700	5	1700
1700	5	1700


************************

************************
Document:  CACM-1458.html
************************


Online Programming

When the transition has been made from off line
to online programming, there are a number of 
changes in the working conditions noted.  These changes
in the environment make necessary corresponding 
changes in the processes related to producing and checking
out programs.  In the main, it it not the 
programming language itself which must be changed to
provide a facility for the online user; it is the 
system surrounding the programming language.  In this
paper the online environment <B>and its</B> effect on 
programming are discussed.

CACM March, 1966

Schwartz, J. I.

CA660314 JB March 3, 197811:44 AM

1458	4	1458
1523	4	1458
1603	4	1458
1698	4	1458
1747	4	1458
1748	4	1458
1854	4	1458
1877	4	1458
1960	4	1458
2377	4	1458
2378	4	1458
2497	4	1458
2558	4	1458
2625	4	1458
2632	4	1458
2840	4	1458
2941	4	1458
3105	4	1458
3144	4	1458
1458	5	1458
1458	5	1458
1458	5	1458
1471	5	1458


************************

************************
Document:  CACM-1781.html
************************


Translator Writing systems

A critical review of recent efforts to automate
the writing of translators of programming languages 
is presented.  The formal study of syntax <B>and its</B> application
to translator writing are discussed in 
Section II.  Various approaches to automating the post syntactic
(semantic) aspects of translator writing 
are discussed in Section III, and several related topics in Section IV.

CACM February, 1968

Feldman, J.
Gries, D.

compiler, compiler-compiler, translator, translator
writing systems, metacompiler, syntax, semantics, 
syntax-directed, meta-assembler, macroprocessor,
parser, syntactic analysis, generator

4.1 4.10 4.12 4.22 5.23

CA680201 JB February 23, 1978  2:02 PM

249	4	1781
254	4	1781
267	4	1781
272	4	1781
1046	4	1781
1062	4	1781
1072	4	1781
1086	4	1781
1102	4	1781
1102	4	1781
1105	4	1781
1109	4	1781
1121	4	1781
1132	4	1781
1139	4	1781
1139	4	1781
1139	4	1781
1140	4	1781
1140	4	1781
1141	4	1781
1142	4	1781
1188	4	1781
1215	4	1781
1215	4	1781
1223	4	1781
1225	4	1781
1234	4	1781
1234	4	1781
1263	4	1781
1263	4	1781
1265	4	1781
1265	4	1781
1265	4	1781
1270	4	1781
1306	4	1781
1306	4	1781
1323	4	1781
1323	4	1781
1350	4	1781
1350	4	1781
1358	4	1781
1358	4	1781
1358	4	1781
1358	4	1781
1379	4	1781
1379	4	1781
1380	4	1781
1380	4	1781
1380	4	1781
1396	4	1781
1399	4	1781
1425	4	1781
1453	4	1781
1464	4	1781
1464	4	1781
1469	4	1781
1484	4	1781
1486	4	1781
1491	4	1781
1491	4	1781
1491	4	1781
1491	4	1781
1496	4	1781
1498	4	1781
1498	4	1781
1503	4	1781
1530	4	1781
1541	4	1781
1542	4	1781
1552	4	1781
1565	4	1781
1565	4	1781
1612	4	1781
1613	4	1781
1614	4	1781
1626	4	1781
1646	4	1781
1647	4	1781
1659	4	1781
1665	4	1781
1683	4	1781
1693	4	1781
1693	4	1781
1693	4	1781
1693	4	1781
1708	4	1781
1708	4	1781
1767	4	1781
1767	4	1781
1767	4	1781
1767	4	1781
1768	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1781	4	1781
1787	4	1781
1787	4	1781
1787	4	1781
1787	4	1781
1787	4	1781
1787	4	1781
1787	4	1781
1788	4	1781
1788	4	1781
1792	4	1781
1807	4	1781
1824	4	1781
1824	4	1781
1824	4	1781
1825	4	1781
1826	4	1781
1836	4	1781
1836	4	1781
1852	4	1781
1854	4	1781
1860	4	1781
1860	4	1781
1860	4	1781
1860	4	1781
1860	4	1781
1860	4	1781
1861	4	1781
1945	4	1781
1945	4	1781
1945	4	1781
1945	4	1781
1945	4	1781
1945	4	1781
1945	4	1781
1945	4	1781
1945	4	1781
1945	4	1781
1945	4	1781
1947	4	1781
1949	4	1781
1988	4	1781
1988	4	1781
1988	4	1781
1989	4	1781
321	4	1781
364	4	1781
2015	4	1781
2034	4	1781
2059	4	1781
2060	4	1781
2060	4	1781
2060	4	1781
2061	4	1781
2061	4	1781
2061	4	1781
2083	4	1781
2082	4	1781
2091	4	1781
2091	4	1781
2091	4	1781
2110	4	1781
2112	4	1781
2126	4	1781
2126	4	1781
2126	4	1781
2150	4	1781
2152	4	1781
2156	4	1781
2168	4	1781
2175	4	1781
2178	4	1781
2178	4	1781
2178	4	1781
2179	4	1781
2179	4	1781
2179	4	1781
2228	4	1781
2249	4	1781
2252	4	1781
2252	4	1781
2252	4	1781
2256	4	1781
2299	4	1781
2314	4	1781
2317	4	1781
2325	4	1781
2326	4	1781
2326	4	1781
2341	4	1781
2341	4	1781
2341	4	1781
2340	4	1781
2356	4	1781
2342	4	1781
2376	4	1781
2470	4	1781
2534	4	1781
2534	4	1781
405	4	1781
2541	4	1781
2546	4	1781
2546	4	1781
2546	4	1781
2546	4	1781
435	4	1781
437	4	1781
438	4	1781
438	4	1781
2579	4	1781
463	4	1781
464	4	1781
483	4	1781
491	4	1781
2603	4	1781
2603	4	1781
2618	4	1781
2645	4	1781
2650	4	1781
2652	4	1781
2684	4	1781
2684	4	1781
2684	4	1781
2698	4	1781
2698	4	1781
2698	4	1781
2698	4	1781
2708	4	1781
2708	4	1781
2708	4	1781
2708	4	1781
2719	4	1781
2732	4	1781
2733	4	1781
2736	4	1781
2820	4	1781
2824	4	1781
2833	4	1781
2842	4	1781
2929	4	1781
2934	4	1781
2982	4	1781
2986	4	1781
557	4	1781
560	4	1781
583	4	1781
584	4	1781
3044	4	1781
3045	4	1781
3045	4	1781
3069	4	1781
3073	4	1781
3073	4	1781
3093	4	1781
3093	4	1781
3094	4	1781
3155	4	1781
3184	4	1781
627	4	1781
631	4	1781
631	4	1781
632	4	1781
637	4	1781
642	4	1781
644	4	1781
653	4	1781
653	4	1781
669	4	1781
669	4	1781
679	4	1781
680	4	1781
680	4	1781
691	4	1781
720	4	1781
729	4	1781
759	4	1781
761	4	1781
761	4	1781
762	4	1781
762	4	1781
762	4	1781
763	4	1781
763	4	1781
763	4	1781
795	4	1781
799	4	1781
123	4	1781
140	4	1781
919	4	1781
945	4	1781
949	4	1781
949	4	1781
949	4	1781
989	4	1781
989	4	1781
989	4	1781
123	5	1781
196	5	1781
919	5	1781
990	5	1781
1007	5	1781
1046	5	1781
1131	5	1781
1139	5	1781
1140	5	1781
1149	5	1781
1198	5	1781
1215	5	1781
1223	5	1781
1265	5	1781
1303	5	1781
1323	5	1781
205	5	1781
1358	5	1781
224	5	1781
249	5	1781
1366	5	1781
288	5	1781
1421	5	1781
1460	5	1781
1462	5	1781
1463	5	1781
1468	5	1781
1467	5	1781
1477	5	1781
1491	5	1781
1496	5	1781
1531	5	1781
1535	5	1781
1565	5	1781
1601	5	1781
1602	5	1781
1613	5	1781
1614	5	1781
1626	5	1781
1641	5	1781
1665	5	1781
1768	5	1781
1781	5	1781
1781	5	1781
1781	5	1781
1787	5	1781
1788	5	1781
1824	5	1781
1825	5	1781
1836	5	1781
1861	5	1781
316	5	1781
381	5	1781
398	5	1781
2015	5	1781
2110	5	1781
2127	5	1781
2187	5	1781
2317	5	1781
2545	5	1781
2698	5	1781
2733	5	1781
404	5	1781
410	5	1781
463	5	1781
464	5	1781
483	5	1781
11	5	1781
584	5	1781
3184	5	1781
3188	5	1781
600	5	1781
680	5	1781
691	5	1781
763	5	1781
799	5	1781
196	6	1781
1141	6	1781
1141	6	1781
1155	6	1781
1191	6	1781
1198	6	1781
1215	6	1781
1265	6	1781
1265	6	1781
1324	6	1781
1358	6	1781
1477	6	1781
1477	6	1781
1477	6	1781
1487	6	1781
1491	6	1781
1491	6	1781
1491	6	1781
1496	6	1781
1527	6	1781
1572	6	1781
1614	6	1781
1614	6	1781
1693	6	1781
1739	6	1781
1748	6	1781
1749	6	1781
1753	6	1781
1781	6	1781
1781	6	1781
1781	6	1781
1781	6	1781
1781	6	1781
1781	6	1781
1781	6	1781
1781	6	1781
1781	6	1781
1781	6	1781
1781	6	1781
1781	6	1781
1781	6	1781
1781	6	1781
1781	6	1781
224	6	1781
1856	6	1781
378	6	1781
2110	6	1781
2126	6	1781
2148	6	1781
2179	6	1781
2341	6	1781
2423	6	1781
2556	6	1781
2786	6	1781
404	6	1781
408	6	1781
3184	6	1781
577	6	1781
631	6	1781
680	6	1781
763	6	1781
799	6	1781
799	6	1781
799	6	1781
799	6	1781


************************

************************
Document:  CACM-2931.html
************************


Logic and Programming Languages

Logic has been long in terested in whether answers
to certain questions are computable in principle, 
since the outcome puts bounds on the possibilities of
formalization.  More recently, precise comparisons 
in the efficiency of decision methods have become available
through the developments in complexity theory. 
 These, however, are applications to logic, and a big question
is whether methods of logic have significance 
in the other direction for the more applied parts of
computability theory.  Programming languages offer 
an obvious opportunity as their syntactic formalization
is well advanced; however, the semantical theory 
can hardly be said to be complete.  Though we have
many examples, we have still to give wide-ranging 
mathematical answers to these queries:  What is a machine?
 What is a computable process?  How (or how 
well) does a machine simulate a process?  Programs naturally
enter in giving descriptions of processes. 
 The definition of the precise meaning of a program
then requires us to explain what are the objects 
of computation (in a way, the statics of the problem)
and how they are to be transformed (the dynamics). 
 So far the theories of automata and of nets, though
most in teresting for dynamics, have formalized only 
a portion of the field, and there has been perhaps too
much concentration on the finite-state and algebraic 
aspects.  It would seem that the understanding of higher-level
program features involves us with infinite 
objects and forces us to pass through several levels
of explanation to go <B>from the</B> conceptual ideas to 
the final simulation on a real machine.  These levels
can be made mathematically exact if we can find 
the right abstractions to represent the necessary structures.
 The experience of many independent workers 
with the method of data types as lattices (or partial
orderings) under an information content ordering, 
and with their continuous mappings, has demonstrated the
flexibility of this approach in providing definitions 
and proofs, which are clean and without undue dependence
on implementations.  Nevertheless much remains 
to be done in showing how abstract conceptualizations
can (or cannot) be actualized before we can say 
we have a unified theory.

CACM September, 1977

Scott, D. S.

logic, programming languages, automata, denotational
semantics, a-calculus models, computability, 
partial functions, approximation, function spaces

1.2 4.20 5.21 5.24 5.27

CA770902 JB December 28, 1977  6:49 AM

2931	5	2931
2931	5	2931
2931	5	2931


************************

************************
Document:  CACM-1496.html
************************


A Formal Semantics for Computer Languages
<B>and its</B> Application In a Compiler-Compiler

A semantic meta-language has been developed
for representing the meanings of statements in 
a large class of computer languages.  This meta-language
has been the basis for construction of an efficient, 
functioning compiler-compiler.  An informal discussion
of the meta-language based on the example of a 
complete translator for a small language is presented.

CACM January, 1966 

Feldman, J. A.

CA660101 JB March 3, 1978  4:31 PM

1046	4	1496
1086	4	1496
1105	4	1496
1139	4	1496
1140	4	1496
1234	4	1496
1263	4	1496
1265	4	1496
1496	4	1496
1496	4	1496
1496	4	1496
1683	4	1496
1768	4	1496
1781	4	1496
1787	4	1496
1824	4	1496
1945	4	1496
2061	4	1496
2126	4	1496
2546	4	1496
464	4	1496
584	4	1496
631	4	1496
653	4	1496
680	4	1496
763	4	1496
795	4	1496
799	4	1496
945	4	1496
1137	5	1496
1141	5	1496
1396	5	1496
1496	5	1496
1496	5	1496
1496	5	1496
1767	5	1496
1781	5	1496
1787	5	1496
1860	5	1496
1945	5	1496
1988	5	1496
2252	5	1496
404	5	1496
823	6	1496
123	6	1496
196	6	1496
196	6	1496
196	6	1496
914	6	1496
915	6	1496
917	6	1496
919	6	1496
964	6	1496
984	6	1496
989	6	1496
990	6	1496
990	6	1496
1007	6	1496
1012	6	1496
1028	6	1496
1029	6	1496
1046	6	1496
1083	6	1496
1084	6	1496
1098	6	1496
1122	6	1496
1131	6	1496
1132	6	1496
1138	6	1496
1139	6	1496
1139	6	1496
1140	6	1496
1141	6	1496
1141	6	1496
1149	6	1496
1198	6	1496
1200	6	1496
1214	6	1496
1215	6	1496
1215	6	1496
1223	6	1496
1223	6	1496
1265	6	1496
1265	6	1496
1278	6	1496
1303	6	1496
1323	6	1496
1334	6	1496
1336	6	1496
1358	6	1496
1358	6	1496
1365	6	1496
1366	6	1496
1366	6	1496
1386	6	1496
1387	6	1496
1388	6	1496
1389	6	1496
1392	6	1496
1393	6	1496
1394	6	1496
1395	6	1496
1396	6	1496
1396	6	1496
1397	6	1496
1421	6	1496
1421	6	1496
1455	6	1496
1460	6	1496
1462	6	1496
1463	6	1496
1467	6	1496
1467	6	1496
1468	6	1496
1468	6	1496
1477	6	1496
1477	6	1496
1487	6	1496
1491	6	1496
1491	6	1496
1491	6	1496
1496	6	1496
1496	6	1496
1496	6	1496
1496	6	1496
1496	6	1496
1496	6	1496
1496	6	1496
1496	6	1496
1531	6	1496
1535	6	1496
1565	6	1496
1601	6	1496
1602	6	1496
1613	6	1496
1614	6	1496
1626	6	1496
1626	6	1496
1641	6	1496
1641	6	1496
1781	6	1496
1785	6	1496
1786	6	1496
1787	6	1496
1788	6	1496
205	6	1496
224	6	1496
224	6	1496
249	6	1496
284	6	1496
288	6	1496
316	6	1496
378	6	1496
381	6	1496
381	6	1496
398	6	1496
11	6	1496
11	6	1496
14	6	1496
2155	6	1496
404	6	1496
407	6	1496
410	6	1496
463	6	1496
464	6	1496
483	6	1496
483	6	1496
3184	6	1496
3184	6	1496
3184	6	1496
3188	6	1496
3199	6	1496
3200	6	1496
3201	6	1496
3202	6	1496
3203	6	1496
3204	6	1496
561	6	1496
584	6	1496
584	6	1496
600	6	1496
669	6	1496
680	6	1496
680	6	1496
691	6	1496
730	6	1496
763	6	1496
763	6	1496
763	6	1496
799	6	1496
799	6	1496


************************

************************
Document:  CACM-1278.html
************************


Wengert's Numerical Method for Partial Derivatives,
Orbit Determination and Quasilinearization

In a recent article in the Communications
of the ACM, R. Wengert suggested a technique for 
machine evaluation of the partial derivatives of a function
given in analytical form.  In solving non-linear 
boundary-value problems using quasilinearization many
partial derivatives must be formed analytically 
and then evaluated numerically.  Wengert's method appears
very attractive <B>from the</B> programming viewpoint 
equations which might not otherwise be undertaken.

CACM April, 1965

Bellman, R. E.
Kagiwada, H.
Kalaba, R. E.

CA650413 JB March 7, 1978  3:39 PM

1028	4	1278
1216	4	1278
1216	4	1278
1278	4	1278
1278	4	1278
1278	4	1278
1347	4	1278
1347	4	1278
1396	4	1278
1396	4	1278
1536	4	1278
973	5	1278
1028	5	1278
1029	5	1278
1278	5	1278
1278	5	1278
1278	5	1278
1347	5	1278
1396	5	1278
964	6	1278
1028	6	1278
1028	6	1278
1029	6	1278
1029	6	1278
1083	6	1278
1132	6	1278
1214	6	1278
1278	6	1278
1278	6	1278
1334	6	1278
1365	6	1278
1386	6	1278
1387	6	1278
1388	6	1278
1392	6	1278
1393	6	1278
1394	6	1278
1395	6	1278
1396	6	1278
1397	6	1278
1496	6	1278
284	6	1278
407	6	1278
3199	6	1278
3200	6	1278
3201	6	1278
3202	6	1278
3203	6	1278
3204	6	1278
561	6	1278
730	6	1278


************************

************************
Document:  CACM-2941.html
************************


Early Experience with Mesa

The experiences of Mesa's first users-primarily
its implementers-are discussed, and some implications 
for Mesa and similar programming languages are suggested.
The specific topics addressed are: module structure 
<B>and its</B> use in defining abstractions, data-structuring
facilities in Mesa, an equivalence algorithm for 
types and type coercions, the benefits of the type system
and why it is breached occasionally, and the 
difficulty of making the treatment of variant records safe.

CACM August, 1977

Geschke, C. M.
Morris, J. H. Jr.
Satterthwaite, E. H.

programming languages, types, modules,
data structures, systems programming

4.22

CA770802 JB December 28, 1977  8:07 AM

1458	4	2941
1523	4	2941
1603	4	2941
1698	4	2941
1747	4	2941
1748	4	2941
1854	4	2941
1877	4	2941
1960	4	2941
2377	4	2941
2378	4	2941
2497	4	2941
2558	4	2941
2625	4	2941
2632	4	2941
2704	4	2941
2723	4	2941
2738	4	2941
2840	4	2941
2866	4	2941
2868	4	2941
2869	4	2941
2939	4	2941
2941	4	2941
2941	4	2941
2941	4	2941
2941	4	2941
2956	4	2941
2958	4	2941
3004	4	2941
3030	4	2941
3030	4	2941
3105	4	2941
3144	4	2941
1471	5	2941
2356	5	2941
2558	5	2941
2651	5	2941
2941	5	2941
2941	5	2941
2941	5	2941
3150	5	2941
2060	6	2941
2704	6	2941
2842	6	2941
2939	6	2941
2940	6	2941
2941	6	2941
2943	6	2941
3073	6	2941
3148	6	2941


************************

************************
Document:  CACM-2061.html
************************


An Algorithm for the Construction Of Bounded-Context Parsers

An algorithm is described which accepts an arbitrary context-free
grammar and constructs a bounded-context parser for
it whenever such a parser exists.  In the first part of the paper
the definition of a context-free grammar and the working of a
bounded-context parser are recalled.  The notion of reduction class for
a context-free grammar is then introduced <B>and its</B> connection with
the structure of a bounded-context parser is indicated.  Next,
pushdown automata which generate the different reduction classes
of a context-free grammar are defined.  Finally, the algorithm is described;
it essentially carries out an exhaustive study of all possible
runs of the pushdown automata generating the reduction classes.
In the second part, the utility of the algorithm is discuss
ed in the light of the experience gained from its use in compiler design.
The algorithm is claimed to be particularly useful in the
simultaneous design of a language and a compiler for it.

CACM May, 1970

Loeckx, J.

bounded-context parsing, bounded-context syntactic analysis, parser 
construction, syntactical analyzer construction, generators, compiler 
compilers, compiler writing systems, translator writing systems metacompilers,
context-free grammars, formal languages, pushdown automata

4.12 5.22 5.23

CA700505 JB February 13, 1978  1:58 PM

1379	4	2061
1491	4	2061
1496	4	2061
1542	4	2061
1683	4	2061
1683	4	2061
1693	4	2061
1693	4	2061
1768	4	2061
1781	4	2061
1781	4	2061
1781	4	2061
1787	4	2061
1787	4	2061
1836	4	2061
1836	4	2061
1945	4	2061
1945	4	2061
1945	4	2061
2015	4	2061
2060	4	2061
2060	4	2061
2061	4	2061
2061	4	2061
2061	4	2061
2061	4	2061
2061	4	2061
2061	4	2061
2082	4	2061
2091	4	2061
2091	4	2061
2152	4	2061
2179	4	2061
2179	4	2061
2179	4	2061
2340	4	2061
2356	4	2061
2546	4	2061
2546	4	2061
2603	4	2061
2698	4	2061
2698	4	2061
2708	4	2061
2708	4	2061
2824	4	2061
2982	4	2061
2986	4	2061
3045	4	2061
3045	4	2061
3093	4	2061
1140	5	2061
1141	5	2061
1477	5	2061
1491	5	2061
1825	5	2061
2061	5	2061
2061	5	2061
2061	5	2061
773	5	2061


************************

************************
Document:  CACM-3077.html
************************


Can Programming Be Liberated from the von Neumann
Style?  A Functional Style and Its Algebra 
of Programs

Conventional programming languages are growing
ever more enormous, but not stronger.  Inherent 
defects at the most basic level cause them to be both
fat and weak: their primitive word-at-a-time style 
of programming inherited from their common ancestor-the
von Neumann computer, their close coupling off 
semantics to state transitions, their division of programming
into a world of expressions and a world 
of statements, their inability to effectively use powerful
combining forms for building new programs 
from existing ones, and their lack of useful mathematical
properties for reasoning about programs. An 
alternative functional style of programming is founded
on the use of combining forms for creating programs. 
 Functional programs deal with structured data, are often
nonrepetitive and nonrecursive, are hierarchically 
constructed, do not name their arguments, and do not require
the complex machinery of procedure declarations 
to become generally applicable.  Combining forms can
use high level programs to build still higher level
ones in a style not possible in conventional languages.
 Associated with the functional style of programming 
is an algebra of programs whose variables range over
programs and whose operations are combining forms. 
 This algebra can be used to transform programs and
to solve equations whose "unknowns" are programs 
in much the same way one transforms equations in high
school algebra.  These transformations are given 
by algebraic laws and are carried out in the same language
in which programs are written.  Combining 
forms are chosen not only for their programming power
but also for the power of their associated algebraic 
laws.  General theorems of of the algebra give the detailed
behavior and termination conditions for large 
classes of programs.  A new class of computing systems
uses the functional programming style both in 
its programming language and in its state transition
rules.  Unlike von Neumann languages, these systems 
have semantics loosely coupled to states-only one
state transition occurs per major computation. 

CACM August, 1978

<B>Backus, J.</B>

Functional programming, algebra of programs, combining
forms, functional forms, programming languages, 
von Neumann computers, von Neumann languages, models of
computing systems, applicative computing systems, 
applicative state transition systems, program transformation,
program correctness, program termination, 
metacomposition

4.20 4.29 5.20 5.24 5.26

CA780801 DH February 7, 1979  3:13 PM

1024	4	3077
1051	4	3077
1102	4	3077
1132	4	3077
1390	4	3077
1486	4	3077
1549	4	3077
1706	4	3077
1826	4	3077
1878	4	3077
378	4	3077
2021	4	3077
2060	4	3077
2155	4	3077
2155	4	3077
2168	4	3077
2222	4	3077
2227	4	3077
2294	4	3077
2315	4	3077
2326	4	3077
2470	4	3077
2558	4	3077
2719	4	3077
2723	4	3077
2732	4	3077
2838	4	3077
2842	4	3077
2842	4	3077
2855	4	3077
2865	4	3077
2879	4	3077
2896	4	3077
2943	4	3077
2981	4	3077
3014	4	3077
3030	4	3077
3068	4	3077
3077	4	3077
3077	4	3077
3077	4	3077
3077	4	3077
3080	4	3077
3104	4	3077
3106	4	3077
3143	4	3077
3150	4	3077
627	4	3077
106	4	3077
210	5	3077
1834	5	3077
2060	5	3077
2457	5	3077
3077	5	3077
3077	5	3077
3077	5	3077


************************



Can Programming Be Liberated <B>from the</B> von Neumann
Style?  A Functional Style and Its Algebra 
of Programs

Conventional programming languages are growing
ever more enormous, but not stronger.  Inherent 
defects at the most basic level cause them to be both
fat and weak: their primitive word-at-a-time style 
of programming inherited from their common ancestor-the
von Neumann computer, their close coupling off 
semantics to state transitions, their division of programming
into a world of expressions and a world 
of statements, their inability to effectively use powerful
combining forms for building new programs 
from existing ones, and their lack of useful mathematical
properties for reasoning about programs. An 
alternative functional style of programming is founded
on the use of combining forms for creating programs. 
 Functional programs deal with structured data, are often
nonrepetitive and nonrecursive, are hierarchically 
constructed, do not name their arguments, and do not require
the complex machinery of procedure declarations 
to become generally applicable.  Combining forms can
use high level programs to build still higher level
ones in a style not possible in conventional languages.
 Associated with the functional style of programming 
is an algebra of programs whose variables range over
programs and whose operations are combining forms. 
 This algebra can be used to transform programs and
to solve equations whose "unknowns" are programs 
in much the same way one transforms equations in high
school algebra.  These transformations are given 
by algebraic laws and are carried out in the same language
in which programs are written.  Combining 
forms are chosen not only for their programming power
but also for the power of their associated algebraic 
laws.  General theorems of of the algebra give the detailed
behavior and termination conditions for large 
classes of programs.  A new class of computing systems
uses the functional programming style both in 
its programming language and in its state transition
rules.  Unlike von Neumann languages, these systems 
have semantics loosely coupled to states-only one
state transition occurs per major computation. 

CACM August, 1978

Backus, J.

Functional programming, algebra of programs, combining
forms, functional forms, programming languages, 
von Neumann computers, von Neumann languages, models of
computing systems, applicative computing systems, 
applicative state transition systems, program transformation,
program correctness, program termination, 
metacomposition

4.20 4.29 5.20 5.24 5.26

CA780801 DH February 7, 1979  3:13 PM

1024	4	3077
1051	4	3077
1102	4	3077
1132	4	3077
1390	4	3077
1486	4	3077
1549	4	3077
1706	4	3077
1826	4	3077
1878	4	3077
378	4	3077
2021	4	3077
2060	4	3077
2155	4	3077
2155	4	3077
2168	4	3077
2222	4	3077
2227	4	3077
2294	4	3077
2315	4	3077
2326	4	3077
2470	4	3077
2558	4	3077
2719	4	3077
2723	4	3077
2732	4	3077
2838	4	3077
2842	4	3077
2842	4	3077
2855	4	3077
2865	4	3077
2879	4	3077
2896	4	3077
2943	4	3077
2981	4	3077
3014	4	3077
3030	4	3077
3068	4	3077
3077	4	3077
3077	4	3077
3077	4	3077
3077	4	3077
3080	4	3077
3104	4	3077
3106	4	3077
3143	4	3077
3150	4	3077
627	4	3077
106	4	3077
210	5	3077
1834	5	3077
2060	5	3077
2457	5	3077
3077	5	3077
3077	5	3077
3077	5	3077


************************



Can Programming Be Liberated from the von Neumann
Style?  A Functional Style and Its Algebra 
of Programs

Conventional programming languages are growing
ever more enormous, but not stronger.  Inherent 
defects at the most basic level cause them to be both
fat and weak: their primitive word-at-a-time style 
of programming inherited from their common ancestor-the
von Neumann computer, their close coupling off 
semantics to state transitions, their division of programming
into a world of expressions and a world 
of statements, their inability to effectively use powerful
combining forms for building new programs 
from existing ones, and their lack of useful mathematical
properties for reasoning about programs. An 
alternative functional style of programming is founded
on the use of combining forms for creating programs. 
 Functional programs deal with structured data, are often
nonrepetitive and nonrecursive, are hierarchically 
constructed, do not name their arguments, and do not require
the complex machinery of procedure declarations 
to become generally applicable.  Combining forms can
use high level programs to build still higher level
ones in a style not possible in conventional languages.
 Associated with the functional style of programming 
is an <B>algebra of</B> programs whose variables range over
programs and whose operations are combining forms. 
 This algebra can be used to transform programs and
to solve equations whose "unknowns" are programs 
in much the same way one transforms equations in high
school algebra.  These transformations are given 
by algebraic laws and are carried out in the same language
in which programs are written.  Combining 
forms are chosen not only for their programming power
but also for the power of their associated algebraic 
laws.  General theorems of of the algebra give the detailed
behavior and termination conditions for large 
classes of programs.  A new class of computing systems
uses the functional programming style both in 
its programming language and in its state transition
rules.  Unlike von Neumann languages, these systems 
have semantics loosely coupled to states-only one
state transition occurs per major computation. 

CACM August, 1978

Backus, J.

Functional programming, algebra of programs, combining
forms, functional forms, programming languages, 
von Neumann computers, von Neumann languages, models of
computing systems, applicative computing systems, 
applicative state transition systems, program transformation,
program correctness, program termination, 
metacomposition

4.20 4.29 5.20 5.24 5.26

CA780801 DH February 7, 1979  3:13 PM

1024	4	3077
1051	4	3077
1102	4	3077
1132	4	3077
1390	4	3077
1486	4	3077
1549	4	3077
1706	4	3077
1826	4	3077
1878	4	3077
378	4	3077
2021	4	3077
2060	4	3077
2155	4	3077
2155	4	3077
2168	4	3077
2222	4	3077
2227	4	3077
2294	4	3077
2315	4	3077
2326	4	3077
2470	4	3077
2558	4	3077
2719	4	3077
2723	4	3077
2732	4	3077
2838	4	3077
2842	4	3077
2842	4	3077
2855	4	3077
2865	4	3077
2879	4	3077
2896	4	3077
2943	4	3077
2981	4	3077
3014	4	3077
3030	4	3077
3068	4	3077
3077	4	3077
3077	4	3077
3077	4	3077
3077	4	3077
3080	4	3077
3104	4	3077
3106	4	3077
3143	4	3077
3150	4	3077
627	4	3077
106	4	3077
210	5	3077
1834	5	3077
2060	5	3077
2457	5	3077
3077	5	3077
3077	5	3077
3077	5	3077


************************



Can Programming Be Liberated from the von Neumann
Style?  A Functional Style and Its Algebra 
of Programs

Conventional programming languages are growing
ever more enormous, but not stronger.  Inherent 
defects at the most basic level cause them to be both
fat and weak: their primitive word-at-a-time style 
of programming inherited from their common ancestor-the
von Neumann computer, their close coupling off 
semantics to state transitions, their division of programming
into a world of expressions and a world 
of statements, their inability to effectively use powerful
combining forms for building new programs 
from existing ones, and their lack of useful mathematical
properties for reasoning about programs. An 
alternative <B>functional style</B> of programming is founded
on the use of combining forms for creating programs. 
 Functional programs deal with structured data, are often
nonrepetitive and nonrecursive, are hierarchically 
constructed, do not name their arguments, and do not require
the complex machinery of procedure declarations 
to become generally applicable.  Combining forms can
use high level programs to build still higher level
ones in a style not possible in conventional languages.
 Associated with the functional style of programming 
is an algebra of programs whose variables range over
programs and whose operations are combining forms. 
 This algebra can be used to transform programs and
to solve equations whose "unknowns" are programs 
in much the same way one transforms equations in high
school algebra.  These transformations are given 
by algebraic laws and are carried out in the same language
in which programs are written.  Combining 
forms are chosen not only for their programming power
but also for the power of their associated algebraic 
laws.  General theorems of of the algebra give the detailed
behavior and termination conditions for large 
classes of programs.  A new class of computing systems
uses the functional programming style both in 
its programming language and in its state transition
rules.  Unlike von Neumann languages, these systems 
have semantics loosely coupled to states-only one
state transition occurs per major computation. 

CACM August, 1978

Backus, J.

Functional programming, algebra of programs, combining
forms, functional forms, programming languages, 
von Neumann computers, von Neumann languages, models of
computing systems, applicative computing systems, 
applicative state transition systems, program transformation,
program correctness, program termination, 
metacomposition

4.20 4.29 5.20 5.24 5.26

CA780801 DH February 7, 1979  3:13 PM

1024	4	3077
1051	4	3077
1102	4	3077
1132	4	3077
1390	4	3077
1486	4	3077
1549	4	3077
1706	4	3077
1826	4	3077
1878	4	3077
378	4	3077
2021	4	3077
2060	4	3077
2155	4	3077
2155	4	3077
2168	4	3077
2222	4	3077
2227	4	3077
2294	4	3077
2315	4	3077
2326	4	3077
2470	4	3077
2558	4	3077
2719	4	3077
2723	4	3077
2732	4	3077
2838	4	3077
2842	4	3077
2842	4	3077
2855	4	3077
2865	4	3077
2879	4	3077
2896	4	3077
2943	4	3077
2981	4	3077
3014	4	3077
3030	4	3077
3068	4	3077
3077	4	3077
3077	4	3077
3077	4	3077
3077	4	3077
3080	4	3077
3104	4	3077
3106	4	3077
3143	4	3077
3150	4	3077
627	4	3077
106	4	3077
210	5	3077
1834	5	3077
2060	5	3077
2457	5	3077
3077	5	3077
3077	5	3077
3077	5	3077


************************

************************
Document:  CACM-2876.html
************************


Intentional Resolution of Privacy Protection in Database Systems

Traditionally, privacy protection in database
systems is understood to be the control over 
what information a given user can get from a database.
 This paper is concerned with another, independent, 
dimension of privacy protection, the control over what
a user is allowed to do with a piece of information 
supplied to him by the database.  The ability to condition
the supply of information on its intended 
use is called here "intentional resolution" of privacy
protection.  The practical importance of intentional 
resolution is demonstrated by several examples, and its realization
is discussed.  It is shown that intentional 
resolution can be achieved, but that it involves a radical
change <B>from the</B> traditional approach to the 
process of user-database interaction.  In particular,
it appears to be necessary for the database to 
impose a certain amount of control over the internal
behavior of users' programs which interact with 
it.  A model for user-database interaction
which admits such a control is developed.

CACM March, 1976

Minsky, N.

protection in database, protection in programming
languages, privacy, security, intentional resolution 
of privacy, interaction with databases

3.50 3.70 4.20 4.30

CA760304 JB January 4, 1978  4:44 PM

2785	4	2876
2868	4	2876
2870	4	2876
2876	4	2876
2876	4	2876
3105	4	2876
3144	4	2876
2632	5	2876
2685	5	2876
2876	5	2876
2876	5	2876
2876	5	2876


************************



Intentional Resolution of Privacy Protection in Database Systems

Traditionally, privacy protection in database
systems is understood to be the control over 
what information a given user can get from a database.
 This paper is concerned with another, independent, 
dimension of privacy protection, the control over what
a user is allowed to do with a piece of information 
supplied to him by the database.  The ability to condition
the supply of information on its intended 
use is called here "intentional resolution" of privacy
protection.  The practical importance of intentional 
resolution is demonstrated by several examples, <B>and its</B> realization
is discussed.  It is shown that intentional 
resolution can be achieved, but that it involves a radical
change from the traditional approach to the 
process of user-database interaction.  In particular,
it appears to be necessary for the database to 
impose a certain amount of control over the internal
behavior of users' programs which interact with 
it.  A model for user-database interaction
which admits such a control is developed.

CACM March, 1976

Minsky, N.

protection in database, protection in programming
languages, privacy, security, intentional resolution 
of privacy, interaction with databases

3.50 3.70 4.20 4.30

CA760304 JB January 4, 1978  4:44 PM

2785	4	2876
2868	4	2876
2870	4	2876
2876	4	2876
2876	4	2876
3105	4	2876
3144	4	2876
2632	5	2876
2685	5	2876
2876	5	2876
2876	5	2876
2876	5	2876


************************

************************
Document:  CACM-1693.html
************************


GPL, a Truly General Purpose Language

A truly general purpose programming language,
GPL, is described which contains facilities for 
constructing (within the language) new data types as
well as facilities for operations performed upon 
them.  The basic language is minimal in the sense that
no basic element can be derived <B>from the</B> others 
with high efficiency in the object programs.  Constructs
like the ALGOL 60 for-statements,and if-statements 
are not basic; they are special types of procedures.
 New "symbols" (underlined words in ALGOL 60) are 
implicitly defined by usage in other declarations.  As
part words are definable, packed words are handled 
as easily as full words.  "Address" variables
(pointers) are included in full generality.

CACM September, 1968

Garwick, J. V.

programming language, general purpose, self-extending, macro, ALGOL

4.20

CA680908 JB February 22, 1978  8:40 AM

1379	4	1693
1380	4	1693
1542	4	1693
1552	4	1693
1683	4	1693
1693	4	1693
1693	4	1693
1693	4	1693
1693	4	1693
1781	4	1693
1781	4	1693
1781	4	1693
1781	4	1693
1787	4	1693
1824	4	1693
1836	4	1693
1836	4	1693
1854	4	1693
1860	4	1693
1861	4	1693
1945	4	1693
1945	4	1693
2015	4	1693
2060	4	1693
2060	4	1693
2060	4	1693
2061	4	1693
2061	4	1693
2082	4	1693
2091	4	1693
2091	4	1693
2126	4	1693
2152	4	1693
2179	4	1693
2179	4	1693
2340	4	1693
2356	4	1693
2546	4	1693
2546	4	1693
2603	4	1693
2698	4	1693
2698	4	1693
2708	4	1693
2708	4	1693
2824	4	1693
2982	4	1693
2986	4	1693
557	4	1693
3045	4	1693
3045	4	1693
3093	4	1693
1421	5	1693
1477	5	1693
1491	5	1693
1614	5	1693
1693	5	1693
1693	5	1693
1693	5	1693
2126	5	1693
2317	5	1693
823	6	1693
196	6	1693
1198	6	1693
1572	6	1693
1614	6	1693
1693	6	1693
1693	6	1693
1749	6	1693
1753	6	1693
1781	6	1693
2126	6	1693
2148	6	1693
404	6	1693


************************

************************
Document:  CACM-2060.html
************************


GEDANKEN-A Simple Typeless Language Based on the
Principle of Completeness and the Reference Concept

GEDANKEN is an experimental programming language with the following 
characteristics.  (1) Any value which is permitted in some context of the 
language is permissible in any other meaningful context.  In particular,
functions and labels are permissible  results of functions and values
of variables.  (2) Assignment and indirect addressing are formalized
by introducing values, called reference, which in turn possess
other values.  The assignment operation always affects the relation
between some reference <B>and its</B> value,  (3) All compound data
structures are treated as functions.  (4) Type declarations are
not permitted.  The functional approach to data structures and the
use of references insure that any process which accepts some data
structure will accept any logically equivalent structure, regardless
of its internal representation.  More generally, any data structure
may be implicit; i.e. it may be specified by giving an arbitrary
algorithm for computing or accessing its components.  The existence of 
label variables permits the construction of coroutines,
quasi-parallel processes, and other unorthodox control mechanisms.
A variety of programming examples illustrates the generality of the language.
Limitations and possible extensions are discussed briefly.

CACM May, 1970

Reynolds, J. C.

programming language, data structure, reference, assignment, coroutine,
quasi-parallel process, typeless language, applicative language,
lambda calculus, list processing, nondeterministic algorithm

4.20 4.22 5.23 5.24

CA700506 JB February 13, 1978  1:43 PM

1024	4	2060
1051	4	2060
1102	4	2060
1132	4	2060
1379	4	2060
1380	4	2060
1390	4	2060
1486	4	2060
1541	4	2060
1542	4	2060
1549	4	2060
1552	4	2060
1683	4	2060
1693	4	2060
1693	4	2060
1693	4	2060
1706	4	2060
1781	4	2060
1781	4	2060
1781	4	2060
1787	4	2060
1826	4	2060
1836	4	2060
1836	4	2060
1846	4	2060
1854	4	2060
1860	4	2060
1878	4	2060
1945	4	2060
1945	4	2060
1989	4	2060
378	4	2060
2015	4	2060
2060	4	2060
2060	4	2060
2060	4	2060
2060	4	2060
2060	4	2060
2060	4	2060
2060	4	2060
2060	4	2060
2061	4	2060
2061	4	2060
2082	4	2060
2091	4	2060
2091	4	2060
2155	4	2060
2152	4	2060
2168	4	2060
2179	4	2060
2179	4	2060
2179	4	2060
2218	4	2060
2294	4	2060
2340	4	2060
2356	4	2060
2470	4	2060
2546	4	2060
2546	4	2060
2603	4	2060
2698	4	2060
2698	4	2060
2698	4	2060
2708	4	2060
2708	4	2060
2719	4	2060
2723	4	2060
2770	4	2060
2824	4	2060
2838	4	2060
2842	4	2060
2855	4	2060
2879	4	2060
2921	4	2060
2982	4	2060
2986	4	2060
557	4	2060
3045	4	2060
3045	4	2060
3077	4	2060
3080	4	2060
3093	4	2060
3106	4	2060
3112	4	2060
3124	4	2060
3154	4	2060
627	4	2060
106	4	2060
210	5	2060
1380	5	2060
1421	5	2060
1469	5	2060
1477	5	2060
1491	5	2060
1869	5	2060
2060	5	2060
2060	5	2060
2060	5	2060
2110	5	2060
2155	5	2060
2294	5	2060
2558	5	2060
2842	5	2060
3077	5	2060
3150	5	2060
1389	6	2060
1469	6	2060
1471	6	2060
210	6	2060
210	6	2060
210	6	2060
1834	6	2060
378	6	2060
2046	6	2060
2060	6	2060
2060	6	2060
2060	6	2060
2060	6	2060
2060	6	2060
2060	6	2060
2148	6	2060
2192	6	2060
2457	6	2060
2704	6	2060
2842	6	2060
2939	6	2060
2940	6	2060
2941	6	2060
2943	6	2060
3073	6	2060
3148	6	2060
3184	6	2060


************************

************************
Document:  CACM-1477.html
************************


EULER: A Generalization of ALGOL, <B>and its</B> Formal Definition: Part II*

CACM February, 1966

Wirth, N.
Weber, H.

CA660207 JB March 3, 1978  3:10 PM

1379	5	1477
1477	5	1477
1477	5	1477
1477	5	1477
1693	5	1477
1781	5	1477
1836	5	1477
1945	5	1477
2015	5	1477
2060	5	1477
2061	5	1477
2091	5	1477
2179	5	1477
2546	5	1477
2698	5	1477
2708	5	1477
3045	5	1477
823	6	1477
123	6	1477
196	6	1477
914	6	1477
915	6	1477
917	6	1477
919	6	1477
984	6	1477
989	6	1477
990	6	1477
990	6	1477
1007	6	1477
1012	6	1477
1046	6	1477
1084	6	1477
1098	6	1477
1122	6	1477
1131	6	1477
1138	6	1477
1139	6	1477
1139	6	1477
1140	6	1477
1140	6	1477
1141	6	1477
1141	6	1477
1149	6	1477
1191	6	1477
1198	6	1477
1200	6	1477
1215	6	1477
1223	6	1477
1223	6	1477
1263	6	1477
1265	6	1477
1265	6	1477
1303	6	1477
1323	6	1477
1336	6	1477
1358	6	1477
1366	6	1477
1366	6	1477
1380	6	1477
1396	6	1477
1421	6	1477
1421	6	1477
1421	6	1477
1455	6	1477
1460	6	1477
1462	6	1477
1463	6	1477
1467	6	1477
1468	6	1477
1469	6	1477
1477	6	1477
1477	6	1477
1477	6	1477
1477	6	1477
1477	6	1477
1477	6	1477
1477	6	1477
1477	6	1477
1477	6	1477
1477	6	1477
1477	6	1477
1477	6	1477
1477	6	1477
1477	6	1477
1487	6	1477
1491	6	1477
1491	6	1477
1491	6	1477
1491	6	1477
1491	6	1477
1491	6	1477
1491	6	1477
1491	6	1477
1491	6	1477
1491	6	1477
1491	6	1477
1491	6	1477
1496	6	1477
1496	6	1477
1531	6	1477
1535	6	1477
1565	6	1477
1601	6	1477
1602	6	1477
1613	6	1477
1614	6	1477
1614	6	1477
1626	6	1477
1641	6	1477
1781	6	1477
1781	6	1477
1781	6	1477
1787	6	1477
1787	6	1477
1788	6	1477
205	6	1477
1825	6	1477
1825	6	1477
210	6	1477
224	6	1477
249	6	1477
1869	6	1477
288	6	1477
316	6	1477
381	6	1477
398	6	1477
2015	6	1477
2110	6	1477
2110	6	1477
2110	6	1477
2111	6	1477
11	6	1477
2126	6	1477
2534	6	1477
2534	6	1477
2556	6	1477
2556	6	1477
404	6	1477
404	6	1477
410	6	1477
463	6	1477
464	6	1477
483	6	1477
483	6	1477
3184	6	1477
3184	6	1477
3184	6	1477
3184	6	1477
3188	6	1477
577	6	1477
584	6	1477
584	6	1477
600	6	1477
669	6	1477
669	6	1477
680	6	1477
680	6	1477
680	6	1477
680	6	1477
691	6	1477
761	6	1477
763	6	1477
763	6	1477
773	6	1477
799	6	1477
799	6	1477


************************

************************
Document:  CACM-0196.html
************************


Report on the Algorithmic Language ALGOL 60

Naur, P.
<B>Backus, J.</B>

CACM May, 1960

CA600501 JB March 22, 1978  1:34 PM

123	5	196
140	5	196
196	5	196
196	5	196
196	5	196
919	5	196
989	5	196
1102	5	196
1109	5	196
1140	5	196
1188	5	196
1306	5	196
249	5	196
254	5	196
272	5	196
1464	5	196
1491	5	196
1767	5	196
1781	5	196
1787	5	196
1949	5	196
321	5	196
2059	5	196
2126	5	196
2732	5	196
435	5	196
437	5	196
463	5	196
483	5	196
491	5	196
560	5	196
583	5	196
3073	5	196
627	5	196
631	5	196
632	5	196
642	5	196
644	5	196
653	5	196
680	5	196
761	5	196
762	5	196
763	5	196
1	6	196
1	6	196
823	6	196
106	6	196
123	6	196
152	6	196
165	6	196
168	6	196
185	6	196
196	6	196
196	6	196
196	6	196
196	6	196
196	6	196
196	6	196
196	6	196
196	6	196
196	6	196
196	6	196
196	6	196
196	6	196
196	6	196
196	6	196
196	6	196
196	6	196
196	6	196
196	6	196
196	6	196
196	6	196
196	6	196
196	6	196
196	6	196
196	6	196
196	6	196
196	6	196
196	6	196
196	6	196
196	6	196
196	6	196
196	6	196
196	6	196
196	6	196
196	6	196
196	6	196
196	6	196
196	6	196
196	6	196
196	6	196
196	6	196
919	6	196
946	6	196
947	6	196
990	6	196
1007	6	196
1046	6	196
1131	6	196
1139	6	196
1140	6	196
1140	6	196
1141	6	196
1149	6	196
1198	6	196
1215	6	196
1215	6	196
1223	6	196
1265	6	196
1303	6	196
1303	6	196
1323	6	196
1358	6	196
1366	6	196
1421	6	196
1460	6	196
1462	6	196
1463	6	196
1467	6	196
1467	6	196
1468	6	196
1468	6	196
1477	6	196
1491	6	196
1491	6	196
1496	6	196
1496	6	196
1496	6	196
1531	6	196
1535	6	196
1565	6	196
1601	6	196
1602	6	196
1613	6	196
1614	6	196
1614	6	196
1626	6	196
1641	6	196
1693	6	196
1781	6	196
1787	6	196
1788	6	196
205	6	196
206	6	196
207	6	196
209	6	196
210	6	196
210	6	196
1834	6	196
224	6	196
224	6	196
224	6	196
249	6	196
249	6	196
271	6	196
288	6	196
288	6	196
303	6	196
316	6	196
321	6	196
381	6	196
387	6	196
398	6	196
11	6	196
46	6	196
51	6	196
2732	6	196
400	6	196
401	6	196
402	6	196
404	6	196
404	6	196
404	6	196
404	6	196
404	6	196
404	6	196
404	6	196
406	6	196
410	6	196
412	6	196
463	6	196
463	6	196
464	6	196
483	6	196
483	6	196
483	6	196
3184	6	196
3184	6	196
3184	6	196
3184	6	196
3184	6	196
3188	6	196
584	6	196
600	6	196
615	6	196
631	6	196
642	6	196
680	6	196
691	6	196
729	6	196
763	6	196
763	6	196
799	6	196
799	6	196
799	6	196


************************

************************
Document:  CACM-3112.html
************************


List Processing in Real Time on a Serial Computer

A real-time list processing system is one
in which the time required by the elementary list 
operations (e.g. CONS, CAR, CDR, RPLACA, REPLACD, EQ,
and ATOM in LISP) is bounded by a (small) constant. 
 Classical implementations of list processing systems
lack this property because allocating a list cell 
<B>from the</B> heap may cause a garbage collection, which process
requires time proportional to the heap size 
to finish.  A real-time list processing system is presented
which continuously reclaims garbage, including 
directed cycles, while linearizing and compacting the
accessible cells into contiguous locations to avoid 
fragmenting the free storage pool.  The program is small
and requires no time-sharing interrupts, making 
it suitable for microcode.  Finally, the system requires
the same average time, and not more than twice 
the space, of a classical implementation, and those
space requirements can be reduced to approximately 
classical proportions by compact list representation.
 Arrays of different sizes, a program stack, and 
hash linking are simple extensions to our system, and
reference counting is found to be inferior for 
many applications.

CACM April, 1978

Baker, H.

Real-time, compacting,garbage collection, list processing,
virtual memory, file or database management, 
storage management, storage allocation, LISP, CDR-coding, reference counting.  

3.50 3.60 3.73 3.80 4.13 4.22 4.32 4.33 4.35 4.49

CA780404 DH February 26,1979  4:32 PM

1024	4	3112
1050	4	3112
1051	4	3112
1098	4	3112
1214	4	3112
1380	4	3112
1388	4	3112
1393	4	3112
1393	4	3112
1485	4	3112
1487	4	3112
1541	4	3112
1549	4	3112
1549	4	3112
1570	4	3112
1846	4	3112
1878	4	3112
1946	4	3112
1957	4	3112
1972	4	3112
2023	4	3112
2060	4	3112
2156	4	3112
2156	4	3112
2168	4	3112
2168	4	3112
2218	4	3112
2361	4	3112
2438	4	3112
2513	4	3112
2625	4	3112
2723	4	3112
2723	4	3112
2736	4	3112
2736	4	3112
2833	4	3112
2833	4	3112
2838	4	3112
2845	4	3112
2855	4	3112
2855	4	3112
2855	4	3112
2857	4	3112
2896	4	3112
2922	4	3112
2944	4	3112
3039	4	3112
3074	4	3112
3074	4	3112
3074	4	3112
3081	4	3112
3101	4	3112
3106	4	3112
3112	4	3112
3112	4	3112
3112	4	3112
3112	4	3112
3112	4	3112
3112	4	3112
3112	4	3112
3112	4	3112
3112	4	3112
3112	4	3112
627	4	3112
106	5	3112
1380	5	3112
1826	5	3112
1972	5	3112
2438	5	3112
2723	5	3112
2736	5	3112
2833	5	3112
2838	5	3112
3112	5	3112
3112	5	3112
3112	5	3112
731	5	3112


************************

************************
Document:  CACM-3017.html
************************


B-trees Re-examined

The B-tree <B>and its</B> variants have, with increasing
frequency, been proposed as a basic storage 
structure for multiuser database applications.  Here,
three potential problems which must be dealt with 
in such a structure that do not arise in more traditional
static directory structures are indicated. 
 One problem is a possible performance penalty.

CACM February, 1978

Held, G.
Stonebraker, M.

B-tree, directory, static directory, dynamic
directory, index sequential access method

3.70 3.73 3.74 4.33 4.34

CA780206 JB March 28, 1978  3:46 PM

2626	4	3017
2786	4	3017
2840	4	3017
2919	4	3017
3017	4	3017
3110	4	3017
3174	4	3017
2629	5	3017
3017	5	3017
3017	5	3017
3017	5	3017


************************

************************
Document:  CACM-2126.html
************************


Experience with an Extensible Language

An operational extensible language system is described.
The system <B>and its</B> base language are appraised with 
respect to efficiency, flexibility, and utility
for different categories of users.

CACM January, 1970

Irons, E. T.

programming languages, extensible, compiler, bootstrapping, ambiguity

4.12 4.22

CA700105 JB February 14, 1978  2:02 PM

249	4	2126
254	4	2126
272	4	2126
1046	4	2126
1102	4	2126
1105	4	2126
1109	4	2126
1139	4	2126
1140	4	2126
1140	4	2126
1188	4	2126
1234	4	2126
1263	4	2126
1265	4	2126
1306	4	2126
1464	4	2126
1491	4	2126
1496	4	2126
1693	4	2126
1767	4	2126
1781	4	2126
1781	4	2126
1781	4	2126
1787	4	2126
1824	4	2126
1824	4	2126
1861	4	2126
1945	4	2126
1949	4	2126
321	4	2126
2059	4	2126
2126	4	2126
2126	4	2126
2126	4	2126
2126	4	2126
2126	4	2126
2317	4	2126
2546	4	2126
435	4	2126
437	4	2126
463	4	2126
464	4	2126
483	4	2126
491	4	2126
2732	4	2126
560	4	2126
583	4	2126
584	4	2126
3073	4	2126
627	4	2126
631	4	2126
631	4	2126
632	4	2126
642	4	2126
644	4	2126
653	4	2126
653	4	2126
680	4	2126
680	4	2126
691	4	2126
761	4	2126
762	4	2126
763	4	2126
763	4	2126
795	4	2126
799	4	2126
123	4	2126
140	4	2126
919	4	2126
945	4	2126
989	4	2126
196	5	2126
1614	5	2126
1693	5	2126
2126	5	2126
2126	5	2126
2126	5	2126
2317	5	2126
2546	5	2126
404	5	2126
823	5	2126
1198	6	2126
1477	6	2126
1491	6	2126
1572	6	2126
1693	6	2126
1749	6	2126
1753	6	2126
1781	6	2126
2126	6	2126
2126	6	2126
2148	6	2126
404	6	2126
3184	6	2126


************************

************************
Document:  CACM-0796.html
************************


SABRAG, A Time-Sharing Low-Cost Computer

The serial SABRAC computer designed and built
in the Scientific Department of the Israel defense 
Ministry has a 5000-location magnetic drum, main store.
 To avoid a need to resort to optimum programming 
techniques and to increase its overall efficiency the
computer has also been given a 224-word ferrite 
core store from which the program is obeyed.  Transfers
between the core and drum stores and to and from 
the twin paper-tape input and output channels are all
available autonomously (concurrently, time-shared). 
 Multiplication and division orders are also autonomous,
so that the machine may be executing up to three 
orders simultaneously.  All functions naturally are interlocked.
 A number of other advanced orders and 
facilities are also incorporatedn particular, an
"Execute" order permits a temporary jump for up 
to four orders and a second modifier register permits double
modification in general and relative addressing 
of subroutines in particular.  Thus the overall effective
speed of the machine is muchhigher than its 
basic specification would lead one to expect <B>and its</B>
design indicates one way in which the concepts of 
time sharing may be incorporated in "low-cost" computers.

CACM August, 1963

Lehman, M.
Netter, Z.
Eshed, R.

CA630802 JB March 13, 1978  8:54 PM

3193	4	796
796	4	796
491	5	796
796	5	796
796	5	796
796	5	796


************************

************************
Document:  CACM-2189.html
************************


Generation of Rosary Permutations Expressed in Hamiltonian Circuits

Systematic generation of a specific class
of permutations fundamental to scheduling problems 
is described.  In a nonoriented complete graph with
n vertices, Hamitonian circuits equivalent to .5(n 
- 1)! specific permutations of n elements, termed rosary
permutations, can be defined.  Each of them 
corresponds to two circular permutations which mirror-image
each other, and is generated successively 
by a number system covering 3*4*...*(n-1) sets of edges.
 Every set of edges {E[k]}, 1 <= E[k] <= k, 
3 <= k <= (n-1) is determined recursively by constructing
a Hamiltonian circuit with k vertices from 
a Hamiltonian circuit with k-1 vertices, starting with
the Hamiltonian circuit of 3 vertices.  The basic 
operation consists of transposition of a pair of adjacent
vertices where the position of the pair in 
the permutation is determined by {E[k]}.  Two algorithms
treating the same example for five vertices 
are presented.  It is very easy to derive all possible n!
permutations  <B>from the</B> .5(n - 1 )! rosary permutations 
be cycling the permutations and by taking them in the
reverse order-procedures which can be performed 
fairly efficiently by computer. 

CACM June, 1971

Harada, K.

permutation, graph theory, scheduling, combinatorial algebra

5.32 5.39

CA710601 JB February 3, 1978  1:55 PM

2044	4	2189
2087	4	2189
2189	4	2189
2189	4	2189
2189	4	2189
2189	4	2189
2417	4	2189
2505	4	2189
2874	4	2189
2908	4	2189
3188	4	2189
1594	5	2189
2087	5	2189
2189	5	2189
2189	5	2189
2189	5	2189
2292	5	2189
2505	5	2189
521	5	2189
3191	5	2189
2189	6	2189
2189	6	2189
2292	6	2189
521	6	2189


************************

************************
Document:  CACM-3150.html
************************


Beyond Programming Languages

As computer technology matures, our growing ability to create large systems is 
leading to basic changes in the nature of programming.  Current programming 
language concepts will not be adequate for building and maintaining
systems of the complexity called for by the tasks we attempt.  Just
as high level languages enabled the programmer to escape <B>from the</B>
intricacies of a machine's order code, higher level programming systems
can provide the means to understand and manipulate complex
systems and components.  In order to develop such systems, we need
to shift our attention away from the detailed specification of
algorithms, towards the description of the properties of the packages
and objects with which we build.  This paper analyzes some of the
shortcomings of programming languages as they now exist,
and lays out some possible directions for future research.

CACM July, 1979

Winograd, T.

Programming, programming languages, programming systems, systems development

4.0 4.20 4.22 4.40

CA790701 DH August 22, 1979  2:00 PM

2155	4	3150
2294	4	3150
2558	4	3150
2837	4	3150
2842	4	3150
2945	4	3150
3031	4	3150
3077	4	3150
3105	4	3150
3148	4	3150
3148	4	3150
3150	4	3150
3150	4	3150
3150	4	3150
3150	4	3150
3150	4	3150
3150	4	3150
3150	4	3150
3150	4	3150
3150	4	3150
3155	4	3150
2060	5	3150
2704	5	3150
2842	5	3150
2939	5	3150
2941	5	3150
2943	5	3150
2940	5	3150
3073	5	3150
3148	5	3150
3150	5	3150
3150	5	3150
3150	5	3150


************************

************************
Document:  CACM-2113.html
************************


The Multistore Parser for Hierarchical Syntactic Structures

A syntactic parser is described for hierarchical concatenation patterns
that are presented to the analyzer in the form of linear strings.  Particular
emphasis is given to the system of "significant addresses" by means
of which processing times for large-scale matching procedures
can be substantially reduced.  The description makes frequent use
of examples taken <B>from the</B> fully operational implementation of the
parser in an experimental English sentence analyzer.  By structuring
an area of the computer's central core storage in such a way
that the individual locations of bytes and bits come to represent the
data involved in the matching procedure, the shifting of information
is reduced to a minimum, and the searching of lists is eliminated
altogether.  The matches are traced by means of binary masks
and the state of single bits determines the operational flow of the
procedure.  The method could be implemented with any interpretive
grammar, provided it can be expressed by the functional classification
of the items composing the input hierarchical structures.

CACM February, 1970

von Glasersfeld, E.

parsing, syntactic analysis, natural-language analysis, linguistic data
processing, computational linguistics, correlational grammar, structure
recognition, pattern recognition, matching procedures, tree-structure 
interpretation, machine translation, automatic abstracting

3.42 3.49 3.63 3.70 3.71

CA700202 JB February 14, 1978  12:57 PM 

2113	5	2113
2113	5	2113
2113	5	2113


************************

************************
Document:  CACM-1771.html
************************


CURRICULUM 68 -- Recommendations for Academic
Programs in Computer Science -- A Report of the 
ACM Curriculum Committee on Computer science

This report contains recommendations on academic
programs in computer science which were developed 
by the ACM Curriculum Committee on Computer Science.
 A classification of the subject areas contained 
in computer science is presented and twenty-two courses
in these areas are described.  Prerequisites, 
catalog descriptions, detailed outlines, and annotated
bibliographies for these courses are included. 
 Specific recommendations which have evolved <B>from the</B>
Committee's 1965 Preliminary Recommendations are 
given for undergraduate programs.  Graduate programs in computer
science are discussed and some recommendations 
are presented for the development of master's degree programs.
 Ways of developing guidelines for doctoral 
programs are discussed, but no specific recommendations
are made. The importance of service courses, 
minors, and continuing education in computer science is
emphasized.  Attention is given to the organization, 
staff requirements, computer resources, and other facilities
needed to implement computer science educational 
programs.

CACM March, 1968

computer science courses, computer science curriculum,
computer science education, computer science 
academic programs, computer science graduate programs,
computer science undergraduate programs, computer 
science course bibliographies

1.52

CA680301 JB February 23, 1978  11:52 AM

1413	4	1771
1654	4	1771
1720	4	1771
1771	4	1771
1771	4	1771
2478	4	1771
1205	5	1771
1654	5	1771
1720	5	1771
1771	5	1771
1771	5	1771
1771	5	1771
1927	5	1771
2147	5	1771
2163	5	1771
2345	5	1771
2478	5	1771
2594	5	1771
2852	5	1771
2899	5	1771
3130	5	1771
1205	6	1771
1417	6	1771
1654	6	1771
1659	6	1771
1720	6	1771
1771	6	1771
1771	6	1771
1771	6	1771
1771	6	1771
1771	6	1771
1771	6	1771
1771	6	1771
1771	6	1771
1771	6	1771
1771	6	1771
1927	6	1771
2155	6	1771
2181	6	1771
2181	6	1771
2204	6	1771
2329	6	1771
2345	6	1771
2387	6	1771
2479	6	1771
2538	6	1771
3003	6	1771
3186	6	1771


************************

************************
Document:  CACM-1350.html
************************


The Augmented Predictive Analyzer for Context-Free
Languages-Its Relative Efficiency

It has been proven by Greibach that for a given
context-free grammar G, a standard-form grammar 
Gs can be constructed, which generates the same languages
as is generated by G and whose rules are all 
of the form Z --> cY(1) ... Y(m), (m >= O) where Z and
Y(i) are intermediate symbols and c a terminal 
symbol.  Since the predictive analyzer at Harvard uses
a standard-form grammar, it can accept the language 
of any context-free Grammar G, given an equivalent standard-form
grammar Gs.  The structural descriptions 
SD(Gs,X) assigned to a given sentence X by the predictive
analyzer, however, are usually different from 
the structural descriptions SD(G,X) assigned to the
same sentence by the original context-free grammar 
G from which Gs is derived.  In Section 1, an algorithm,
originally due to Abbott is described standard-form 
grammar each of whose rules is in standard form, supplemented
by additional information describing its 
derivation <B>from the</B> original context-free grammar. 
A technique for performing the SD(Gs,X) to SD(G,X) 
transformation effectively is also described.  In section
2, the augmented predictive analyzer as a parsing 
algorithm for arbitrary context-free languages is compared
with two other parsing algorithms: a selective 
top-to-bottom algorithm similar to Irons' "error correcting
parse algorithm" and an immediate constituent 
analyzer which is an extension of Sakai-Cocke's algorithm
for normal grammars.  The comparison is based 
upon several criteria of efficiency, covering core-storage
requirements, complexities of the programs 
and processing time.

CACM November, 1966

Kuno,S.

CA661108 JB March 2, 1978  3:11 PM

1225	4	1350
1225	4	1350
1350	4	1350
1350	4	1350
1350	4	1350
1350	4	1350
1350	4	1350
1399	4	1350
1646	4	1350
1659	4	1350
1659	4	1350
1768	4	1350
1781	4	1350
1781	4	1350
1856	4	1350
1945	4	1350
1945	4	1350
1945	4	1350
2050	4	1350
2110	4	1350
2650	4	1350
2698	4	1350
2708	4	1350
3093	4	1350
3094	4	1350
1012	5	1350
1225	5	1350
1265	5	1350
1350	5	1350
1350	5	1350
1350	5	1350
1399	5	1350
1659	5	1350
680	5	1350
1225	6	1350
1265	6	1350
1350	6	1350
1671	6	1350
1697	6	1350


************************

************************
Document:  CACM-1491.html
************************


EULER: A Generalization ALGOL, <B>and its</B> Formal Definition: Part I*

A method for defining programming languages is
developed which introduces a rigorous relationship 
between structure and meaning.  The structure of a
language is defined by a phrase structure syntax, 
the meaning in terms of the effects which the execution
of a sequence of interpretation rules exerts 
upon a fixed set of variables, called the Environment.
 There exists a one-to-one correspondence between 
syntactic rules and interpretation rules is determined by
the sequence of corresponding syntactic reductions 
which constitute a parse.  The individual interpretation
rules are explained in terms of an elementary 
an d obvious algorithmic notation.  A constructive
method for evaluating a text is provided, and for 
certain decidable classes of languages their unambiguity
is proved.  As an example, a generalization 
of ALGOL is described in full detail to demonstrate that
concepts like block-structure, procedures, parameters, 
etc. can be defined adequately and precisely by this method.

CACM January, 1966

Wirth, N.
Weber, H.

CA660104 JB March 3, 1978  4:22 PM

249	4	1491
254	4	1491
272	4	1491
1037	4	1491
1086	4	1491
1102	4	1491
1109	4	1491
1132	4	1491
1140	4	1491
1188	4	1491
1234	4	1491
1234	4	1491
1263	4	1491
1265	4	1491
1270	4	1491
1306	4	1491
1323	4	1491
1358	4	1491
1358	4	1491
1379	4	1491
1380	4	1491
1453	4	1491
1464	4	1491
1464	4	1491
1469	4	1491
1484	4	1491
1486	4	1491
1491	4	1491
1491	4	1491
1491	4	1491
1491	4	1491
1491	4	1491
1498	4	1491
1613	4	1491
1614	4	1491
1767	4	1491
1781	4	1491
1781	4	1491
1781	4	1491
1781	4	1491
1787	4	1491
1825	4	1491
1860	4	1491
1949	4	1491
321	4	1491
2059	4	1491
2061	4	1491
2083	4	1491
2126	4	1491
2178	4	1491
2178	4	1491
2179	4	1491
2252	4	1491
2325	4	1491
2326	4	1491
2341	4	1491
2470	4	1491
2546	4	1491
435	4	1491
437	4	1491
463	4	1491
483	4	1491
491	4	1491
2645	4	1491
2652	4	1491
2684	4	1491
2684	4	1491
2732	4	1491
2842	4	1491
2929	4	1491
2934	4	1491
560	4	1491
583	4	1491
3044	4	1491
3069	4	1491
3073	4	1491
627	4	1491
631	4	1491
632	4	1491
642	4	1491
644	4	1491
653	4	1491
669	4	1491
679	4	1491
680	4	1491
691	4	1491
761	4	1491
761	4	1491
762	4	1491
763	4	1491
123	4	1491
140	4	1491
919	4	1491
949	4	1491
989	4	1491
989	4	1491
196	5	1491
1140	5	1491
1303	5	1491
1491	5	1491
1491	5	1491
1491	5	1491
1542	5	1491
1683	5	1491
1693	5	1491
1781	5	1491
1787	5	1491
1836	5	1491
1945	5	1491
2060	5	1491
2061	5	1491
2082	5	1491
2091	5	1491
2152	5	1491
2179	5	1491
2340	5	1491
2356	5	1491
2546	5	1491
2603	5	1491
2698	5	1491
2708	5	1491
2824	5	1491
2982	5	1491
2986	5	1491
3045	5	1491
3093	5	1491
3184	5	1491
729	5	1491
823	6	1491
123	6	1491
196	6	1491
196	6	1491
914	6	1491
915	6	1491
917	6	1491
919	6	1491
970	6	1491
984	6	1491
989	6	1491
990	6	1491
990	6	1491
1007	6	1491
1012	6	1491
1046	6	1491
1084	6	1491
1098	6	1491
1122	6	1491
1131	6	1491
1138	6	1491
1139	6	1491
1139	6	1491
1140	6	1491
1140	6	1491
1141	6	1491
1141	6	1491
1141	6	1491
1141	6	1491
1149	6	1491
1191	6	1491
1191	6	1491
1198	6	1491
1200	6	1491
1215	6	1491
1215	6	1491
1223	6	1491
1223	6	1491
1265	6	1491
1265	6	1491
1303	6	1491
1323	6	1491
1336	6	1491
1358	6	1491
1366	6	1491
1366	6	1491
1380	6	1491
1396	6	1491
1421	6	1491
1421	6	1491
1421	6	1491
1455	6	1491
1460	6	1491
1462	6	1491
1463	6	1491
1467	6	1491
1468	6	1491
1469	6	1491
1477	6	1491
1477	6	1491
1477	6	1491
1477	6	1491
1477	6	1491
1477	6	1491
1477	6	1491
1477	6	1491
1477	6	1491
1477	6	1491
1477	6	1491
1477	6	1491
1487	6	1491
1491	6	1491
1491	6	1491
1491	6	1491
1491	6	1491
1491	6	1491
1491	6	1491
1491	6	1491
1491	6	1491
1491	6	1491
1491	6	1491
1491	6	1491
1491	6	1491
1491	6	1491
1491	6	1491
1491	6	1491
1491	6	1491
1491	6	1491
1491	6	1491
1491	6	1491
1491	6	1491
1491	6	1491
1491	6	1491
1491	6	1491
1491	6	1491
1496	6	1491
1496	6	1491
1496	6	1491
1531	6	1491
1535	6	1491
1565	6	1491
1601	6	1491
1602	6	1491
1613	6	1491
1614	6	1491
1614	6	1491
1626	6	1491
1641	6	1491
1683	6	1491
1683	6	1491
1683	6	1491
1767	6	1491
1781	6	1491
1781	6	1491
1781	6	1491
1787	6	1491
1787	6	1491
1788	6	1491
205	6	1491
1825	6	1491
1825	6	1491
210	6	1491
1836	6	1491
1836	6	1491
1836	6	1491
224	6	1491
224	6	1491
249	6	1491
1869	6	1491
288	6	1491
316	6	1491
381	6	1491
398	6	1491
2015	6	1491
2110	6	1491
2110	6	1491
2110	6	1491
2111	6	1491
11	6	1491
2126	6	1491
2179	6	1491
2179	6	1491
2227	6	1491
2340	6	1491
2340	6	1491
2340	6	1491
2534	6	1491
2534	6	1491
2556	6	1491
2556	6	1491
2708	6	1491
404	6	1491
404	6	1491
410	6	1491
463	6	1491
464	6	1491
483	6	1491
483	6	1491
3184	6	1491
3184	6	1491
3184	6	1491
3188	6	1491
3198	6	1491
518	6	1491
577	6	1491
584	6	1491
584	6	1491
600	6	1491
669	6	1491
680	6	1491
680	6	1491
680	6	1491
680	6	1491
680	6	1491
691	6	1491
763	6	1491
763	6	1491
763	6	1491
763	6	1491
773	6	1491
799	6	1491
799	6	1491
799	6	1491


************************

************************
Document:  CACM-2802.html
************************


The New Math of Computer Programming

Structured programming has proved to be an important
methodology for systematic program design 
and development.  Structured programs are identified
as compound function expressions in the algebra 
of functions. The algebraic properties of these function
expressions permit the reformulation (expansion 
as well as reduction) of a nested subexpression independently
of its environment, thus modeling what 
is known as stepwise program refinement as well as program
execution.  Finally, structured programming 
is characterized in terms of the selection and solution
of certain elementary equations defined in the 
<B>algebra of</B> functions.  These solutions can be given in
general formulas, each involving a single parameter, 
which display the entire freedom available
in creating correct structured programs.

CACM January, 1975

Mills, H. D.

structured programming, algebra of functions,
stepwise refinement, program correctness

4.6 5.21 5.24

CA750109 JB January 12, 1978  9:50 AM

2709	4	2802
2802	4	2802
3004	4	2802
1425	5	2802
2802	5	2802
2802	5	2802
2802	5	2802


************************

