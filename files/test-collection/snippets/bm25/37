Snippets for the query:  What is the type of a module? (I don't want the entire literature on Abstract Data Types here, but I'm not sure how to phrase this to avoid it. I'm interested in questions about how one can check that a module "matches" contexts in which it is used.)
************************
Total Hits:  151
************************

************************
Document:  CACM-2958.html
************************


Abstract <B>Data Types</B> and the Development of Data Structures

Abstract data types can play a significant role
in the development of software that is reliable, 
efficient, and flexible.  This paper presents and discusses
the application of an algebraic technique 
for the specification of abstract data types.  Among
the examples presented is a top-down development 
of a symbol table for a block structured language; a discussion
of the proof of its correctness is given. 
 The paper also contains a brief discussion of the problems
involved in constructing algebraic specifications 
that are both consistent and complete.

CACM June, 1977

Guttag, J.

abstract data type, correctness proof, data type,
data structure, specification, software specification

4.34 5.24

CA770605 JB December 29, 1977  1:17 AM

2704	4	2958
2738	4	2958
2866	4	2958
2869	4	2958
2941	4	2958
2958	4	2958
3004	4	2958
3030	4	2958
2356	5	2958
2958	5	2958
2958	5	2958
2958	5	2958
3030	5	2958
3031	5	2958
3049	5	2958
2247	6	2958
2356	6	2958
2457	6	2958
2651	6	2958
2939	6	2958
2956	6	2958
2958	6	2958
2958	6	2958
2958	6	2958
2957	6	2958
2960	6	2958
2972	6	2958


************************



<B>Abstract Data</B> Types and the Development of Data Structures

Abstract data types can play a significant role
in the development of software that is reliable, 
efficient, and flexible.  This paper presents and discusses
the application of an algebraic technique 
for the specification of abstract data types.  Among
the examples presented is a top-down development 
of a symbol table for a block structured language; a discussion
of the proof of its correctness is given. 
 The paper also contains a brief discussion of the problems
involved in constructing algebraic specifications 
that are both consistent and complete.

CACM June, 1977

Guttag, J.

abstract data type, correctness proof, data type,
data structure, specification, software specification

4.34 5.24

CA770605 JB December 29, 1977  1:17 AM

2704	4	2958
2738	4	2958
2866	4	2958
2869	4	2958
2941	4	2958
2958	4	2958
3004	4	2958
3030	4	2958
2356	5	2958
2958	5	2958
2958	5	2958
2958	5	2958
3030	5	2958
3031	5	2958
3049	5	2958
2247	6	2958
2356	6	2958
2457	6	2958
2651	6	2958
2939	6	2958
2956	6	2958
2958	6	2958
2958	6	2958
2958	6	2958
2957	6	2958
2960	6	2958
2972	6	2958


************************



Abstract Data Types and the Development of Data Structures

Abstract data types can play a significant role
in the development of software that is reliable, 
efficient, and flexible.  This paper presents and discusses
the application of an algebraic technique 
for the specification of abstract data types.  Among
the examples presented is a top-down development 
of a symbol table for a block structured language; a discussion
of the proof of its correctness is given. 
 The paper also contains a brief discussion of the problems
involved in constructing algebraic specifications 
<B>that a</B>re both consistent and complete.

CACM June, 1977

Guttag, J.

abstract data type, correctness proof, data type,
data structure, specification, software specification

4.34 5.24

CA770605 JB December 29, 1977  1:17 AM

2704	4	2958
2738	4	2958
2866	4	2958
2869	4	2958
2941	4	2958
2958	4	2958
3004	4	2958
3030	4	2958
2356	5	2958
2958	5	2958
2958	5	2958
2958	5	2958
3030	5	2958
3031	5	2958
3049	5	2958
2247	6	2958
2356	6	2958
2457	6	2958
2651	6	2958
2939	6	2958
2956	6	2958
2958	6	2958
2958	6	2958
2958	6	2958
2957	6	2958
2960	6	2958
2972	6	2958


************************



Abstract Data Types and the Development of Data Structures

Abstract data types can play a significant role
in the development of software that is reliable, 
efficient, and flexible.  This paper presents and discusses
the application <B>of a</B>n algebraic technique 
for the specification of abstract data types.  Among
the examples presented is a top-down development 
of a symbol table for a block structured language; a discussion
of the proof of its correctness is given. 
 The paper also contains a brief discussion of the problems
involved in constructing algebraic specifications 
that are both consistent and complete.

CACM June, 1977

Guttag, J.

abstract data type, correctness proof, data type,
data structure, specification, software specification

4.34 5.24

CA770605 JB December 29, 1977  1:17 AM

2704	4	2958
2738	4	2958
2866	4	2958
2869	4	2958
2941	4	2958
2958	4	2958
3004	4	2958
3030	4	2958
2356	5	2958
2958	5	2958
2958	5	2958
2958	5	2958
3030	5	2958
3031	5	2958
3049	5	2958
2247	6	2958
2356	6	2958
2457	6	2958
2651	6	2958
2939	6	2958
2956	6	2958
2958	6	2958
2958	6	2958
2958	6	2958
2957	6	2958
2960	6	2958
2972	6	2958


************************

************************
Document:  CACM-1489.html
************************


Data, Documentation and Decision Tables

In business data processing systems, <B>it is</B>
necessary to be able to define and document data, 
files, programs and decision rules in a way that adequately
represents both (1) their changing information 
content, and (2) their continuous interaction.  Tabular
description makes this possible, being notably 
objective, through and economical in cost and time when
systems must be analyzed and programs prepared 
or modified.  To show how quickly tabular techniques
make an unfamiliar system manageable, a detailed 
example and a self-test are provided.

CACM January, 1966

Fisher, D. L.

CA660106 JB March 3, 1978  4:13 PM

1489	5	1489
1489	5	1489
1489	5	1489
1548	5	1489
2220	5	1489
2726	5	1489
1172	6	1489
1172	6	1489
1237	6	1489
1327	6	1489
1327	6	1489
1354	6	1489
1354	6	1489
1488	6	1489
1488	6	1489
1489	6	1489
1489	6	1489
1489	6	1489
1548	6	1489
1548	6	1489
250	6	1489
2220	6	1489
2221	6	1489
2263	6	1489


************************



Data, Documentation and Decision Tables

In business data processing systems, it is
necessary to be able to define and document data, 
files, programs and decision rules in a way <B>that a</B>dequately
represents both (1) their changing information 
content, and (2) their continuous interaction.  Tabular
description makes this possible, being notably 
objective, through and economical in cost and time when
systems must be analyzed and programs prepared 
or modified.  To show how quickly tabular techniques
make an unfamiliar system manageable, a detailed 
example and a self-test are provided.

CACM January, 1966

Fisher, D. L.

CA660106 JB March 3, 1978  4:13 PM

1489	5	1489
1489	5	1489
1489	5	1489
1548	5	1489
2220	5	1489
2726	5	1489
1172	6	1489
1172	6	1489
1237	6	1489
1327	6	1489
1327	6	1489
1354	6	1489
1354	6	1489
1488	6	1489
1488	6	1489
1489	6	1489
1489	6	1489
1489	6	1489
1548	6	1489
1548	6	1489
250	6	1489
2220	6	1489
2221	6	1489
2263	6	1489


************************

************************
Document:  CACM-2424.html
************************


Dynamic Verification of Operating System Decisions

Dynamic verification <B>of a</B> decision implies
that every time the decision is made there is a 
consistency check performed on the decision using independent
hardware and software.  The dynamic verification 
of operating system decisions is used on the PRIME system
being designed and constructed at the University 
of California, Berkeley.  PRIME is an experimental time-sharing
which is to have the properties of continuous 
availability, data privacy, and cost effectiveness.
 The technique of dynamic verification allows the 
construction of an operating system which does not make certain
decisions improperly even in the presence 
of a single hardware or software fault.  Furthermore,
multiple faults lead to unreliable operation only 
if the faults happen to reinforce each other.  On PRIME,
dynamic verification is used to ensure that 
one user's information cannot become available to another
user gratuitously even in the presence of a 
single hardware or software fault.the amount of additional
hardware and software required for dynamic 
verification can be modest.

CACM November, 1973

Fabry, R. S.

operating systems, data security, fault tolerance,
software reliability, data privacy, program 
verification, modular computer systems

4.32

CA731102 JB January 20, 1978  10:56 AM

1828	4	2424
1854	4	2424
1877	4	2424
1960	4	2424
2150	4	2424
2317	4	2424
2319	4	2424
2377	4	2424
2342	4	2424
2376	4	2424
2379	4	2424
2424	4	2424
2482	4	2424
2618	4	2424
2632	4	2424
2704	4	2424
2723	4	2424
2738	4	2424
2740	4	2424
2741	4	2424
2867	4	2424
3184	4	2424
1749	5	2424
2424	5	2424
2424	5	2424
2424	5	2424


************************

************************
Document:  CACM-2369.html
************************


Hidden Lines Elimination for a Rotating Object

A method is presented of determining which
parts of three-dimensional objects are visible and 
which are invisible when the objects are rotated about
some axis.  This paper describes a polygon comparison 
scheme <B>in which</B> the relationships of two polygons can
be classified into tree types, and also discusses 
how the relationship is changed for each pair of polygons
under rotation about some axis.  A rotation 
table is defined for each pair of polygons, which remains
fixed as long as rotation is about one axis 
and provides a means of rapidly determining the visible
and hidden line relationship between two polygons. 
 Additional work must be done to extend this approach
to simultaneous rotation about several axes.

CACM April, 1972

Matsushita, Y.

hidden line problem, display programming, computer
graphics, displays, graphics, computer drawn 
picture

4.40 4.41 4.49

CA720404 JB January 31, 1978  1:40 PM

2369	5	2369
2369	5	2369
2369	5	2369


************************

************************
Document:  CACM-3014.html
************************


Is "Sometime" Sometimes Better than "Always"? (Intermittent
Assertions in Proving Program Correctness)

This paper explores a technique for proving the
correctness and termination of programs simultaneously. 
 This approach, the intermittent-assertion method, involves
documenting the program with assertions that 
must be true at some time when control passes through
the corresponding point, but that need not be true 
every time.  The method, introduced by Burstall, promises
to provide a valuable complement to the more 
conventional methods.  The intermittent-assertion method
is presented with a number of examples of correctness 
and termination proofs.  Some of these proofs are markedly
simpler than their conventional counterparts. 
 On the other hand, it is shown <B>that a</B> proof of correctness
or termination by any of the conventional 
techniques can be rephrased directly as a proof using
intermittent assertions.  Finally, it is shown 
how the intermittent-assertion method can be applied
to prove the validity of program transformations 
and the correctness of continuously operating programs.

CACM February, 1978

Manna, Z.
Waldinger, R.

intermittent assertions, correctness of programs,
termination of programs, program verification, 
program transformation, continuously operating programs.

5.24

CA780209 JB March 28, 1978  2:04 PM

2021	4	3014
2222	4	3014
2227	4	3014
2315	4	3014
2326	4	3014
2470	4	3014
2732	4	3014
2865	4	3014
2896	4	3014
2943	4	3014
3014	4	3014
3014	4	3014
3068	4	3014
3077	4	3014
3143	4	3014
1834	5	3014
2981	5	3014
3014	5	3014
3014	5	3014
3014	5	3014
3157	5	3014
3014	6	3014


************************



Is "Sometime" Sometimes Better than "Always"? (Intermittent
Assertions in Proving Program Correctness)

This paper explores a technique for proving the
correctness and termination of programs simultaneously. 
 This approach, the intermittent-assertion method, involves
documenting the program with assertions that 
must be true at some time when control passes through
the corresponding point, but that need not be true 
every time.  The method, introduced by Burstall, promises
to provide a valuable complement to the more 
conventional methods.  The intermittent-assertion method
is presented with a number of examples of correctness 
and termination proofs.  Some of these proofs are markedly
simpler than their conventional counterparts. 
 On the other hand, <B>it is</B> shown that a proof of correctness
or termination by any of the conventional 
techniques can be rephrased directly as a proof using
intermittent assertions.  Finally, it is shown 
how the intermittent-assertion method can be applied
to prove the validity of program transformations 
and the correctness of continuously operating programs.

CACM February, 1978

Manna, Z.
Waldinger, R.

intermittent assertions, correctness of programs,
termination of programs, program verification, 
program transformation, continuously operating programs.

5.24

CA780209 JB March 28, 1978  2:04 PM

2021	4	3014
2222	4	3014
2227	4	3014
2315	4	3014
2326	4	3014
2470	4	3014
2732	4	3014
2865	4	3014
2896	4	3014
2943	4	3014
3014	4	3014
3014	4	3014
3068	4	3014
3077	4	3014
3143	4	3014
1834	5	3014
2981	5	3014
3014	5	3014
3014	5	3014
3014	5	3014
3157	5	3014
3014	6	3014


************************

************************
Document:  CACM-2622.html
************************


A User Authentication Scheme Not Requiring Secrecy in the Computer

In many computer operating systems a user authenticates
himself by entering a secret password 
known solely to himself and the system.  The system compares
this password with one recorded in a Password 
Table which is available to only the authentication
program.  The integrity of the system depends on 
keeping the table secret.  In this paper a password
scheme is presented which does not require secrecy 
in the computer.    All aspects of the system, including
all relevant code and data bases, may be known 
by anyone attempting to intrude.  The scheme is based
on using a function H which the would-be intruder 
is unable to invert.  This function is applied to the
user's password and the result compared to a table 
entry, a match being interpreted as authentication of
the user.  The intruder may know all about H and 
have access to the table, but he can penetrate the system
only if he can invert H to determine an input 
that produces a given output.  This paper discusses
issues surrounding selection of a suitable H.  Two 
different plausible arguments are given that penetration
would be exceedingly difficult, and it <B>is the</B>n 
argued that more rigorous results are unlikely.  Finally,
some human engineering problems relating to 
the scheme are discussed.

CACM August, 1974

Evans, A. Jr.
Kantrowitz, W.
Weiss, E.

operating system security, security, authentication,
passwords, one-way encryption, cryptology

4.39 5.39

CA740802 JB January 17, 1978  10:19 AM

2622	5	2622
2622	5	2622
2622	5	2622


************************



A User Authentication Scheme Not Requiring Secrecy in the Computer

In many computer operating systems a user authenticates
himself by entering a secret password 
known solely to himself and the system.  The system compares
this password with one recorded in a Password 
Table which is available to only the authentication
program.  The integrity of the system depends on 
keeping the table secret.  In this paper a password
scheme is presented which does not require secrecy 
in the computer.    All aspects of the system, including
all relevant code and data bases, may be known 
by anyone attempting to intrude.  The scheme is based
on using a function H which the would-be intruder 
is unable to invert.  This function is applied to the
user's password and the result compared to a table 
entry, a match being interpreted as authentication of
the user.  The intruder may know all about H and 
have access to the table, but he can penetrate the system
only if he can invert H to determine an input 
that produces a given output.  This paper discusses
issues surrounding selection <B>of a</B> suitable H.  Two 
different plausible arguments are given that penetration
would be exceedingly difficult, and it is then 
argued that more rigorous results are unlikely.  Finally,
some human engineering problems relating to 
the scheme are discussed.

CACM August, 1974

Evans, A. Jr.
Kantrowitz, W.
Weiss, E.

operating system security, security, authentication,
passwords, one-way encryption, cryptology

4.39 5.39

CA740802 JB January 17, 1978  10:19 AM

2622	5	2622
2622	5	2622
2622	5	2622


************************



A User Authentication Scheme Not Requiring Secrecy in the Computer

In many computer operating systems a user authenticates
himself by entering a secret password 
known solely to himself and the system.  The system compares
this password with one recorded in a Password 
Table which is available to only the authentication
program.  The integrity of the system depends on 
keeping the table secret.  In this paper a password
scheme is presented which does not require secrecy 
in the computer.    All aspects of the system, including
all relevant code and data bases, may be known 
by anyone attempting to intrude.  The scheme is based
on using a function H which the would-be intruder 
is unable to invert.  This function is applied to the
user's password and the result compared to a table 
entry, a match being interpreted as authentication of
the user.  The intruder may know all about H and 
have access to the table, but he can penetrate the system
only if he can invert H to determine an input 
that produces a given output.  This paper discusses
issues surrounding selection of a suitable H.  Two 
different plausible arguments are given that penetration
would be exceedingly difficult, and <B>it is</B> then 
argued that more rigorous results are unlikely.  Finally,
some human engineering problems relating to 
the scheme are discussed.

CACM August, 1974

Evans, A. Jr.
Kantrowitz, W.
Weiss, E.

operating system security, security, authentication,
passwords, one-way encryption, cryptology

4.39 5.39

CA740802 JB January 17, 1978  10:19 AM

2622	5	2622
2622	5	2622
2622	5	2622


************************

************************
Document:  CACM-3177.html
************************


How to Share a Secret

In this paper we show <B>how to</B> divide data D into
n pieces in such a way that D is easily reconstructable from any
k pieces, but even complete knowledge of k - 1 pieces reveals
olutely no information about D.  This technique enables the construction
of robust key management schemes for cryptographic systems
that can function securely and reliably even when misfortunes destroy
half the pieces and security breaches expose all but one of the
remaining pieces.

CACM November, 1979

Shamir, A.

Cryptography, key management, interpolation

5.39 5.6

CA791105 DB January 23, 1980  11:48 AM

3038	4	3177
3111	4	3177
3177	4	3177
3021	5	3177
3177	5	3177
3177	5	3177
3177	5	3177


************************

************************
Document:  CACM-2139.html
************************


Implementation of the Substring Test by Hashing

A technique is described for implementing the
test which determines if one string is a substring 
of another.  When there is low probability that the test
will be satisfied, <B>it is</B> shown how the operation 
can be speeded up considerably if it is preceded by
a test on appropriately chosen hash codes of the 
strings.

CACM December, 1971

Harrison, M. C.

substring, hashing, subset, signature, information
compression, information retrieval, searching

3.74 5.30 5.6

CA711204 JB February 2, 1978  10:14 AM

2139	5	2139
2139	5	2139
2139	5	2139
2532	5	2139
2631	5	2139
2746	5	2139
3001	5	2139
1665	6	2139
1739	6	2139
2033	6	2139
2139	6	2139
2139	6	2139
2139	6	2139
2139	6	2139
2532	6	2139
2545	6	2139
2786	6	2139


************************



Implementation of the Substring Test by Hashing

A technique is described for implementing the
test which determines if one string is a substring 
<B>of a</B>nother.  When there is low probability that the test
will be satisfied, it is shown how the operation 
can be speeded up considerably if it is preceded by
a test on appropriately chosen hash codes of the 
strings.

CACM December, 1971

Harrison, M. C.

substring, hashing, subset, signature, information
compression, information retrieval, searching

3.74 5.30 5.6

CA711204 JB February 2, 1978  10:14 AM

2139	5	2139
2139	5	2139
2139	5	2139
2532	5	2139
2631	5	2139
2746	5	2139
3001	5	2139
1665	6	2139
1739	6	2139
2033	6	2139
2139	6	2139
2139	6	2139
2139	6	2139
2139	6	2139
2532	6	2139
2545	6	2139
2786	6	2139


************************

************************
Document:  CACM-3166.html
************************


Computing Standard Deviations: Accuracy

Four algorithms for the numerical computation
of the standard deviation of (unweighted) sampled data
are analyzed.  Two of the algorithms are well-known in the statistical
and computational literature; the other two are new algorithms
specifically intended for automatic computation.  Our discussion is 
expository, with emphasis on reaching a suitable definition of
"accuracy."  Each of the four algorithms is analyzed for the conditions
under <B>which it</B> will be accurate.  We conclude that all four
algorithms will provide accurate answers for many problems, but two
of the algorithms, one new, one old, are substantially more accurate
on difficult problems than are the other two.

CACM September, 1979

Chan, T.
Lewis, J.

Mean, standard deviation, least squares, updating
estimates, rounding error analysis, condition number.

5.5 5.11 5.19

CA790907 DB January 16, 1980  4:23 PM

1619	4	3166
2731	4	3166
3159	4	3166
3159	4	3166
3166	4	3166
3166	4	3166
3166	4	3166
3166	4	3166
3166	4	3166
3167	4	3166
3167	4	3166
1411	5	3166
2731	5	3166
2799	5	3166
3159	5	3166
3166	5	3166
3166	5	3166
3166	5	3166
3167	5	3166
2731	6	3166
2799	6	3166
3166	6	3166


************************



Computing Standard Deviations: Accuracy

Four algorithms for the numerical computation
of the standard deviation of (unweighted) sampled data
are analyzed.  Two of the algorithms are well-known in the statistical
and computational literature; the other two are new algorithms
specifically intended for automatic computation.  Our discussion is 
expository, with emphasis on reaching a suitable definition of
"accuracy."  Each of the four algorithms is analyzed for the conditions
under which it will be accurate.  We conclude <B>that a</B>ll four
algorithms will provide accurate answers for many problems, but two
of the algorithms, one new, one old, are substantially more accurate
on difficult problems than are the other two.

CACM September, 1979

Chan, T.
Lewis, J.

Mean, standard deviation, least squares, updating
estimates, rounding error analysis, condition number.

5.5 5.11 5.19

CA790907 DB January 16, 1980  4:23 PM

1619	4	3166
2731	4	3166
3159	4	3166
3159	4	3166
3166	4	3166
3166	4	3166
3166	4	3166
3166	4	3166
3166	4	3166
3167	4	3166
3167	4	3166
1411	5	3166
2731	5	3166
2799	5	3166
3159	5	3166
3166	5	3166
3166	5	3166
3166	5	3166
3167	5	3166
2731	6	3166
2799	6	3166
3166	6	3166


************************

************************
Document:  CACM-2912.html
************************


Concurrent Reading and Writing

The problem of sharing data among asynchronous
process is considered.  It is assumed that only 
one process at a time can modify the data, but concurrent
reading and writing is permitted.  Two general 
theorems are proved, and some algorithms are presented
to illustrate their use.  These include a solution 
to the general problem <B>in which</B> a read is repeated if
it might have obtained an incorrect result, and 
two techniques for transmitting messages between processes.
 These solutions do not assume any synchronizing 
mechanism other than data which can be written
by one process and read by other processes.

CACM November, 1977

Lamport, L.

asynchronous multiprocessing, multiprocess synchronization,
readers/writers problem, shared data

4.32 5.24

CA771104 JB December 27, 1977  7:47 AM

2320	4	2912
2597	4	2912
2777	4	2912
2851	4	2912
2895	4	2912
2912	4	2912
2946	4	2912
3128	4	2912
2150	5	2912
2912	5	2912
2912	5	2912
2912	5	2912
3128	5	2912
2150	6	2912
2376	6	2912
2436	6	2912
2597	6	2912
2865	6	2912
2866	6	2912
2870	6	2912
2912	6	2912
3082	6	2912


************************

************************
Document:  CACM-3031.html
************************


<B>Abstract Data</B> Types and Software Validation

A data abstraction can be naturally specified
using algebraic axioms.  The virtue of these 
axioms is that they permit a representation-independent
formal specification of a data type.  An example 
is given which shows how to employ algebraic axioms at
successive levels of implementation.  The  major 
thrust of the paper is twofold.  First, it is shown how
the use of algebraic axiomatizations can simplify 
the process of proving the correctness of an implementation
of an abstract data type.  Second, semi-automatic 
tools are described which can be used both to automate
such proofs of correctness and to derive an immediate 
implementation from the axioms.  This implementation
allows for limited testing of programs at design 
time, before a conventional implementation is accomplished.

CACM December, 1978

Guttag, J.
Horowitz, E.
Musser, D.

Abstract data type, correctness proof,
data type, data structure, specification 

4.34 5.24

CA781208 DH January 18, 1979  2:51 PM   

3030	4	3031
3031	4	3031
3031	4	3031
3049	4	3031
3105	4	3031
3148	4	3031
3150	4	3031
2939	5	3031
2958	5	3031
3031	5	3031
3031	5	3031
3031	5	3031


************************



Abstract Data Types and Software Validation

A data abstraction can be naturally specified
using algebraic axioms.  The virtue of these 
axioms is that they permit a representation-independent
formal specification of a data type.  An example 
is given which shows <B>how to</B> employ algebraic axioms at
successive levels of implementation.  The  major 
thrust of the paper is twofold.  First, it is shown how
the use of algebraic axiomatizations can simplify 
the process of proving the correctness of an implementation
of an abstract data type.  Second, semi-automatic 
tools are described which can be used both to automate
such proofs of correctness and to derive an immediate 
implementation from the axioms.  This implementation
allows for limited testing of programs at design 
time, before a conventional implementation is accomplished.

CACM December, 1978

Guttag, J.
Horowitz, E.
Musser, D.

Abstract data type, correctness proof,
data type, data structure, specification 

4.34 5.24

CA781208 DH January 18, 1979  2:51 PM   

3030	4	3031
3031	4	3031
3031	4	3031
3049	4	3031
3105	4	3031
3148	4	3031
3150	4	3031
2939	5	3031
2958	5	3031
3031	5	3031
3031	5	3031
3031	5	3031


************************



Abstract Data Types and Software Validation

A data abstraction can be naturally specified
using algebraic axioms.  The virtue of these 
axioms is that they permit a representation-independent
formal specification <B>of a</B> data type.  An example 
is given which shows how to employ algebraic axioms at
successive levels of implementation.  The  major 
thrust of the paper is twofold.  First, it is shown how
the use of algebraic axiomatizations can simplify 
the process of proving the correctness of an implementation
of an abstract data type.  Second, semi-automatic 
tools are described which can be used both to automate
such proofs of correctness and to derive an immediate 
implementation from the axioms.  This implementation
allows for limited testing of programs at design 
time, before a conventional implementation is accomplished.

CACM December, 1978

Guttag, J.
Horowitz, E.
Musser, D.

Abstract data type, correctness proof,
data type, data structure, specification 

4.34 5.24

CA781208 DH January 18, 1979  2:51 PM   

3030	4	3031
3031	4	3031
3031	4	3031
3049	4	3031
3105	4	3031
3148	4	3031
3150	4	3031
2939	5	3031
2958	5	3031
3031	5	3031
3031	5	3031
3031	5	3031


************************



Abstract Data Types and Software Validation

A data abstraction can be naturally specified
using algebraic axioms.  The virtue of these 
axioms is that they permit a representation-independent
formal specification of a data type.  An example 
is given which shows how to employ algebraic axioms at
successive levels of implementation.  The  major 
thrust of the paper is twofold.  First, <B>it is</B> shown how
the use of algebraic axiomatizations can simplify 
the process of proving the correctness of an implementation
of an abstract data type.  Second, semi-automatic 
tools are described which can be used both to automate
such proofs of correctness and to derive an immediate 
implementation from the axioms.  This implementation
allows for limited testing of programs at design 
time, before a conventional implementation is accomplished.

CACM December, 1978

Guttag, J.
Horowitz, E.
Musser, D.

Abstract data type, correctness proof,
data type, data structure, specification 

4.34 5.24

CA781208 DH January 18, 1979  2:51 PM   

3030	4	3031
3031	4	3031
3031	4	3031
3049	4	3031
3105	4	3031
3148	4	3031
3150	4	3031
2939	5	3031
2958	5	3031
3031	5	3031
3031	5	3031
3031	5	3031


************************



Abstract <B>Data Types</B> and Software Validation

A data abstraction can be naturally specified
using algebraic axioms.  The virtue of these 
axioms is that they permit a representation-independent
formal specification of a data type.  An example 
is given which shows how to employ algebraic axioms at
successive levels of implementation.  The  major 
thrust of the paper is twofold.  First, it is shown how
the use of algebraic axiomatizations can simplify 
the process of proving the correctness of an implementation
of an abstract data type.  Second, semi-automatic 
tools are described which can be used both to automate
such proofs of correctness and to derive an immediate 
implementation from the axioms.  This implementation
allows for limited testing of programs at design 
time, before a conventional implementation is accomplished.

CACM December, 1978

Guttag, J.
Horowitz, E.
Musser, D.

Abstract data type, correctness proof,
data type, data structure, specification 

4.34 5.24

CA781208 DH January 18, 1979  2:51 PM   

3030	4	3031
3031	4	3031
3031	4	3031
3049	4	3031
3105	4	3031
3148	4	3031
3150	4	3031
2939	5	3031
2958	5	3031
3031	5	3031
3031	5	3031
3031	5	3031


************************

************************
Document:  CACM-2940.html
************************


Abstraction and Verification in Alphard: Defining
and Specifying Iteration and Generators

The Alphard "form" provides the programmer with
a great deal of control over the implementation 
of abstract data types.  In this paper the abstraction techniques
are extended from simple data representation 
and function definition to the iteration statement, the
most important poin t of interaction between data 
and the control structure of the language itself.  A
means of specializing Alphard's loops to operate 
on abstract entities without explicit dependence on the
representation of those entities is in troduced. 
 Specification and verification techniques <B>that a</B>llow
the properties of the generators for such iterations 
to be expressed in the form of proof rules are developed.
 Results are obtained that for common special 
cases of these loops are essentially identical to the
corresponding constructs in other languages.  A 
means of showing that a generator will terminate is also provided.

CACM August, 1977

Shaw, M.
Wulf, W. A.

abstraction and representation, abstract data types,
assertions, control specialization, correctness, 
generators,invariants, iteration statements, modular
decomposition, program specifications, programming 
languages, programming methodology, proofs of correctness, types, verification

4.20 5.24

CA770803 JB December 28, 1977  7:59 AM

2940	5	2940
2940	5	2940
2940	5	2940
3150	5	2940
2060	6	2940
2704	6	2940
2842	6	2940
2939	6	2940
2940	6	2940
2941	6	2940
2943	6	2940
3073	6	2940
3148	6	2940


************************



Abstraction and Verification in Alphard: Defining
and Specifying Iteration and Generators

The Alphard "form" provides the programmer with
a great deal of control over the implementation 
<B>of a</B>bstract data types.  In this paper the abstraction techniques
are extended from simple data representation 
and function definition to the iteration statement, the
most important poin t of interaction between data 
and the control structure of the language itself.  A
means of specializing Alphard's loops to operate 
on abstract entities without explicit dependence on the
representation of those entities is in troduced. 
 Specification and verification techniques that allow
the properties of the generators for such iterations 
to be expressed in the form of proof rules are developed.
 Results are obtained that for common special 
cases of these loops are essentially identical to the
corresponding constructs in other languages.  A 
means of showing that a generator will terminate is also provided.

CACM August, 1977

Shaw, M.
Wulf, W. A.

abstraction and representation, abstract data types,
assertions, control specialization, correctness, 
generators,invariants, iteration statements, modular
decomposition, program specifications, programming 
languages, programming methodology, proofs of correctness, types, verification

4.20 5.24

CA770803 JB December 28, 1977  7:59 AM

2940	5	2940
2940	5	2940
2940	5	2940
3150	5	2940
2060	6	2940
2704	6	2940
2842	6	2940
2939	6	2940
2940	6	2940
2941	6	2940
2943	6	2940
3073	6	2940
3148	6	2940


************************

************************
Document:  CACM-0071.html
************************


Proposal for a Feasible Programming System

This paper proposes designing a programming
facility (itself involving a digital computer and 
a program) which will assist the preparation of large-scale
real-time programs.  This facility is to 
be capable of preparing programs for any <B>of a</B> variety
of machines having characteristics similar to those 
of the facility's computer.  One of the basic assumptions
is that there will be enough random-access 
storage available to avoid the necessity for segmenting
a constructed program in any fashion other than 
a trivial one.  While this assumption is somewhat unrealistic,
it is intended to provide an opportunity 
to concentrate on the other aspects of program construction.
 The programming system should stress the 
discovery in source program statements of as many errors
as possible, before attempting to construct 
an object program.  Among the computer characteristics
which are advocated are a program interrupt scheme, 
a large set of characters, and indirect addressing.

CACM August, 1959

Bagley, P. R.

CA590802 JB March 22, 1978  6:16 PM

71	5	71
71	5	71
71	5	71


************************



Proposal for a Feasible Programming System

This paper proposes designing a programming
facility (itself involving a digital computer and 
a program) which will assist the preparation of large-scale
real-time programs.  This facility is to 
be capable of preparing programs for any of a variety
of machines having characteristics similar to those 
of the facility's computer.  One of the basic assumptions
is that there will be enough random-access 
storage available <B>to avoid</B> the necessity for segmenting
a constructed program in any fashion other than 
a trivial one.  While this assumption is somewhat unrealistic,
it is intended to provide an opportunity 
to concentrate on the other aspects of program construction.
 The programming system should stress the 
discovery in source program statements of as many errors
as possible, before attempting to construct 
an object program.  Among the computer characteristics
which are advocated are a program interrupt scheme, 
a large set of characters, and indirect addressing.

CACM August, 1959

Bagley, P. R.

CA590802 JB March 22, 1978  6:16 PM

71	5	71
71	5	71
71	5	71


************************



Proposal for a Feasible Programming System

This paper proposes designing a programming
facility (itself involving a digital computer and 
a program) which will assist the preparation of large-scale
real-time programs.  This facility is to 
be capable of preparing programs for any of a variety
of machines having characteristics similar to those 
of the facility's computer.  One of the basic assumptions
is that there will be enough random-access 
storage available to avoid the necessity for segmenting
a constructed program in any fashion other than 
a trivial one.  While this assumption is somewhat unrealistic,
<B>it is</B> intended to provide an opportunity 
to concentrate on the other aspects of program construction.
 The programming system should stress the 
discovery in source program statements of as many errors
as possible, before attempting to construct 
an object program.  Among the computer characteristics
which are advocated are a program interrupt scheme, 
a large set of characters, and indirect addressing.

CACM August, 1959

Bagley, P. R.

CA590802 JB March 22, 1978  6:16 PM

71	5	71
71	5	71
71	5	71


************************

************************
Document:  CACM-2931.html
************************


Logic and Programming Languages

Logic has been long in terested in whether answers
to certa<B>in questions</B> are computable in principle, 
since the outcome puts bounds on the possibilities of
formalization.  More recently, precise comparisons 
in the efficiency of decision methods have become available
through the developments in complexity theory. 
 These, however, are applications to logic, and a big question
is whether methods of logic have significance 
in the other direction for the more applied parts of
computability theory.  Programming languages offer 
an obvious opportunity as their syntactic formalization
is well advanced; however, the semantical theory 
can hardly be said to be complete.  Though we have
many examples, we have still to give wide-ranging 
mathematical answers to these queries:  What is a machine?
 What is a computable process?  How (or how 
well) does a machine simulate a process?  Programs naturally
enter in giving descriptions of processes. 
 The definition of the precise meaning of a program
then requires us to explain what are the objects 
of computation (in a way, the statics of the problem)
and how they are to be transformed (the dynamics). 
 So far the theories of automata and of nets, though
most in teresting for dynamics, have formalized only 
a portion of the field, and there has been perhaps too
much concentration on the finite-state and algebraic 
aspects.  It would seem that the understanding of higher-level
program features involves us with infinite 
objects and forces us to pass through several levels
of explanation to go from the conceptual ideas to 
the final simulation on a real machine.  These levels
can be made mathematically exact if we can find 
the right abstractions to represent the necessary structures.
 The experience of many independent workers 
with the method of data types as lattices (or partial
orderings) under an information content ordering, 
and with their continuous mappings, has demonstrated the
flexibility of this approach in providing definitions 
and proofs, which are clean and without undue dependence
on implementations.  Nevertheless much remains 
to be done in showing how abstract conceptualizations
can (or cannot) be actualized before we can say 
we have a unified theory.

CACM September, 1977

Scott, D. S.

logic, programming languages, automata, denotational
semantics, a-calculus models, computability, 
partial functions, approximation, function spaces

1.2 4.20 5.21 5.24 5.27

CA770902 JB December 28, 1977  6:49 AM

2931	5	2931
2931	5	2931
2931	5	2931


************************



Logic and Programming Languages

Logic has been long in terested in whether answers
to certain questions are computable in principle, 
since the outcome puts bounds on the possibilities of
formalization.  More recently, precise comparisons 
in the efficiency of decision methods have become available
through the developments in complexity theory. 
 These, however, are applications to logic, and a big question
is whether methods of logic have significance 
in the other direction for the more applied parts of
computability theory.  Programming languages offer 
an obvious opportunity as their syntactic formalization
is well advanced; however, the semantical theory 
can hardly be said to be complete.  Though we have
many examples, we have still to give wide-ranging 
mathematical answers to these queries:  What is a machine?
 What is a computable process?  How (or how 
well) does a machine simulate a process?  Programs naturally
enter in giving descriptions of processes. 
 The definition of the precise meaning <B>of a</B> program
then requires us to explain what are the objects 
of computation (in a way, the statics of the problem)
and how they are to be transformed (the dynamics). 
 So far the theories of automata and of nets, though
most in teresting for dynamics, have formalized only 
a portion of the field, and there has been perhaps too
much concentration on the finite-state and algebraic 
aspects.  It would seem that the understanding of higher-level
program features involves us with infinite 
objects and forces us to pass through several levels
of explanation to go from the conceptual ideas to 
the final simulation on a real machine.  These levels
can be made mathematically exact if we can find 
the right abstractions to represent the necessary structures.
 The experience of many independent workers 
with the method of data types as lattices (or partial
orderings) under an information content ordering, 
and with their continuous mappings, has demonstrated the
flexibility of this approach in providing definitions 
and proofs, which are clean and without undue dependence
on implementations.  Nevertheless much remains 
to be done in showing how abstract conceptualizations
can (or cannot) be actualized before we can say 
we have a unified theory.

CACM September, 1977

Scott, D. S.

logic, programming languages, automata, denotational
semantics, a-calculus models, computability, 
partial functions, approximation, function spaces

1.2 4.20 5.21 5.24 5.27

CA770902 JB December 28, 1977  6:49 AM

2931	5	2931
2931	5	2931
2931	5	2931


************************



Logic and Programming Languages

Logic has been long in terested in whether answers
to certain questions are computable in principle, 
since the outcome puts bounds on the possibilities of
formalization.  More recently, precise comparisons 
in the efficiency of decision methods have become available
through the developments in complexity theory. 
 These, however, are applications to logic, and a big question
is whether methods of logic have significance 
in the other direction for the more applied parts of
computability theory.  Programming languages offer 
an obvious opportunity as their syntactic formalization
is well advanced; however, the semantical theory 
can hardly be said to be complete.  Though we have
many examples, we have still to give wide-ranging 
mathematical answers to these queries:  <B>What is</B> a machine?
 What is a computable process?  How (or how 
well) does a machine simulate a process?  Programs naturally
enter in giving descriptions of processes. 
 The definition of the precise meaning of a program
then requires us to explain what are the objects 
of computation (in a way, the statics of the problem)
and how they are to be transformed (the dynamics). 
 So far the theories of automata and of nets, though
most in teresting for dynamics, have formalized only 
a portion of the field, and there has been perhaps too
much concentration on the finite-state and algebraic 
aspects.  It would seem that the understanding of higher-level
program features involves us with infinite 
objects and forces us to pass through several levels
of explanation to go from the conceptual ideas to 
the final simulation on a real machine.  These levels
can be made mathematically exact if we can find 
the right abstractions to represent the necessary structures.
 The experience of many independent workers 
with the method of data types as lattices (or partial
orderings) under an information content ordering, 
and with their continuous mappings, has demonstrated the
flexibility of this approach in providing definitions 
and proofs, which are clean and without undue dependence
on implementations.  Nevertheless much remains 
to be done in showing how abstract conceptualizations
can (or cannot) be actualized before we can say 
we have a unified theory.

CACM September, 1977

Scott, D. S.

logic, programming languages, automata, denotational
semantics, a-calculus models, computability, 
partial functions, approximation, function spaces

1.2 4.20 5.21 5.24 5.27

CA770902 JB December 28, 1977  6:49 AM

2931	5	2931
2931	5	2931
2931	5	2931


************************

************************
Document:  CACM-2750.html
************************


A Cost Oriented Algorithm for Data Set Allocation in Storage Hierarchies

Data set allocation in today's multilevel
storage systems is usually based on qualitative, 
ad hoc decisions.  While it would be desirable to obtain
an optimal solution to this allocation problem, 
<B>it is</B> clear that the number of parameters involved makes
it intractable to straight-forward solution. 
 In such a situation, we must find a set of assumptions
which simplify the problem greatly, but which 
still provide a basis for considering all significant
cost elements. This paper presents such a first, 
quantitative allocation step.  It considers many of the
significant detailed costs of system utilization, 
data storage, data staging, and data migration.  Although
many avenues of further improvement are available, 
the present algorithm seems to be usefully accurate.
As such, it can aid in quantifying the problems 
of data set allocation, storage system configuration, and new device designs.

CACM June, 1975

Lum, V. Y.
Senko, M. E
Wang, C. P.
Ling, H.

data set allocation, hierarchical storage, storage
system configuration, data staging, data migration, 
storage allocation analysis

3.5 3.9 6.2

CA750603 JB January 9, 1978  1:31 PM

2750	5	2750
2750	5	2750
2750	5	2750


************************



A Cost Oriented Algorithm for Data Set Allocation in Storage Hierarchies

Data set allocation in today's multilevel
storage systems is usually based on qualitative, 
ad hoc decisions.  While it would be desirable to obtain
an optimal solution to this allocation problem, 
it is clear that the number of parameters involved makes
it intractable to straight-forward solution. 
 In such a situation, we must find a set <B>of a</B>ssumptions
which simplify the problem greatly, but which 
still provide a basis for considering all significant
cost elements. This paper presents such a first, 
quantitative allocation step.  It considers many of the
significant detailed costs of system utilization, 
data storage, data staging, and data migration.  Although
many avenues of further improvement are available, 
the present algorithm seems to be usefully accurate.
As such, it can aid in quantifying the problems 
of data set allocation, storage system configuration, and new device designs.

CACM June, 1975

Lum, V. Y.
Senko, M. E
Wang, C. P.
Ling, H.

data set allocation, hierarchical storage, storage
system configuration, data staging, data migration, 
storage allocation analysis

3.5 3.9 6.2

CA750603 JB January 9, 1978  1:31 PM

2750	5	2750
2750	5	2750
2750	5	2750


************************

************************
Document:  CACM-0718.html
************************


An Experiment in Automatic Verification of Programs 

How effective is a compiler at replacing explicit
verification, and what <B>is the</B> cost of this 
technique?

CACM October, 1963

Weinberg, G. M.
Gressett, G. L.

CA631007 JB March 13, 1978  5:59 PM

1053	5	718
718	5	718
718	5	718
718	5	718
435	6	718
474	6	718
718	6	718
720	6	718


************************

************************
Document:  CACM-3103.html
************************


Automatic Data Structure Selection: An Example and Overview

The use of several levels <B>of a</B>bstraction has
proved to be very helpful in constructing and 
maintaining programs.  When programs are designed with abstract
data types such as sets and lists, programmer 
time can be saved by automating the process of filling
in low-level implementation details.  In the past, 
programming systems have provided only a single general
purpose implementation for an abstract type. 
 Thus the programs produced using abstract types were
then inefficient in space or time.  In this paper 
a system for automatically choosing efficient implementations
for abstract types from a library of implementations 
is discussed.  This process is discussed in detail for
an example program.  General issues in data structure 
selection are also reviewed. 

CACM May, 1978

Low, J.

Abstract data types, automatic programming, data
structures, optimizing compilers, sets, lists

4.12 4.22 4.6

CA780504 DH February 26, 1979  1:51 PM

1957	4	3103
2151	4	3103
3103	4	3103
3103	4	3103
3148	4	3103
1860	5	3103
2877	5	3103
3103	5	3103
3103	5	3103
3103	5	3103


************************

************************
Document:  CACM-2941.html
************************


Early Experience with Mesa

The experiences of Mesa's first users-primarily
its implementers-are discussed, and some implications 
for Mesa and similar programming languages are suggested.
The specific topics addressed are: module structure 
and its use in defining abstractions, data-structuring
facilities in Mesa, an equivalence algorithm for 
types and type coercions, the benefits of the type system
and why <B>it is</B> breached occasionally, and the 
difficulty of making the treatment of variant records safe.

CACM August, 1977

Geschke, C. M.
Morris, J. H. Jr.
Satterthwaite, E. H.

programming languages, types, modules,
data structures, systems programming

4.22

CA770802 JB December 28, 1977  8:07 AM

1458	4	2941
1523	4	2941
1603	4	2941
1698	4	2941
1747	4	2941
1748	4	2941
1854	4	2941
1877	4	2941
1960	4	2941
2377	4	2941
2378	4	2941
2497	4	2941
2558	4	2941
2625	4	2941
2632	4	2941
2704	4	2941
2723	4	2941
2738	4	2941
2840	4	2941
2866	4	2941
2868	4	2941
2869	4	2941
2939	4	2941
2941	4	2941
2941	4	2941
2941	4	2941
2941	4	2941
2956	4	2941
2958	4	2941
3004	4	2941
3030	4	2941
3030	4	2941
3105	4	2941
3144	4	2941
1471	5	2941
2356	5	2941
2558	5	2941
2651	5	2941
2941	5	2941
2941	5	2941
2941	5	2941
3150	5	2941
2060	6	2941
2704	6	2941
2842	6	2941
2939	6	2941
2940	6	2941
2941	6	2941
2943	6	2941
3073	6	2941
3148	6	2941


************************



Early Experience with Mesa

The experiences of Mesa's first users-primarily
its implementers-are discussed, and some implications 
for Mesa and similar programming languages are suggested.
The specific topics addressed are: module structure 
and its use in defining abstractions, data-structuring
facilities in Mesa, an equivalence algorithm for 
types and type coercions, the benefits of <B>the type</B> system
and why it is breached occasionally, and the 
difficulty of making the treatment of variant records safe.

CACM August, 1977

Geschke, C. M.
Morris, J. H. Jr.
Satterthwaite, E. H.

programming languages, types, modules,
data structures, systems programming

4.22

CA770802 JB December 28, 1977  8:07 AM

1458	4	2941
1523	4	2941
1603	4	2941
1698	4	2941
1747	4	2941
1748	4	2941
1854	4	2941
1877	4	2941
1960	4	2941
2377	4	2941
2378	4	2941
2497	4	2941
2558	4	2941
2625	4	2941
2632	4	2941
2704	4	2941
2723	4	2941
2738	4	2941
2840	4	2941
2866	4	2941
2868	4	2941
2869	4	2941
2939	4	2941
2941	4	2941
2941	4	2941
2941	4	2941
2941	4	2941
2956	4	2941
2958	4	2941
3004	4	2941
3030	4	2941
3030	4	2941
3105	4	2941
3144	4	2941
1471	5	2941
2356	5	2941
2558	5	2941
2651	5	2941
2941	5	2941
2941	5	2941
2941	5	2941
3150	5	2941
2060	6	2941
2704	6	2941
2842	6	2941
2939	6	2941
2940	6	2941
2941	6	2941
2943	6	2941
3073	6	2941
3148	6	2941


************************

************************
Document:  CACM-3008.html
************************


Preserving Average Proximity in Arrays

Programmers and data structure designers are often
forced to choose between alternative structures. 
 In storing these structures, preserving logical adjacencies
or "proximity" is usually an important consideration. 
 The combinatorial problem of storing arrays as various
kinds of list structures is examined.  Embeddings 
of graphs are used to model the loss of proximity involved
in such storage schemes, and an elementary 
proof that arrays cannot be stored as linear lists with
bounded loss of proximity is presented.  Average 
loss of proximity is then considered, and <B>it is</B> shown
that arrays cannot be stored as linear lists with 
only bounded loss of average proximity, but can be so
stored in binary trees.  The former result implies, 
for instance, that row major order is an asymptotically
optimal storage strategy for arrays.

CACM March, 1978

DeMillo, R.
Eisenstat, S.
Lipton, R.

arrays, graph embedding, linear lists,
proximity, average proximity, trees

4.34 5.24 5.25 5.32

CA780305 JB March 28, 1978  1:07 PM

1050	4	3008
1102	4	3008
378	4	3008
3008	4	3008
731	4	3008
798	4	3008
209	5	3008
3008	5	3008
3008	5	3008
3008	5	3008


************************



Preserving Average Proximity in Arrays

Programmers and data structure designers are often
forced to choose between alternative structures. 
 In storing these structures, preserving logical adjacencies
or "proximity" is usually an important consideration. 
 The combinatorial problem of storing arrays as various
kinds of list structures is examined.  Embeddings 
of graphs are used to model the loss of proximity involved
in such storage schemes, and an elementary 
proof that arrays cannot be stored as linear lists with
bounded loss of proximity is presented.  Average 
loss of proximity <B>is the</B>n considered, and it is shown
that arrays cannot be stored as linear lists with 
only bounded loss of average proximity, but can be so
stored in binary trees.  The former result implies, 
for instance, that row major order is an asymptotically
optimal storage strategy for arrays.

CACM March, 1978

DeMillo, R.
Eisenstat, S.
Lipton, R.

arrays, graph embedding, linear lists,
proximity, average proximity, trees

4.34 5.24 5.25 5.32

CA780305 JB March 28, 1978  1:07 PM

1050	4	3008
1102	4	3008
378	4	3008
3008	4	3008
731	4	3008
798	4	3008
209	5	3008
3008	5	3008
3008	5	3008
3008	5	3008


************************



Preserving Average Proximity in Arrays

Programmers and data structure designers are often
forced to choose between alternative structures. 
 In storing these structures, preserving logical adjacencies
or "proximity" is usually an important consideration. 
 The combinatorial problem of storing arrays as various
kinds of list structures is examined.  Embeddings 
of graphs are used to model the loss of proximity involved
in such storage schemes, and an elementary 
proof that arrays cannot be stored as linear lists with
bounded loss of proximity is presented.  Average 
loss of proximity is then considered, and it is shown
that arrays cannot be stored as linear lists with 
only bounded loss <B>of a</B>verage proximity, but can be so
stored in binary trees.  The former result implies, 
for instance, that row major order is an asymptotically
optimal storage strategy for arrays.

CACM March, 1978

DeMillo, R.
Eisenstat, S.
Lipton, R.

arrays, graph embedding, linear lists,
proximity, average proximity, trees

4.34 5.24 5.25 5.32

CA780305 JB March 28, 1978  1:07 PM

1050	4	3008
1102	4	3008
378	4	3008
3008	4	3008
731	4	3008
798	4	3008
209	5	3008
3008	5	3008
3008	5	3008
3008	5	3008


************************



Preserving Average Proximity in Arrays

Programmers and data structure designers are often
forced to choose between alternative structures. 
 In storing these structures, preserving logical adjacencies
or "proximity" is usually an important consideration. 
 The combinatorial problem of storing arrays as various
kinds of list structures is examined.  Embeddings 
of graphs are used to model the loss of proximity involved
in such storage schemes, and an elementary 
proof <B>that a</B>rrays cannot be stored as linear lists with
bounded loss of proximity is presented.  Average 
loss of proximity is then considered, and it is shown
that arrays cannot be stored as linear lists with 
only bounded loss of average proximity, but can be so
stored in binary trees.  The former result implies, 
for instance, that row major order is an asymptotically
optimal storage strategy for arrays.

CACM March, 1978

DeMillo, R.
Eisenstat, S.
Lipton, R.

arrays, graph embedding, linear lists,
proximity, average proximity, trees

4.34 5.24 5.25 5.32

CA780305 JB March 28, 1978  1:07 PM

1050	4	3008
1102	4	3008
378	4	3008
3008	4	3008
731	4	3008
798	4	3008
209	5	3008
3008	5	3008
3008	5	3008
3008	5	3008


************************

************************
Document:  CACM-2572.html
************************


Arguments for a Moratorium on the Construction
<B>of a</B> Community Information Utility

In this article the author urges a prudent
and decentralized approach to the question of the 
design and desirability of computerized community information
utilities.  Before accepting the inevitability 
and desirability of this or any technology, we should:
(1) be sure of the feasibility (internally and 
externally) of what is proposed; (2) project and perhaps
wait for changes in complementary techniques; 
(3) evaluate current and projected supplementary techniques;
(4) establish the existence of demand for 
what is proposed; (5) take steps to involve a representative
group of ultimate users in systems design, 
and (6) carefully think through possible side effects
on man and his world view.  Current proposals for 
community information utilities are examined in this
framework, and the conclusion is drawn that society 
is not yet in a position to justify either the construction
of an information utility in a prototype 
community or the acceptance of a policy in
favor of its widespread implementation.

CACM December, 1974

Press, L. I.

community information utilities, social implications, public policy

2.1 2.3

CA741202 JB January 16, 1978  10:02 AM

2572	5	2572
2572	5	2572
2572	5	2572
3179	5	2572
2572	6	2572
2607	6	2572
3076	6	2572


************************

************************
Document:  CACM-1625.html
************************


On the Automatic Simplification of Source-Language Programs

Methods of simplification that can be applied
automatically to programs written in an ALGOL-like 
language are discussed.  The simplifications are based
on the form of the program and the knowledge obtained 
by a processor, without any understanding of what the
program is supposed to do.  These methods have 
been implemented in a processor called SURE that accepts
a program written in JOVIAL and outputs an equivalent 
JOVIAL program that may be shorter and may be executed
faster than the original.  SURE is described, 
some of the problems encountered in automatic improvement
at the source-language level are discussed, 
and further types <B>of a</B>utomatic program improvement are suggested.

CACM March, 1967

Clark, E. R.

CA670304 JB February 28, 1978  1:33 PM

1084	4	1625
1379	4	1625
1625	4	1625
1625	4	1625
1807	4	1625
1945	4	1625
1947	4	1625
1248	5	1625
1625	5	1625
1625	5	1625
1625	5	1625
669	5	1625


************************



On the Automatic Simplification of Source-Language Programs

Methods of simplification that can be applied
automatically to programs written in an ALGOL-like 
language are discussed.  The simplifications are based
on the form of the program and the knowledge obtained 
by a processor, without any understanding of what the
program is supposed to do.  These methods have 
been implemented in a processor called SURE <B>that a</B>ccepts
a program written in JOVIAL and outputs an equivalent 
JOVIAL program that may be shorter and may be executed
faster than the original.  SURE is described, 
some of the problems encountered in automatic improvement
at the source-language level are discussed, 
and further types of automatic program improvement are suggested.

CACM March, 1967

Clark, E. R.

CA670304 JB February 28, 1978  1:33 PM

1084	4	1625
1379	4	1625
1625	4	1625
1625	4	1625
1807	4	1625
1945	4	1625
1947	4	1625
1248	5	1625
1625	5	1625
1625	5	1625
1625	5	1625
669	5	1625


************************

************************
Document:  CACM-3105.html
************************


A Language Extension for Expressing Constraints on Data Access

Controlled sharing of information is needed and
desirable for many applications and is supported 
in operating systems by access control mechanisms.  This
paper shows <B>how to</B> extend programming languages 
to provide controlled sharing.  The extension permits
expression of access constraints on shared data. 
 Access constraints can apply both to simple objects, and
to objects that are components of larger objects, 
such as bank account records in a bank's data base.
 The constraints are stated declaratively, and can 
be enforced by static checking similar to type checking.
 The approach can be used to extend any strongly-typed 
language, but is particularly suitable for extending
languages that support the notion of abstract data 
types. 

CACM May, 1978

Jones, A.
Liskov,B.

Programming languages, access control, data types,
abstract data types, type checking, capabilities

4.20 4.35

CA780502 DH February 26, 1979  3:19 PM

1458	4	3105
1523	4	3105
1603	4	3105
1698	4	3105
1747	4	3105
1748	4	3105
1854	4	3105
1877	4	3105
1960	4	3105
2377	4	3105
2378	4	3105
2497	4	3105
2558	4	3105
2625	4	3105
2626	4	3105
2632	4	3105
2840	4	3105
2868	4	3105
2868	4	3105
2870	4	3105
2876	4	3105
2941	4	3105
3031	4	3105
3105	4	3105
3105	4	3105
3105	4	3105
3105	4	3105
3105	4	3105
3105	4	3105
3144	4	3105
3144	4	3105
3144	4	3105
3148	4	3105
3150	4	3105
1471	5	3105
2625	5	3105
2632	5	3105
2868	5	3105
2939	5	3105
3068	5	3105
3105	5	3105
3105	5	3105
3105	5	3105


************************



A Language Extension for Expressing Constraints on Data Access

Controlled sharing of information is needed and
desirable for many applications and is supported 
in operating systems by access control mechanisms.  This
paper shows how to extend programming languages 
to provide controlled sharing.  The extension permits
expression <B>of a</B>ccess constraints on shared data. 
 Access constraints can apply both to simple objects, and
to objects that are components of larger objects, 
such as bank account records in a bank's data base.
 The constraints are stated declaratively, and can 
be enforced by static checking similar to type checking.
 The approach can be used to extend any strongly-typed 
language, but is particularly suitable for extending
languages that support the notion of abstract data 
types. 

CACM May, 1978

Jones, A.
Liskov,B.

Programming languages, access control, data types,
abstract data types, type checking, capabilities

4.20 4.35

CA780502 DH February 26, 1979  3:19 PM

1458	4	3105
1523	4	3105
1603	4	3105
1698	4	3105
1747	4	3105
1748	4	3105
1854	4	3105
1877	4	3105
1960	4	3105
2377	4	3105
2378	4	3105
2497	4	3105
2558	4	3105
2625	4	3105
2626	4	3105
2632	4	3105
2840	4	3105
2868	4	3105
2868	4	3105
2870	4	3105
2876	4	3105
2941	4	3105
3031	4	3105
3105	4	3105
3105	4	3105
3105	4	3105
3105	4	3105
3105	4	3105
3105	4	3105
3144	4	3105
3144	4	3105
3144	4	3105
3148	4	3105
3150	4	3105
1471	5	3105
2625	5	3105
2632	5	3105
2868	5	3105
2939	5	3105
3068	5	3105
3105	5	3105
3105	5	3105
3105	5	3105


************************



A Language Extension for Expressing Constraints on Data Access

Controlled sharing of information is needed and
desirable for many applications and is supported 
in operating systems by access control mechanisms.  This
paper shows how to extend programming languages 
to provide controlled sharing.  The extension permits
expression of access constraints on shared data. 
 Access constraints can apply both to simple objects, and
to objects <B>that a</B>re components of larger objects, 
such as bank account records in a bank's data base.
 The constraints are stated declaratively, and can 
be enforced by static checking similar to type checking.
 The approach can be used to extend any strongly-typed 
language, but is particularly suitable for extending
languages that support the notion of abstract data 
types. 

CACM May, 1978

Jones, A.
Liskov,B.

Programming languages, access control, data types,
abstract data types, type checking, capabilities

4.20 4.35

CA780502 DH February 26, 1979  3:19 PM

1458	4	3105
1523	4	3105
1603	4	3105
1698	4	3105
1747	4	3105
1748	4	3105
1854	4	3105
1877	4	3105
1960	4	3105
2377	4	3105
2378	4	3105
2497	4	3105
2558	4	3105
2625	4	3105
2626	4	3105
2632	4	3105
2840	4	3105
2868	4	3105
2868	4	3105
2870	4	3105
2876	4	3105
2941	4	3105
3031	4	3105
3105	4	3105
3105	4	3105
3105	4	3105
3105	4	3105
3105	4	3105
3105	4	3105
3144	4	3105
3144	4	3105
3144	4	3105
3148	4	3105
3150	4	3105
1471	5	3105
2625	5	3105
2632	5	3105
2868	5	3105
2939	5	3105
3068	5	3105
3105	5	3105
3105	5	3105
3105	5	3105


************************

************************
Document:  CACM-2705.html
************************


Programming Languages, Natural Languages, and Mathematics

Some social aspects of programming are illuminated
through analogies with similar aspects of 
mathematics and natural languages.  The split between
pure and applied mathematics is found similarly 
in programming. The development of natural languages toward
flexion less, word-order based language types 
speaks for programming language design based on general,
abstract constructs.  By analogy with incidents 
of the history <B>of a</B>rtificial, auxiliary languages it
is suggested that Fortran and Cobol will remain 
dominant for a long time to come.  The most promising
avenues for further work of wide influence are 
seen to be high quality program literature (i.e. programs)
of general utility and studies of questions 
related to program style.

CACM December, 1975

Naur, P.

analogies related to social aspects,pure and applied
mathematics, language quality, language development, 
artificial auxiliary languages, literature, style,
descriptive and prescriptive attitudes

4.20

CA751202 JB January 6, 1978  8:30 AM

2705	4	2705
2705	4	2705
2984	4	2705
3101	4	2705
1908	5	2705
2705	5	2705
2705	5	2705
2705	5	2705
3185	5	2705


************************

************************
Document:  CACM-0321.html
************************


ALGOL 60 Confidential

The ALGOL 60 Report,* when first encountered,
seems to describe a very complex language which 
will be difficult to learn.  The "metalinguistic formulae"
admirably serve the purpose of precisely specifying 
a language, but they are certainly not very readable
for a beginner.  However, experience has shown that 
once the report is explained it is in fact easy to learn
ALGOL and to write algorithms in it.  The language 
is so general and powerful it can handle an enormous
class of problems.  It is not hard to learn those 
parts of ALGOL present in other compiler languages: how
to write assignment and go to and for statements, 
etc.  Indeed, a lot of the unnecessary restrictions
imposed by other compiling languages have finally 
been lifted.  But ALGOL also allows many unobvious things
to be written, as we will see later, and herein 
lies a problem: ALGOL seems to have become too general.
 So many restrictions have been lifted <B>that a</B> 
lot of technical details crop up which are hard to learn
and to use correctly.  In this paper some of 
the more obscure features of the language are considered
and their usefulness is discussed.  Remarks 
are based on the authors' interpretations of the ALGOL 60 Report.

CACM June, 1961

Knuth, D. E.
Merner, J. N.

CA610604 JB March 16, 1978  10:48 PM

249	4	321
254	4	321
272	4	321
1102	4	321
1109	4	321
1140	4	321
1188	4	321
1234	4	321
1234	4	321
1306	4	321
1464	4	321
1491	4	321
1767	4	321
1781	4	321
1787	4	321
1949	4	321
321	4	321
321	4	321
321	4	321
321	4	321
2059	4	321
2126	4	321
435	4	321
437	4	321
463	4	321
483	4	321
491	4	321
2732	4	321
560	4	321
583	4	321
3073	4	321
627	4	321
631	4	321
632	4	321
642	4	321
644	4	321
653	4	321
680	4	321
761	4	321
762	4	321
763	4	321
123	4	321
140	4	321
919	4	321
989	4	321
196	5	321
1234	5	321
254	5	321
321	5	321
321	5	321
321	5	321
400	5	321
401	5	321
402	5	321
196	6	321
944	6	321
321	6	321
321	6	321
385	6	321
387	6	321
400	6	321
402	6	321
404	6	321
3184	6	321
729	6	321


************************



ALGOL 60 Confidential

The ALGOL 60 Report,* when first encountered,
seems to describe a very complex language which 
will be difficult to learn.  The "metalinguistic formulae"
admirably serve the purpose of precisely specifying 
a language, but they are certainly not very readable
for a beginner.  However, experience has shown that 
once the report is explained <B>it is</B> in fact easy to learn
ALGOL and to write algorithms in it.  The language 
is so general and powerful it can handle an enormous
class of problems.  It is not hard to learn those 
parts of ALGOL present in other compiler languages: how
to write assignment and go to and for statements, 
etc.  Indeed, a lot of the unnecessary restrictions
imposed by other compiling languages have finally 
been lifted.  But ALGOL also allows many unobvious things
to be written, as we will see later, and herein 
lies a problem: ALGOL seems to have become too general.
 So many restrictions have been lifted that a 
lot of technical details crop up which are hard to learn
and to use correctly.  In this paper some of 
the more obscure features of the language are considered
and their usefulness is discussed.  Remarks 
are based on the authors' interpretations of the ALGOL 60 Report.

CACM June, 1961

Knuth, D. E.
Merner, J. N.

CA610604 JB March 16, 1978  10:48 PM

249	4	321
254	4	321
272	4	321
1102	4	321
1109	4	321
1140	4	321
1188	4	321
1234	4	321
1234	4	321
1306	4	321
1464	4	321
1491	4	321
1767	4	321
1781	4	321
1787	4	321
1949	4	321
321	4	321
321	4	321
321	4	321
321	4	321
2059	4	321
2126	4	321
435	4	321
437	4	321
463	4	321
483	4	321
491	4	321
2732	4	321
560	4	321
583	4	321
3073	4	321
627	4	321
631	4	321
632	4	321
642	4	321
644	4	321
653	4	321
680	4	321
761	4	321
762	4	321
763	4	321
123	4	321
140	4	321
919	4	321
989	4	321
196	5	321
1234	5	321
254	5	321
321	5	321
321	5	321
321	5	321
400	5	321
401	5	321
402	5	321
196	6	321
944	6	321
321	6	321
321	6	321
385	6	321
387	6	321
400	6	321
402	6	321
404	6	321
3184	6	321
729	6	321


************************

************************
Document:  CACM-2956.html
************************


Some Ideas on Data Types in High-Level Languages

A number of issues are explored concerning the
notion that a data type is a set of values together 
with a set of primitive operations on those values.  Among
these are the need for a notation for iterating 
over the elements <B>of a</B>ny finite set (instead of the
more narrow for i:= 1 to n notation), the use of 
the domain of an array as a data type, the need for
a simple notation for allowing types of parameters 
to be themselves parameters (but in a restrictive fashion),
and resulting problems with conversion of 
values from one type to another.

CACM June, 1977

Gries, D.
Gehani, N.

data types, generic procedures, programming languages

4.12 4.20 4.22

CA770607 JB December 28, 1977  1:27 PM

2167	4	2956
2723	4	2956
2941	4	2956
2956	4	2956
2956	4	2956
3030	4	2956
1379	5	2956
2651	5	2956
2956	5	2956
2956	5	2956
2956	5	2956
3049	5	2956
2956	6	2956
2958	6	2956
2957	6	2956
2960	6	2956


************************



Some Ideas on <B>Data Types</B> in High-Level Languages

A number of issues are explored concerning the
notion that a data type is a set of values together 
with a set of primitive operations on those values.  Among
these are the need for a notation for iterating 
over the elements of any finite set (instead of the
more narrow for i:= 1 to n notation), the use of 
the domain of an array as a data type, the need for
a simple notation for allowing types of parameters 
to be themselves parameters (but in a restrictive fashion),
and resulting problems with conversion of 
values from one type to another.

CACM June, 1977

Gries, D.
Gehani, N.

data types, generic procedures, programming languages

4.12 4.20 4.22

CA770607 JB December 28, 1977  1:27 PM

2167	4	2956
2723	4	2956
2941	4	2956
2956	4	2956
2956	4	2956
3030	4	2956
1379	5	2956
2651	5	2956
2956	5	2956
2956	5	2956
2956	5	2956
3049	5	2956
2956	6	2956
2958	6	2956
2957	6	2956
2960	6	2956


************************



Some Ideas on Data Types in High-Level Languages

A number of issues are explored concerning the
notion <B>that a</B> data type is a set of values together 
with a set of primitive operations on those values.  Among
these are the need for a notation for iterating 
over the elements of any finite set (instead of the
more narrow for i:= 1 to n notation), the use of 
the domain of an array as a data type, the need for
a simple notation for allowing types of parameters 
to be themselves parameters (but in a restrictive fashion),
and resulting problems with conversion of 
values from one type to another.

CACM June, 1977

Gries, D.
Gehani, N.

data types, generic procedures, programming languages

4.12 4.20 4.22

CA770607 JB December 28, 1977  1:27 PM

2167	4	2956
2723	4	2956
2941	4	2956
2956	4	2956
2956	4	2956
3030	4	2956
1379	5	2956
2651	5	2956
2956	5	2956
2956	5	2956
2956	5	2956
3049	5	2956
2956	6	2956
2958	6	2956
2957	6	2956
2960	6	2956


************************

************************
Document:  CACM-1413.html
************************


A Vision of Technology and Education

Educational technology is currently quite
fashionable.  Here, as in many other branches or 
aspects of technology, changes possible in the next generation
or two are now known as ideas, discoveries 
or inventions.  The unknown is whether the potential
will become the actual and, if so, on what time 
scale.  This ignorance stems largely from ignorance about
the social response to potential technological 
change.  The object of this paper is to present a vision
of potential educational technology and to raise 
<B>questions about</B> the modes of social response and
adaptation likely to be evoked by such a vision.

CACM July, 1966

Oettinger, A. G.

CA660701 JB March 3, 1978  8:38 AM

1413	4	1413
1413	4	1413
1654	4	1413
1771	4	1413
1902	4	1413
2478	4	1413
1205	5	1413
1270	5	1413
1413	5	1413
1413	5	1413
1413	5	1413


************************

************************
Document:  CACM-1145.html
************************


GIT-A Heuristic Program for Testing Pairs
of Directed Line Graphs for Isomorphism*

Given a pair of directed line graphs, the problem
of ascertaining whether or not they are isomorphic 
is one for which no efficient algorithmic solution is known.
 Since a straightforward enumerative algorithm 
might require 40 years of running time on a very high
speed computer in order to compare two 15-node 
graphs, a more sophisticated approach seems called
for.  The situation is similar to that prevailing 
in areas such as game-playing and theorem-proving, where
practical algorithms are unknown (for the interesting 
cases), but where various practical though only partially
successful techniques are available.  Git-Graph 
Isomorphism Tester-incorporates a variety of processes
<B>that a</B>ttempt to narrow down the search for an 
isomorphism, or to demonstrate that none exists.  No one
scheme is relied upon exclusively for a solution, 
and the program is designed to avoid excessive computation
along fruitless lines.  GIT has been written 
in the COMIT language and successfully tested on the IBM 7090.

CACM January, 1964

Unger, S. H.

CA640110 JB March 10, 1978  5:24 AM

1145	4	1145
1145	5	1145
1145	5	1145
1145	5	1145
1504	5	1145
3040	5	1145
655	5	1145
1145	6	1145
1145	6	1145


************************



GIT-A Heuristic Program for Testing Pairs
of Directed Line Graphs for Isomorphism*

Given a pair of directed line graphs, the problem
of ascertaining whether or not they are isomorphic 
is one for which no efficient algorithmic solution is known.
 Since a straightforward enumerative algorithm 
might require 40 years of running time on a very high
speed computer in order to compare two 15-node 
graphs, a more sophisticated approach seems called
for.  The situation is similar to that prevailing 
in areas such as game-playing and theorem-proving, where
practical algorithms are unknown (for the interesting 
cases), but where various practical though only partially
successful techniques are available.  Git-Graph 
Isomorphism Tester-incorporates a variety of processes
that attempt to narrow down the search for an 
isomorphism, or to demonstrate that none exists.  No one
scheme is relied upon exclusively for a solution, 
and the program is designed <B>to avoid</B> excessive computation
along fruitless lines.  GIT has been written 
in the COMIT language and successfully tested on the IBM 7090.

CACM January, 1964

Unger, S. H.

CA640110 JB March 10, 1978  5:24 AM

1145	4	1145
1145	5	1145
1145	5	1145
1145	5	1145
1504	5	1145
3040	5	1145
655	5	1145
1145	6	1145
1145	6	1145


************************



GIT-A Heuristic Program for Testing Pairs
of Directed Line Graphs for Isomorphism*

Given a pair of directed line graphs, the problem
<B>of a</B>scertaining whether or not they are isomorphic 
is one for which no efficient algorithmic solution is known.
 Since a straightforward enumerative algorithm 
might require 40 years of running time on a very high
speed computer in order to compare two 15-node 
graphs, a more sophisticated approach seems called
for.  The situation is similar to that prevailing 
in areas such as game-playing and theorem-proving, where
practical algorithms are unknown (for the interesting 
cases), but where various practical though only partially
successful techniques are available.  Git-Graph 
Isomorphism Tester-incorporates a variety of processes
that attempt to narrow down the search for an 
isomorphism, or to demonstrate that none exists.  No one
scheme is relied upon exclusively for a solution, 
and the program is designed to avoid excessive computation
along fruitless lines.  GIT has been written 
in the COMIT language and successfully tested on the IBM 7090.

CACM January, 1964

Unger, S. H.

CA640110 JB March 10, 1978  5:24 AM

1145	4	1145
1145	5	1145
1145	5	1145
1145	5	1145
1504	5	1145
3040	5	1145
655	5	1145
1145	6	1145
1145	6	1145


************************

************************
Document:  CACM-2957.html
************************


Database Abstractions: Aggregation

Aggregation is in troduced as an abstraction
which is important in conceptualizing the real 
world.  Aggregation transforms a relationship between
objects into a higher-level object.  A new data 
type, called aggregation, is developed which, under
certain criteria of "well-definedness," specifies 
aggregation abstractions.  Relational databases defined
as collections <B>of a</B>ggregates are structured as 
a hierarchy on n-ary relations.  To main tain well-definedness,
update operations on such databases must 
preserve two invariants.  Well-defined relations are
distinct from relations in third normal form.  It 
is shown that these notions are complementary and both are
important in database design.  A top-down 
methodology for database design is described which separates
decisions concerning aggregate structure 
from decisions concerning key identification.  It is
suggested that aggregate types, and other types 
which support real-world abstractions without in troducing
implementation detail, should be incorporated 
into programming languages.

CACM June, 1977

Smith, J. M.
Smith, D. C. P.

data abstraction, relational database, data type,
aggregation, database design, data structure, 
knowledge representation, data definition language

3.65 3.69 3.79 4.29 4.33 4.34

CA770606 JB December 29, 1977  12:33 AM

2155	4	2957
2406	4	2957
2710	4	2957
2715	4	2957
2716	4	2957
2717	4	2957
2718	4	2957
2765	4	2957
2817	4	2957
2888	4	2957
2901	4	2957
2957	4	2957
2959	4	2957
2965	4	2957
3087	4	2957
3154	4	2957
2046	5	2957
2957	5	2957
2957	5	2957
2957	5	2957
3049	5	2957
2956	6	2957
2958	6	2957
2957	6	2957
2960	6	2957


************************



Database Abstractions: Aggregation

Aggregation is in troduced as an abstraction
which is important in conceptualizing the real 
world.  Aggregation transforms a relationship between
objects into a higher-level object.  A new data 
type, called aggregation, is developed which, under
certain criteria of "well-definedness," specifies 
aggregation abstractions.  Relational databases defined
as collections of aggregates are structured as 
a hierarchy on n-ary relations.  To main tain well-definedness,
update operations on such databases must 
preserve two invariants.  Well-defined relations are
distinct from relations in third normal form.  It 
is shown that these notions are complementary and both are
important in database design.  A top-down 
methodology for database design is described which separates
decisions concerning aggregate structure 
from decisions concerning key identification.  It is
suggested <B>that a</B>ggregate types, and other types 
which support real-world abstractions without in troducing
implementation detail, should be incorporated 
into programming languages.

CACM June, 1977

Smith, J. M.
Smith, D. C. P.

data abstraction, relational database, data type,
aggregation, database design, data structure, 
knowledge representation, data definition language

3.65 3.69 3.79 4.29 4.33 4.34

CA770606 JB December 29, 1977  12:33 AM

2155	4	2957
2406	4	2957
2710	4	2957
2715	4	2957
2716	4	2957
2717	4	2957
2718	4	2957
2765	4	2957
2817	4	2957
2888	4	2957
2901	4	2957
2957	4	2957
2959	4	2957
2965	4	2957
3087	4	2957
3154	4	2957
2046	5	2957
2957	5	2957
2957	5	2957
2957	5	2957
3049	5	2957
2956	6	2957
2958	6	2957
2957	6	2957
2960	6	2957


************************

************************
Document:  CACM-3162.html
************************


On Improving the Worst Case Running Time
of the Boyer-Moore String Matching Algorithm

It is shown <B>how to</B> modify the Boyer-Moore string matching algorithm so that
its worst case running time is linear even when multiple occurrences of the 
pattern are present in the text.

CACM September, 1979

Galil, Z.

Computational complexity, linear time, worst case, string matching, periodicity

3.74 4.40 5.25

CA790903 DB January 14, 1980  10:27 AM

3162	4	3162
2916	5	3162
3162	5	3162
3162	5	3162
3162	5	3162


************************

************************
Document:  CACM-2184.html
************************


On the Meaning of Names in Programming Systems

It is assumed that there is a similarity of
function between the data names of a programming 
language and the file names of an operating system.
 The two functions are discussed in terms of the 
same basic concepts in order to identify the extent
to which they overlap. It is suggested that there 
is some similarity between the idea of a file directory
and a storable object of type context.  Manipulations 
with contexts are then discussed at length.  It is noted
that there is a simple extension of Church's 
Lambda notation that deals nicely with these ideas of
context manipulation.  Whereas a function can be 
regarded as the abstraction based upon the first two terms of
the expression Lambda(name list)(expression)(value list), 
<B>it is</B> found that a context can be viewed as an abstraction
based upon the first two terms in the equivalent 
expression Mu(name list)(value list)(expression).

CACM July, 1971

Fraser, A. G.

file, operating system, programming language, functions,
names, context, file directory, file dictionary, 
lambda calculus, theory of programming

3.73 4.22 4.39 5.23 5.24

CA710606 JB February 3, 1978  9:58 AM

2184	5	2184
2184	5	2184
2184	5	2184


************************



On the Meaning of Names in Programming Systems

It is assumed that there is a similarity of
function between the data names <B>of a</B> programming 
language and the file names of an operating system.
 The two functions are discussed in terms of the 
same basic concepts in order to identify the extent
to which they overlap. It is suggested that there 
is some similarity between the idea of a file directory
and a storable object of type context.  Manipulations 
with contexts are then discussed at length.  It is noted
that there is a simple extension of Church's 
Lambda notation that deals nicely with these ideas of
context manipulation.  Whereas a function can be 
regarded as the abstraction based upon the first two terms of
the expression Lambda(name list)(expression)(value list), 
it is found that a context can be viewed as an abstraction
based upon the first two terms in the equivalent 
expression Mu(name list)(value list)(expression).

CACM July, 1971

Fraser, A. G.

file, operating system, programming language, functions,
names, context, file directory, file dictionary, 
lambda calculus, theory of programming

3.73 4.22 4.39 5.23 5.24

CA710606 JB February 3, 1978  9:58 AM

2184	5	2184
2184	5	2184
2184	5	2184


************************



On the Meaning of Names in Programming Systems

It is assumed that there is a similarity of
function between the data names of a programming 
language and the file names of an operating system.
 The two functions are discussed in terms of the 
same basic concepts in order to identify the extent
to which they overlap. It is suggested that there 
is some similarity between the idea of a file directory
and a storable object of type context.  Manipulations 
with contexts are then discussed at length.  It is noted
that there is a simple extension of Church's 
Lambda notation that deals nicely with these ideas of
context manipulation.  Whereas a function can be 
regarded as the abstraction based upon the first two terms of
the expression Lambda(name list)(expression)(value list), 
it is found <B>that a</B> context can be viewed as an abstraction
based upon the first two terms in the equivalent 
expression Mu(name list)(value list)(expression).

CACM July, 1971

Fraser, A. G.

file, operating system, programming language, functions,
names, context, file directory, file dictionary, 
lambda calculus, theory of programming

3.73 4.22 4.39 5.23 5.24

CA710606 JB February 3, 1978  9:58 AM

2184	5	2184
2184	5	2184
2184	5	2184


************************

************************
Document:  CACM-1698.html
************************


A Statistical Model for Console Behavior in Multiuser Computers

The ability of a computer system to communicate
with the outside world efficiently is as important 
as its ability to perform computations efficiently. 
It is quite difficult to characterize a particular 
user, but rather easy to characterize the entire user community.
 Based on the properties of this community 
we have postulated a hypothetical "virtual console."
 No claim is made <B>that a</B> virtual console behaves 
like any actual console, but the entire collection of
virtual consoles models the collection of actual 
consoles.  Using the model we answer questions like: 
How many processes are suspended waiting for console 
input?  What is the maximum rate at which a process can
execute?  What bounds can be set on overall buffer 
requirements?  Answers to these and similar questions
are needed in certain aspects of operating system 
design.

CACM September, 1968

Denning, P. J.

statistical models for input-output, operating
system design, input-output design

4.30 4.41 5.5

CA680903 JB February 22, 1978  9:21 AM

1458	4	1698
1523	4	1698
1603	4	1698
1698	4	1698
1747	4	1698
1748	4	1698
1854	4	1698
1877	4	1698
1960	4	1698
2377	4	1698
2378	4	1698
2497	4	1698
2558	4	1698
2625	4	1698
2632	4	1698
2840	4	1698
2941	4	1698
3105	4	1698
3144	4	1698
1471	5	1698
1698	5	1698
1698	5	1698
1698	5	1698


************************



A Statistical Model for Console Behavior in Multiuser Computers

The ability of a computer system to communicate
with the outside world efficiently is as important 
as its ability to perform computations efficiently. 
It is quite difficult to characterize a particular 
user, but rather easy to characterize the entire user community.
 Based on the properties of this community 
we have postulated a hypothetical "virtual console."
 No claim is made that a virtual console behaves 
like any actual console, but the entire collection of
virtual consoles models the collection of actual 
consoles.  Using the model we answer questions like: 
How many processes are suspended waiting for console 
input?  <B>What is</B> the maximum rate at which a process can
execute?  What bounds can be set on overall buffer 
requirements?  Answers to these and similar questions
are needed in certain aspects of operating system 
design.

CACM September, 1968

Denning, P. J.

statistical models for input-output, operating
system design, input-output design

4.30 4.41 5.5

CA680903 JB February 22, 1978  9:21 AM

1458	4	1698
1523	4	1698
1603	4	1698
1698	4	1698
1747	4	1698
1748	4	1698
1854	4	1698
1877	4	1698
1960	4	1698
2377	4	1698
2378	4	1698
2497	4	1698
2558	4	1698
2625	4	1698
2632	4	1698
2840	4	1698
2941	4	1698
3105	4	1698
3144	4	1698
1471	5	1698
1698	5	1698
1698	5	1698
1698	5	1698


************************



A Statistical Model for Console Behavior in Multiuser Computers

The ability <B>of a</B> computer system to communicate
with the outside world efficiently is as important 
as its ability to perform computations efficiently. 
It is quite difficult to characterize a particular 
user, but rather easy to characterize the entire user community.
 Based on the properties of this community 
we have postulated a hypothetical "virtual console."
 No claim is made that a virtual console behaves 
like any actual console, but the entire collection of
virtual consoles models the collection of actual 
consoles.  Using the model we answer questions like: 
How many processes are suspended waiting for console 
input?  What is the maximum rate at which a process can
execute?  What bounds can be set on overall buffer 
requirements?  Answers to these and similar questions
are needed in certain aspects of operating system 
design.

CACM September, 1968

Denning, P. J.

statistical models for input-output, operating
system design, input-output design

4.30 4.41 5.5

CA680903 JB February 22, 1978  9:21 AM

1458	4	1698
1523	4	1698
1603	4	1698
1698	4	1698
1747	4	1698
1748	4	1698
1854	4	1698
1877	4	1698
1960	4	1698
2377	4	1698
2378	4	1698
2497	4	1698
2558	4	1698
2625	4	1698
2632	4	1698
2840	4	1698
2941	4	1698
3105	4	1698
3144	4	1698
1471	5	1698
1698	5	1698
1698	5	1698
1698	5	1698


************************



A Statistical Model for Console Behavior in Multiuser Computers

The ability of a computer system to communicate
with the outside world efficiently is as important 
as its ability to perform computations efficiently. 
It is quite difficult to characterize a particular 
user, but rather easy to characterize the entire user community.
 Based on the properties of this community 
we have postulated a hypothetical "virtual console."
 No claim is made that a virtual console behaves 
like any actual console, but the entire collection of
virtual consoles models the collection of actual 
consoles.  Using the model we answer questions like: 
How many processes are suspended waiting for console 
input?  What <B>is the</B> maximum rate at which a process can
execute?  What bounds can be set on overall buffer 
requirements?  Answers to these and similar questions
are needed in certain aspects of operating system 
design.

CACM September, 1968

Denning, P. J.

statistical models for input-output, operating
system design, input-output design

4.30 4.41 5.5

CA680903 JB February 22, 1978  9:21 AM

1458	4	1698
1523	4	1698
1603	4	1698
1698	4	1698
1747	4	1698
1748	4	1698
1854	4	1698
1877	4	1698
1960	4	1698
2377	4	1698
2378	4	1698
2497	4	1698
2558	4	1698
2625	4	1698
2632	4	1698
2840	4	1698
2941	4	1698
3105	4	1698
3144	4	1698
1471	5	1698
1698	5	1698
1698	5	1698
1698	5	1698


************************



A Statistical Model for Console Behavior in Multiuser Computers

The ability of a computer system to communicate
with the outside world efficiently is as important 
as its ability to perform computations efficiently. 
It is quite difficult to characterize a particular 
user, but rather easy to characterize <B>the entire</B> user community.
 Based on the properties of this community 
we have postulated a hypothetical "virtual console."
 No claim is made that a virtual console behaves 
like any actual console, but the entire collection of
virtual consoles models the collection of actual 
consoles.  Using the model we answer questions like: 
How many processes are suspended waiting for console 
input?  What is the maximum rate at which a process can
execute?  What bounds can be set on overall buffer 
requirements?  Answers to these and similar questions
are needed in certain aspects of operating system 
design.

CACM September, 1968

Denning, P. J.

statistical models for input-output, operating
system design, input-output design

4.30 4.41 5.5

CA680903 JB February 22, 1978  9:21 AM

1458	4	1698
1523	4	1698
1603	4	1698
1698	4	1698
1747	4	1698
1748	4	1698
1854	4	1698
1877	4	1698
1960	4	1698
2377	4	1698
2378	4	1698
2497	4	1698
2558	4	1698
2625	4	1698
2632	4	1698
2840	4	1698
2941	4	1698
3105	4	1698
3144	4	1698
1471	5	1698
1698	5	1698
1698	5	1698
1698	5	1698


************************

************************
Document:  CACM-2582.html
************************


Improving Locality by Critical Working Sets

A new approach to program locality improvement
via restructuring is described.  The method 
is particularly suited to those systems where primary memory
is managed according to a working set strategy. 
 It is based on the concept of critical working set, a
working set which does not contain the next memory 
reference.  The data the method operates upon are extracted from
a trace of the program to be restructured. 
 It is shown that, except in some special cases, the
method is not optimum.  However, the experimental 
results obtained by using the method to restructure an
interactive text editor and the file system module 
<B>of a</B>n operating system have shown its substantial superiority
over the other methods proposed in the 
literature.

CACM November, 1974

Ferrari, D.

program restructuring, program segmentation, locality
improvement, memory hierarchies, virtual 
memory, multiprogramming, restructuring techniques, static
restructuring, dynamic restructuring, working 
set strategy, critical working set

4.32 4.39 4.43 4.49 4.9

CA741102 JB January 16, 1978  10:50 AM

1892	4	2582
1901	4	2582
2085	4	2582
2095	4	2582
2218	4	2582
2277	4	2582
2319	4	2582
2319	4	2582
2329	4	2582
2358	4	2582
2365	4	2582
2373	4	2582
2380	4	2582
2434	4	2582
2499	4	2582
2501	4	2582
2582	4	2582
2582	4	2582
2582	4	2582
2582	4	2582
2669	4	2582
2669	4	2582
2828	4	2582
2863	4	2582
2881	4	2582
2928	4	2582
2996	4	2582
3006	4	2582
3054	4	2582
3067	4	2582
3152	4	2582
1751	5	2582
1924	5	2582
2017	5	2582
2130	5	2582
2582	5	2582
2582	5	2582
2582	5	2582


************************

************************
Document:  CACM-3132.html
************************


Experiments with Some Algorithms that Find
Central Solutions for Pattern Classification

In two-class pattern recognition, it is a standard
technique to have an algorithm finding hyperplanes
which separates the two classes in a linearly separable training
set.  The traditional methods find a hyperplane which separates all
points in the other, but such a hyperplane is not necessarily centered
in the empty space between the two classes.  Since a central
hyperplane does not favor one class or the other, it should have
a lower error rate in classifying new points and <B>is the</B>refore better
than a noncentral hyperplane.  Six algorithms for finding central
hyperplanes are tested on three data sets.  Although frequently
used practice, the modified relaxation algorithm is very poor. 
Three algorithms which are defined in the paper are found to be
quite good.

CACM March, 1979

Slagle, J.

Pattern recognition, pattern classification, linear discriminants, central
hyperplanes, centering, centrality criteria, dead zone, hyperplane,
linearly separable, relaxation algorithm, accelerated relaxation

3.62 3.63

CA790303 DH April 12, 1979  3:20 PM

3132	4	3132
2215	5	3132
3132	5	3132
3132	5	3132
3132	5	3132


************************



Experiments with Some Algorithms that Find
Central Solutions for Pattern Classification

In two-class pattern recognition, <B>it is</B> a standard
technique to have an algorithm finding hyperplanes
which separates the two classes in a linearly separable training
set.  The traditional methods find a hyperplane which separates all
points in the other, but such a hyperplane is not necessarily centered
in the empty space between the two classes.  Since a central
hyperplane does not favor one class or the other, it should have
a lower error rate in classifying new points and is therefore better
than a noncentral hyperplane.  Six algorithms for finding central
hyperplanes are tested on three data sets.  Although frequently
used practice, the modified relaxation algorithm is very poor. 
Three algorithms which are defined in the paper are found to be
quite good.

CACM March, 1979

Slagle, J.

Pattern recognition, pattern classification, linear discriminants, central
hyperplanes, centering, centrality criteria, dead zone, hyperplane,
linearly separable, relaxation algorithm, accelerated relaxation

3.62 3.63

CA790303 DH April 12, 1979  3:20 PM

3132	4	3132
2215	5	3132
3132	5	3132
3132	5	3132
3132	5	3132


************************

************************
Document:  CACM-3142.html
************************


Consumer Difficulties With Computerized Transactions: 
An Empirical Investigation

The prevalence with which errors may be encountered by the 
end targets of a computerized process is assessed.  How many and
what <B>type of</B> errors occur?  How easily are they corrected?  What
is the reaction of consumers to errors-to a failure to correct
them?  What can be learned by designers of large management packages
from such data? Results show that with the present state of the
art, approximately 40 percent of individuals (or households) having
average contacts with different types of accounts experience one
or more errors per year.  Eighty percent relate to billing.  Attempts
to correct errors often turned out to be difficult and not always
successful. There appears to be some conflict between computer-using
organizations and their public.  Also the role of poor man
agement packages including poor software is indicated.  While most
management systems may be adequate, results of the survey raise
concerns about the timeliness and the number of designs of very
large linked program packages (as EFT for instance).  

CACM May, 1979

Sterling, T.

Errors, systems errors, billing errors, management systems, consumers

2.0 2.1 2.12 2.2 3.50 3.52 3.55 4.19 4.6

CA790503 DH June 5, 1979  3:21 PM

3142	4	3142
3142	4	3142
3179	4	3142
3178	4	3142
3182	4	3142
3183	4	3142
2583	5	3142
3076	5	3142
3142	5	3142
3142	5	3142
3142	5	3142
3178	5	3142
3076	6	3142
3140	6	3142
3142	6	3142
3179	6	3142
3180	6	3142
3181	6	3142
3182	6	3142


************************



Consumer Difficulties With Computerized Transactions: 
An Empirical Investigation

The prevalence with which errors may be encountered by the 
end targets <B>of a</B> computerized process is assessed.  How many and
what type of errors occur?  How easily are they corrected?  What
is the reaction of consumers to errors-to a failure to correct
them?  What can be learned by designers of large management packages
from such data? Results show that with the present state of the
art, approximately 40 percent of individuals (or households) having
average contacts with different types of accounts experience one
or more errors per year.  Eighty percent relate to billing.  Attempts
to correct errors often turned out to be difficult and not always
successful. There appears to be some conflict between computer-using
organizations and their public.  Also the role of poor man
agement packages including poor software is indicated.  While most
management systems may be adequate, results of the survey raise
concerns about the timeliness and the number of designs of very
large linked program packages (as EFT for instance).  

CACM May, 1979

Sterling, T.

Errors, systems errors, billing errors, management systems, consumers

2.0 2.1 2.12 2.2 3.50 3.52 3.55 4.19 4.6

CA790503 DH June 5, 1979  3:21 PM

3142	4	3142
3142	4	3142
3179	4	3142
3178	4	3142
3182	4	3142
3183	4	3142
2583	5	3142
3076	5	3142
3142	5	3142
3142	5	3142
3142	5	3142
3178	5	3142
3076	6	3142
3140	6	3142
3142	6	3142
3179	6	3142
3180	6	3142
3181	6	3142
3182	6	3142


************************



Consumer Difficulties With Computerized Transactions: 
An Empirical Investigation

The prevalence with which errors may be encountered by the 
end targets of a computerized process is assessed.  How many and
what type of errors occur?  How easily are they corrected?  What
<B>is the</B> reaction of consumers to errors-to a failure to correct
them?  What can be learned by designers of large management packages
from such data? Results show that with the present state of the
art, approximately 40 percent of individuals (or households) having
average contacts with different types of accounts experience one
or more errors per year.  Eighty percent relate to billing.  Attempts
to correct errors often turned out to be difficult and not always
successful. There appears to be some conflict between computer-using
organizations and their public.  Also the role of poor man
agement packages including poor software is indicated.  While most
management systems may be adequate, results of the survey raise
concerns about the timeliness and the number of designs of very
large linked program packages (as EFT for instance).  

CACM May, 1979

Sterling, T.

Errors, systems errors, billing errors, management systems, consumers

2.0 2.1 2.12 2.2 3.50 3.52 3.55 4.19 4.6

CA790503 DH June 5, 1979  3:21 PM

3142	4	3142
3142	4	3142
3179	4	3142
3178	4	3142
3182	4	3142
3183	4	3142
2583	5	3142
3076	5	3142
3142	5	3142
3142	5	3142
3142	5	3142
3178	5	3142
3076	6	3142
3140	6	3142
3142	6	3142
3179	6	3142
3180	6	3142
3181	6	3142
3182	6	3142


************************

************************
Document:  CACM-1143.html
************************


Analysis of Decay-Type Data*

A comparative study has been made <B>of a</B> variety
of numerical techniques for fitting experimental 
data of the decay type by forms involving the sums of
exponentials.  Statistical errors of the fitted 
parameters are also calculated.  These methods have been
applied to artificially-generated sets of data 
as well as to the results of experiments with radioactive
tracers on both human and animal subjects. 
 Results show that the values of the fitted parameters
are very sensitive to variations in the fitting 
procedure.  Therefore great care very sensitive to variations
in the fitting procedure.  Therefore great 
care must be exercised in identifying such values with
physical constants.  Although the values of functions 
derived from these fitted parameters which can definitely
be associated with physical entities are generally 
more stable under variations in the fitting techniques,
error bounds can be so large that no great confidence 
can be placed even in them.  It would therefore appear
best to select a uniform technique both for running 
the experiments and for analyzing the data, and then
to consider as significant only relative results 
between one subject and the next.

CACM January, 1964

Worsley, B. H.

CA640112 JB March 10, 1978 5:11 AM

1143	5	1143
1143	5	1143
1143	5	1143


************************

************************
Document:  CACM-1155.html
************************


Experiments with a Deductive Question-Answering Program

As an investigation in artificial intelligence,
computer experiments on deductive question-answering 
were run with a LISP program called DEDUCOM, an acronym
for DEDUctive COMmunicator. When given 68 facts, 
DEDUCOM answered 10 questions answerable from the facts.
 A fact tells DEDUCOM either some specific information 
or a method of answering a general kind of question.
 Some conclusions drawn in the article are: (1) 
DEDUCOM can answer a wide variety of questions.  (2)
A human can increase the deductive power of DEDUCOM 
by telling it more facts.  (3) DEDUCOM can write very
simple programs (it is hoped that this ability 
<B>is the</B> forerunner of an ability to self-program, which
is a way to learn).  (4)DEDUCOM's search procedure 
at present has two bad defects: some questions answerable
from the given facts cannot be answered and 
some other answerable questions can be answered only if
the relevant facts are given in the "right" order. 
 (6) At present, DEDUCOM's method of making logical deductions
in predicate calculus has two bad defects: 
some facts have to be changed to logically equivalent ones
before being given to DEDUCOM, and some redundant 
facts have to be given to DEDUCOM.

CACM December, 1965

Slagle, J. R.

CA651214 JB March 6, 1978  3:34 PM

1155	4	1155
1456	4	1155
1468	4	1155
1515	4	1155
1699	4	1155
1856	4	1155
2127	4	1155
1155	5	1155
1155	5	1155
1155	5	1155
1324	5	1155
1515	5	1155
2096	5	1155
2127	5	1155
2210	5	1155
1155	6	1155
1155	6	1155
1155	6	1155
1155	6	1155
1324	6	1155
1324	6	1155
1487	6	1155
1527	6	1155
1781	6	1155
1856	6	1155


************************



Experiments with a Deductive Question-Answering Program

As an investigation in artificial intelligence,
computer experiments on deductive question-answering 
were run with a LISP program called DEDUCOM, an acronym
for DEDUctive COMmunicator. When given 68 facts, 
DEDUCOM answered 10 questions answerable from the facts.
 A fact tells DEDUCOM either some specific information 
or a method <B>of a</B>nswering a general kind of question.
 Some conclusions drawn in the article are: (1) 
DEDUCOM can answer a wide variety of questions.  (2)
A human can increase the deductive power of DEDUCOM 
by telling it more facts.  (3) DEDUCOM can write very
simple programs (it is hoped that this ability 
is the forerunner of an ability to self-program, which
is a way to learn).  (4)DEDUCOM's search procedure 
at present has two bad defects: some questions answerable
from the given facts cannot be answered and 
some other answerable questions can be answered only if
the relevant facts are given in the "right" order. 
 (6) At present, DEDUCOM's method of making logical deductions
in predicate calculus has two bad defects: 
some facts have to be changed to logically equivalent ones
before being given to DEDUCOM, and some redundant 
facts have to be given to DEDUCOM.

CACM December, 1965

Slagle, J. R.

CA651214 JB March 6, 1978  3:34 PM

1155	4	1155
1456	4	1155
1468	4	1155
1515	4	1155
1699	4	1155
1856	4	1155
2127	4	1155
1155	5	1155
1155	5	1155
1155	5	1155
1324	5	1155
1515	5	1155
2096	5	1155
2127	5	1155
2210	5	1155
1155	6	1155
1155	6	1155
1155	6	1155
1155	6	1155
1324	6	1155
1324	6	1155
1487	6	1155
1527	6	1155
1781	6	1155
1856	6	1155


************************



Experiments with a Deductive Question-Answering Program

As an investigation in artificial intelligence,
computer experiments on deductive question-answering 
were run with a LISP program called DEDUCOM, an acronym
for DEDUctive COMmunicator. When given 68 facts, 
DEDUCOM answered 10 questions answerable from the facts.
 A fact tells DEDUCOM either some specific information 
or a method of answering a general kind of question.
 Some conclusions drawn in the article are: (1) 
DEDUCOM can answer a wide variety of questions.  (2)
A human can increase the deductive power of DEDUCOM 
by telling it more facts.  (3) DEDUCOM can write very
simple programs (<B>it is</B> hoped that this ability 
is the forerunner of an ability to self-program, which
is a way to learn).  (4)DEDUCOM's search procedure 
at present has two bad defects: some questions answerable
from the given facts cannot be answered and 
some other answerable questions can be answered only if
the relevant facts are given in the "right" order. 
 (6) At present, DEDUCOM's method of making logical deductions
in predicate calculus has two bad defects: 
some facts have to be changed to logically equivalent ones
before being given to DEDUCOM, and some redundant 
facts have to be given to DEDUCOM.

CACM December, 1965

Slagle, J. R.

CA651214 JB March 6, 1978  3:34 PM

1155	4	1155
1456	4	1155
1468	4	1155
1515	4	1155
1699	4	1155
1856	4	1155
2127	4	1155
1155	5	1155
1155	5	1155
1155	5	1155
1324	5	1155
1515	5	1155
2096	5	1155
2127	5	1155
2210	5	1155
1155	6	1155
1155	6	1155
1155	6	1155
1155	6	1155
1324	6	1155
1324	6	1155
1487	6	1155
1527	6	1155
1781	6	1155
1856	6	1155


************************

************************
Document:  CACM-1346.html
************************


On the Application of the Process of Equalization
of Maxima to Obtain Rational Approximation 
to Certain Modified Bessel Functions

The second Remes algorithm as originally established
for polynomials, may converge or not when 
the approximating functions are rational.  However, the
few results known in this domain show how efficient 
the algorithm can be to obtain approximations with a
small error, much more than in the polynomial case, 
<B>in which</B> the best approximation can be very nearly
approached directly by a series development.  The 
aim of this paper is to investigate the limitations
of the applicability of certain extensions of the 
algorithm to the case where the approximations are rational
as well as to present some numerical results.

CACM December, 1966

Gargantini, L.

CA661204 JB March 2, 1978  2:39 PM

1015	4	1346
1346	4	1346
1346	4	1346
1440	4	1346
1645	4	1346
951	4	1346
951	5	1346
1346	5	1346
1346	5	1346
1346	5	1346
532	5	1346


************************

************************
Document:  CACM-1623.html
************************


An Application of FORMAC

A nonlinear circuit analysis problem is stated
and the way in which it was solved using FORMAC 
is indicated.  The solution of the problem using FORMAC
was notable since several other methods that 
were tried failed.  The problem is straightforward (although
untenable by hand) but nevertheless involved 
an elaborate use of the FORMAC language.  The program
was fairly large and utilized practically every 
command.  In particular, it made extensive use of the
PART command.  Several tricks were necessary in 
order to circumvent some of the shortcomings of the
FORMAC system.  This paper is more concerned with 
the use of programming techniques in FORMAC than with
the actual engineering problem, although readers 
may be <B>interested in</B> the problem because it is stated
in a general (mathematical) sense and could be 
of interest in areas other than circuit analysis.

CACM March, 1967

Neidleman, L. D.

CA670306 JB February 28, 1978  1:27 PM

1623	5	1623
1623	5	1623
1623	5	1623


************************



An Application of FORMAC

A nonlinear circuit analysis problem is stated
and the way <B>in which</B> it was solved using FORMAC 
is indicated.  The solution of the problem using FORMAC
was notable since several other methods that 
were tried failed.  The problem is straightforward (although
untenable by hand) but nevertheless involved 
an elaborate use of the FORMAC language.  The program
was fairly large and utilized practically every 
command.  In particular, it made extensive use of the
PART command.  Several tricks were necessary in 
order to circumvent some of the shortcomings of the
FORMAC system.  This paper is more concerned with 
the use of programming techniques in FORMAC than with
the actual engineering problem, although readers 
may be interested in the problem because it is stated
in a general (mathematical) sense and could be 
of interest in areas other than circuit analysis.

CACM March, 1967

Neidleman, L. D.

CA670306 JB February 28, 1978  1:27 PM

1623	5	1623
1623	5	1623
1623	5	1623


************************



An Application of FORMAC

A nonlinear circuit analysis problem is stated
and the way in which it was solved using FORMAC 
is indicated.  The solution of the problem using FORMAC
was notable since several other methods that 
were tried failed.  The problem is straightforward (although
untenable by hand) but nevertheless involved 
an elaborate use of the FORMAC language.  The program
was fairly large and utilized practically every 
command.  In particular, it made extensive use of the
PART command.  Several tricks were necessary in 
order to circumvent some of the shortcomings of the
FORMAC system.  This paper is more concerned with 
the use of programming techniques in FORMAC than with
the actual engineering problem, although readers 
may be interested in the problem because <B>it is</B> stated
in a general (mathematical) sense and could be 
of interest in areas other than circuit analysis.

CACM March, 1967

Neidleman, L. D.

CA670306 JB February 28, 1978  1:27 PM

1623	5	1623
1623	5	1623
1623	5	1623


************************



An Application of FORMAC

A nonlinear circuit analysis problem is stated
and the way in <B>which it</B> was solved using FORMAC 
is indicated.  The solution of the problem using FORMAC
was notable since several other methods that 
were tried failed.  The problem is straightforward (although
untenable by hand) but nevertheless involved 
an elaborate use of the FORMAC language.  The program
was fairly large and utilized practically every 
command.  In particular, it made extensive use of the
PART command.  Several tricks were necessary in 
order to circumvent some of the shortcomings of the
FORMAC system.  This paper is more concerned with 
the use of programming techniques in FORMAC than with
the actual engineering problem, although readers 
may be interested in the problem because it is stated
in a general (mathematical) sense and could be 
of interest in areas other than circuit analysis.

CACM March, 1967

Neidleman, L. D.

CA670306 JB February 28, 1978  1:27 PM

1623	5	1623
1623	5	1623
1623	5	1623


************************

************************
Document:  CACM-1628.html
************************


The Emergence <B>of a</B> Profession

Computer programming deals with an enormous
variety of activities and is carried on by people 
with a great variety of backgrounds.  It seems clear
that part but not all of this activity is evolving 
toward a distinct professional field, but that the
scope of this emerging profession, and some of its 
economic, social, and educational characteristics are
as yet by no means well defined.  In this paper, 
these issues are examined and some opinions about them are expressed.

CACM March, 1967

Orden, A.

CA670301 JB February 28, 1978  1:47 PM

1628	5	1628
1628	5	1628
1628	5	1628
1770	5	1628
1628	6	1628


************************

************************
Document:  CACM-1469.html
************************


The Next 700 Programming Languages 

A family of unimplemented computing languages
is described that is intended to span differences 
of application area by a unified framework.  This framework
dictates the rules about the uses of user-coined 
names, and the conventions about characterizing functional
relationships.  Within this framework the 
design of a specific language splits into two independent
parts.  One is the choice of written appearances 
of programs (or more generally, their physical representation).
 The other is the choice of the abstract 
entities (such as numbers, character-strings, lists
of them, functional relations among them) that can 
be referred to in the language.  The system is biased
towards "expressions" rather than "statements." 
 It includes a nonprocedural(purely functional) subsystem
<B>that a</B>ims to expand the class of users' needs 
that can be met by a single print-instruction, without sacrificing
the important properties that make 
conventional right-hand-side expressions easy to construct and understand.

CACM March, 1966

Landin, P. J.

CA660303 JB March 3, 1978  2:05 PM

1469	4	1469
1486	4	1469
1491	4	1469
1781	4	1469
2178	4	1469
2326	4	1469
2470	4	1469
2684	4	1469
3044	4	1469
1303	5	1469
1469	5	1469
1469	5	1469
1469	5	1469
2060	5	1469
2294	5	1469
2470	5	1469
3124	5	1469
1303	6	1469
1380	6	1469
1421	6	1469
1469	6	1469
1469	6	1469
1469	6	1469
1469	6	1469
1477	6	1469
1491	6	1469
210	6	1469
1834	6	1469
1869	6	1469
2060	6	1469
2110	6	1469
2264	6	1469


************************



The Next 700 Programming Languages 

A family of unimplemented computing languages
is described that is intended to span differences 
<B>of a</B>pplication area by a unified framework.  This framework
dictates the rules about the uses of user-coined 
names, and the conventions about characterizing functional
relationships.  Within this framework the 
design of a specific language splits into two independent
parts.  One is the choice of written appearances 
of programs (or more generally, their physical representation).
 The other is the choice of the abstract 
entities (such as numbers, character-strings, lists
of them, functional relations among them) that can 
be referred to in the language.  The system is biased
towards "expressions" rather than "statements." 
 It includes a nonprocedural(purely functional) subsystem
that aims to expand the class of users' needs 
that can be met by a single print-instruction, without sacrificing
the important properties that make 
conventional right-hand-side expressions easy to construct and understand.

CACM March, 1966

Landin, P. J.

CA660303 JB March 3, 1978  2:05 PM

1469	4	1469
1486	4	1469
1491	4	1469
1781	4	1469
2178	4	1469
2326	4	1469
2470	4	1469
2684	4	1469
3044	4	1469
1303	5	1469
1469	5	1469
1469	5	1469
1469	5	1469
2060	5	1469
2294	5	1469
2470	5	1469
3124	5	1469
1303	6	1469
1380	6	1469
1421	6	1469
1469	6	1469
1469	6	1469
1469	6	1469
1469	6	1469
1477	6	1469
1491	6	1469
210	6	1469
1834	6	1469
1869	6	1469
2060	6	1469
2110	6	1469
2264	6	1469


************************



The Next 700 Programming Languages 

A family of unimplemented computing languages
is described that is intended to span differences 
of application area by a unified framework.  This framework
dictates the rules about the uses of user-coined 
names, and the conventions about characterizing functional
relationships.  Within this framework the 
design of a specific language splits into two independent
parts.  One <B>is the</B> choice of written appearances 
of programs (or more generally, their physical representation).
 The other is the choice of the abstract 
entities (such as numbers, character-strings, lists
of them, functional relations among them) that can 
be referred to in the language.  The system is biased
towards "expressions" rather than "statements." 
 It includes a nonprocedural(purely functional) subsystem
that aims to expand the class of users' needs 
that can be met by a single print-instruction, without sacrificing
the important properties that make 
conventional right-hand-side expressions easy to construct and understand.

CACM March, 1966

Landin, P. J.

CA660303 JB March 3, 1978  2:05 PM

1469	4	1469
1486	4	1469
1491	4	1469
1781	4	1469
2178	4	1469
2326	4	1469
2470	4	1469
2684	4	1469
3044	4	1469
1303	5	1469
1469	5	1469
1469	5	1469
1469	5	1469
2060	5	1469
2294	5	1469
2470	5	1469
3124	5	1469
1303	6	1469
1380	6	1469
1421	6	1469
1469	6	1469
1469	6	1469
1469	6	1469
1469	6	1469
1477	6	1469
1491	6	1469
210	6	1469
1834	6	1469
1869	6	1469
2060	6	1469
2110	6	1469
2264	6	1469


************************

************************
Document:  CACM-2651.html
************************


The Treatment of <B>Data Types</B> in EL1

In constructing a general purpose programming
language, a key issue is providing a sufficient 
set of data types and associated operations in a manner
that permits both natural problem-oriented notation 
and efficient implementation.  The EL1 language contains
a number of features specifically designed to 
simultaneously satisfy both requirements.  The resulting
treatment of data types includes provision for 
programmer-defined data types data types and generic
routines, programmer control over type conversion, 
and very flexible data type behavior, in a context that
allows efficient compiled code and compact data 
representation.

CACM May, 1974

Wegbreit, B.

data types, modes, mode unions, type conversion,
coercion, generic functions, extensible languages, 
data type definition, data description language, compilation

4.12 4.13 4.22

CA740502 JB January 17, 1978  4:32 PM

2651	5	2651
2651	5	2651
2651	5	2651
2723	5	2651
2941	5	2651
2956	5	2651
3030	5	2651
1379	6	2651
1471	6	2651
1549	6	2651
1749	6	2651
1826	6	2651
210	6	2651
2247	6	2651
2356	6	2651
2356	6	2651
2457	6	2651
2558	6	2651
2651	6	2651
2651	6	2651
2651	6	2651
2651	6	2651
2958	6	2651
2972	6	2651
627	6	2651
731	6	2651


************************

************************
Document:  CACM-0867.html
************************


Least Squares Fitting of Planes to Surfaces Using Dynamic Programming

Dynamic programming has recently been used
by Stone, by Bellman and by Gluss to determine the 
closet fit of broken line segments to a curve in an
interval under the constraint that the number of 
segments is fixed.  In the present paper successive
models are developed to extend the method to the 
fitting of broken plane segments to surfaces z=g(x,y) defined
over certain types of subareas of the (x,y)-space. 
 The first model considers a rectangular area, with
the constraint that the plane segments are defined 
over a grid in the (x,y)-space.  It is then shown how
this model may be incorporated into an algorithm 
that provides successive approximations to optimal fits
for any <B>type of</B> closed area.  Finally, applications 
are briefly described.

CACM April, 1963

Gluss, B.

CA630424 JB March 14, 1978  11:43 AM

497	4	867
867	4	867
867	4	867
317	5	867
497	5	867
867	5	867
867	5	867
867	5	867


************************



Least Squares Fitting of Planes to Surfaces Using Dynamic Programming

Dynamic programming has recently been used
by Stone, by Bellman and by Gluss to determine the 
closet fit of broken line segments to a curve in an
interval under the constraint that the number of 
segments is fixed.  In the present paper successive
models are developed to extend the method to the 
fitting of broken plane segments to surfaces z=g(x,y) defined
over certain types of subareas of the (x,y)-space. 
 The first model considers a rectangular area, with
the constraint that the plane segments are defined 
over a grid in the (x,y)-space.  It <B>is the</B>n shown how
this model may be incorporated into an algorithm 
that provides successive approximations to optimal fits
for any type of closed area.  Finally, applications 
are briefly described.

CACM April, 1963

Gluss, B.

CA630424 JB March 14, 1978  11:43 AM

497	4	867
867	4	867
867	4	867
317	5	867
497	5	867
867	5	867
867	5	867
867	5	867


************************

************************
Document:  CACM-0497.html
************************


Further Remarks on Line Segment Curve-Fitting Using Dynamic Programming

In a recent paper, Bellman showed how dynamic
programming could be used to determine the solution 
to a problem previously considered by Stone.  The problem
comprises the determination, given N, of the 
N points of subdivision <B>of a</B> given interval (a,B) and
the corresponding line segments, that give the 
best least squares fit to a function g(x) in the interval.
 Bellman confined himself primarily to the 
analytical derivation, suggesting briefly, however,
how the solution of the equation derived for each 
particular point of subdivision u(i) could be reduced to
a discrete search.  In this paper, the computational 
procedure is considered more fully, and the similarities
to some of Stone's equations are indicated. 
 It is further shown that an equation for u(i) involving
no minimization may be found.  In addition, 
it is shown how Bellman's method may be applied to the
curve-fitting problem when the additional constraints 
are added that the ends of the line segments must be on the curve.

CACM August, 1962

Gluss, B.

CA620831 JB March 17, 1978  9:19 PM

497	4	497
867	4	497
317	5	497
497	5	497
497	5	497
497	5	497
867	5	497
317	6	497
497	6	497


************************



Further Remarks on Line Segment Curve-Fitting Using Dynamic Programming

In a recent paper, Bellman showed how dynamic
programming could be used to determine the solution 
to a problem previously considered by Stone.  The problem
comprises the determination, given N, of the 
N points of subdivision of a given interval (a,B) and
the corresponding line segments, that give the 
best least squares fit to a function g(x) in the interval.
 Bellman confined himself primarily to the 
analytical derivation, suggesting briefly, however,
how the solution of the equation derived for each 
particular point of subdivision u(i) could be reduced to
a discrete search.  In this paper, the computational 
procedure is considered more fully, and the similarities
to some of Stone's equations are indicated. 
 It is further shown that an equation for u(i) involving
no minimization may be found.  In addition, 
<B>it is</B> shown how Bellman's method may be applied to the
curve-fitting problem when the additional constraints 
are added that the ends of the line segments must be on the curve.

CACM August, 1962

Gluss, B.

CA620831 JB March 17, 1978  9:19 PM

497	4	497
867	4	497
317	5	497
497	5	497
497	5	497
497	5	497
867	5	497
317	6	497
497	6	497


************************



Further Remarks on Line Segment Curve-Fitting Using Dynamic Programming

In a recent paper, Bellman showed how dynamic
programming could be used to determine the solution 
to a problem previously considered by Stone.  The problem
comprises the determination, given N, of the 
N points of subdivision of a given interval (a,B) and
the corresponding line segments, that give the 
best least squares fit to a function g(x) in the interval.
 Bellman confined himself primarily to the 
analytical derivation, suggesting briefly, however,
how the solution of the equation derived for each 
particular point of subdivision u(i) could be reduced to
a discrete search.  In this paper, the computational 
procedure is considered more fully, and the similarities
to some of Stone's equations are indicated. 
 It is further shown <B>that a</B>n equation for u(i) involving
no minimization may be found.  In addition, 
it is shown how Bellman's method may be applied to the
curve-fitting problem when the additional constraints 
are added that the ends of the line segments must be on the curve.

CACM August, 1962

Gluss, B.

CA620831 JB March 17, 1978  9:19 PM

497	4	497
867	4	497
317	5	497
497	5	497
497	5	497
497	5	497
867	5	497
317	6	497
497	6	497


************************

************************
Document:  CACM-2196.html
************************


A Man-Machine Approach Toward Solving the Traveling Salesman Problem

The traveling salesman problem belongs to an
important class of scheduling and routing problems. 
 It is also a subproblem in solving others, such as
the warehouse distribution problem.  It has been 
attacked by many mathematical methods with but meager
success.  Only for special forms of the problem 
or for problems with a moderate number of points can
it be solved exactly, even if very large amounts 
of computer time are used.  Heuristic procedures have
been proposed and tested with only slightly better 
results.  This paper describes a computer aided heuristic
technique which uses only a modest amount of 
computer time in real-time to solve large (100-200)
point problems.  This technique takes advantage of 
both the computer's and the human's problem-solving
abilities.  The computer is not asked to solve the 
problem in a brute force way as in many of today's heuristics,
but <B>it is</B> asked to organize the data for 
the human so that the human can solve the problem easily.
 The technique used in this paper seems to 
point to new directions in the field of man-machine interaction
and in the field of artificial intelligence.

CACM May, 1971

Krolak, P.
Felts, W.
Marble, G.

heuristic procedures, computer-aided heuristic technique,
man-machine interaction, artificial intelligence, 
assignment problem, mask of the assignment, rubber band
tour generator, interaction process, traveling 
salesman problem

3.57 3.66 5.30

CA710503 JB February 3, 1978  3:00 PM

2196	5	2196
2196	5	2196
2196	5	2196


************************



A Man-Machine Approach Toward Solving the Traveling Salesman Problem

The traveling salesman problem belongs to an
important class of scheduling and routing problems. 
 It is also a subproblem in solving others, such as
the warehouse distribution problem.  It has been 
attacked by many mathematical methods with but meager
success.  Only for special forms of the problem 
or for problems with a moderate number of points can
it be solved exactly, even if very large amounts 
of computer time are used.  Heuristic procedures have
been proposed and tested with only slightly better 
results.  This paper describes a computer aided heuristic
technique which uses only a modest amount of 
computer time in real-time to solve large (100-200)
point problems.  This technique takes advantage of 
both the computer's and the human's problem-solving
abilities.  The computer is not asked to solve the 
problem in a brute force way as in many of today's heuristics,
but it is asked to organize the data for 
the human so that the human can solve the problem easily.
 The technique used in this paper seems to 
point to new directions in the field of man-machine interaction
and in the field <B>of a</B>rtificial intelligence.

CACM May, 1971

Krolak, P.
Felts, W.
Marble, G.

heuristic procedures, computer-aided heuristic technique,
man-machine interaction, artificial intelligence, 
assignment problem, mask of the assignment, rubber band
tour generator, interaction process, traveling 
salesman problem

3.57 3.66 5.30

CA710503 JB February 3, 1978  3:00 PM

2196	5	2196
2196	5	2196
2196	5	2196


************************

************************
Document:  CACM-2176.html
************************


Buffer Allocation in Merge-Sorting

A fixed buffer allocation for merge-sorting
is presented here which minimizes the number of 
input-output operations for a given order of merge.
 When sorting on movable arm disks, the number of 
seeks is equal to the number of input-output operations,
and the seek time usually controls the sort 
time.  First some standard terminology is introduced. 
Then the input buffer allocation method is described, 
followed by an analysis of the improvement to be expected
over more conventional allocation.  This analysis 
makes use <B>of a</B> particular distribution function.  An
analysis of a completely different distribution 
is given which yields similar results.  This suggests
that the results do not depend on a particular 
distribution function.  An optimum output buffer size
is also determined.  It is concluded that this 
buffering allocation can significantly reduce the time
of merge sorting on movable arm disks when the 
input data are not random, and that this output buffer
allocation should be used whether the data is 
random or not.

CACM July, 1971

Ferguson, D. E.

file, item, string, merge sort, seek time, gamma distribution function

4.41 5.31

CA710706 JB February 3, 1978  8:41 AM

1638	4	2176
2176	4	2176
2272	4	2176
2176	5	2176
2176	5	2176
2176	5	2176
677	5	2176


************************

************************
Document:  CACM-2480.html
************************


Teaching "About Programming"

This paper presents the goals and organization
<B>of a</B> course about programming designed to provide 
entering students in a graduate program with a cultural
enrichment in their professional lives.  The 
students are expected to have taken at least two programming
courses prior to this one and, therefore, 
to be familiar with at least two programming languages,
both as students and users.  Teaching someone 
how to program is similar to teaching him to play a musical
instrument: neither skill can be taught-they 
must be learned.  However, the teacher still serves
several vital purposes: to present a set of rules 
for producing well-formed utterances; to offer numerous
demonstrations of his own skill; and to function 
as an involved critic.  Finally, the teacher is the
source of information about the process in which 
the student is involved.

CACM July, 1973

Rosin, R. F.

education, programming concepts, professionalism

1.52 2.2 4.22

CA730706 JB January 23, 1978  12:36 PM

2319	4	2480
2480	4	2480
2480	4	2480
2594	4	2480
2709	4	2480
2738	4	2480
2867	4	2480
2939	4	2480
2972	4	2480
3004	4	2480
3030	4	2480
3155	4	2480
3155	4	2480
2204	5	2480
2247	5	2480
2480	5	2480
2480	5	2480
2480	5	2480
3003	5	2480
1659	6	2480
1678	6	2480
1927	6	2480
1945	6	2480
2097	6	2480
2147	6	2480
2163	6	2480
2187	6	2480
2329	6	2480
2345	6	2480
2367	6	2480
2407	6	2480
2478	6	2480
2479	6	2480
2480	6	2480
2538	6	2480


************************



Teaching "About Programming"

This paper presents the goals and organization
of a course about programming designed to provide 
entering students in a graduate program with a cultural
enrichment in their professional lives.  The 
students are expected to have taken at least two programming
courses prior to this one and, therefore, 
to be familiar with at least two programming languages,
both as students and users.  Teaching someone 
how to program is similar to teaching him to play a musical
instrument: neither skill can be taught-they 
must be learned.  However, the teacher still serves
several vital purposes: to present a set of rules 
for producing well-formed utterances; to offer numerous
demonstrations of his own skill; and to function 
as an involved critic.  Finally, the teacher is the
source of information about the process <B>in which</B> 
the student is involved.

CACM July, 1973

Rosin, R. F.

education, programming concepts, professionalism

1.52 2.2 4.22

CA730706 JB January 23, 1978  12:36 PM

2319	4	2480
2480	4	2480
2480	4	2480
2594	4	2480
2709	4	2480
2738	4	2480
2867	4	2480
2939	4	2480
2972	4	2480
3004	4	2480
3030	4	2480
3155	4	2480
3155	4	2480
2204	5	2480
2247	5	2480
2480	5	2480
2480	5	2480
2480	5	2480
3003	5	2480
1659	6	2480
1678	6	2480
1927	6	2480
1945	6	2480
2097	6	2480
2147	6	2480
2163	6	2480
2187	6	2480
2329	6	2480
2345	6	2480
2367	6	2480
2407	6	2480
2478	6	2480
2479	6	2480
2480	6	2480
2538	6	2480


************************



Teaching "About Programming"

This paper presents the goals and organization
of a course about programming designed to provide 
entering students in a graduate program with a cultural
enrichment in their professional lives.  The 
students are expected to have taken at least two programming
courses prior to this one and, therefore, 
to be familiar with at least two programming languages,
both as students and users.  Teaching someone 
<B>how to</B> program is similar to teaching him to play a musical
instrument: neither skill can be taught-they 
must be learned.  However, the teacher still serves
several vital purposes: to present a set of rules 
for producing well-formed utterances; to offer numerous
demonstrations of his own skill; and to function 
as an involved critic.  Finally, the teacher is the
source of information about the process in which 
the student is involved.

CACM July, 1973

Rosin, R. F.

education, programming concepts, professionalism

1.52 2.2 4.22

CA730706 JB January 23, 1978  12:36 PM

2319	4	2480
2480	4	2480
2480	4	2480
2594	4	2480
2709	4	2480
2738	4	2480
2867	4	2480
2939	4	2480
2972	4	2480
3004	4	2480
3030	4	2480
3155	4	2480
3155	4	2480
2204	5	2480
2247	5	2480
2480	5	2480
2480	5	2480
2480	5	2480
3003	5	2480
1659	6	2480
1678	6	2480
1927	6	2480
1945	6	2480
2097	6	2480
2147	6	2480
2163	6	2480
2187	6	2480
2329	6	2480
2345	6	2480
2367	6	2480
2407	6	2480
2478	6	2480
2479	6	2480
2480	6	2480
2538	6	2480


************************



Teaching "About Programming"

This paper presents the goals and organization
of a course about programming designed to provide 
entering students in a graduate program with a cultural
enrichment in their professional lives.  The 
students are expected to have taken at least two programming
courses prior to this one and, therefore, 
to be familiar with at least two programming languages,
both as students and users.  Teaching someone 
how to program is similar to teaching him to play a musical
instrument: neither skill can be taught-they 
must be learned.  However, the teacher still serves
several vital purposes: to present a set of rules 
for producing well-formed utterances; to offer numerous
demonstrations of his own skill; and to function 
as an involved critic.  Finally, the teacher <B>is the</B>
source of information about the process in which 
the student is involved.

CACM July, 1973

Rosin, R. F.

education, programming concepts, professionalism

1.52 2.2 4.22

CA730706 JB January 23, 1978  12:36 PM

2319	4	2480
2480	4	2480
2480	4	2480
2594	4	2480
2709	4	2480
2738	4	2480
2867	4	2480
2939	4	2480
2972	4	2480
3004	4	2480
3030	4	2480
3155	4	2480
3155	4	2480
2204	5	2480
2247	5	2480
2480	5	2480
2480	5	2480
2480	5	2480
3003	5	2480
1659	6	2480
1678	6	2480
1927	6	2480
1945	6	2480
2097	6	2480
2147	6	2480
2163	6	2480
2187	6	2480
2329	6	2480
2345	6	2480
2367	6	2480
2407	6	2480
2478	6	2480
2479	6	2480
2480	6	2480
2538	6	2480


************************

************************
Document:  CACM-1341.html
************************


Levels of Computer Systems

In building current computer systems, we tend
to break them down into "levels" of control, 
command and communication; in using the system, we break
our problems down correspondingly.  The continued 
use of such a structure raises <B>questions about</B> its effects
on the usefulness of future systems, particularly 
with regard to such trends as time sharing, parallel
programming, and, eventually, systems which learn. 
 In this essay some of these questions are posed, and
the general attitude we must take in pursuing the 
problem further is discussed.

CACM December, 1966

Bryant, P.

CA661208 JB March 2, 1978  2:29 PM

1341	5	1341
1341	5	1341
1341	5	1341


************************

************************
Document:  CACM-2305.html
************************


The "Plankalkul" of Konrad Zuse: A Forerunner
of Today's Programming Languages

Plankalkul was an attempt by Korrad Zuse in
the 1940's to devise a notational and conceptual 
system for writing what today is termed a program.  Although
this early approach to a programming language 
did not lead to practical use, the plan is described
here because it contains features <B>that a</B>re standard 
in today's programming languages.  The investigation
is of historical interest; also, it may provide 
insights that would lead to advancements in the state
of the art.  Using modern programming terminology, 
the Plankalkul is presented to the extent it has possible
to reconstruct it from the published literature.

CACM July, 1972

Bauer, F. L.
Wossner, H.

higher programming languages, programming,
theory of programming, history of programming

1.2 4.22 5.29

CA720723 JB January 30, 1978  10:46 AM

2305	5	2305
2305	5	2305
2305	5	2305


************************

************************
Document:  CACM-1536.html
************************


Dynamic Computation of Derivatives

It is shown how Wengert's procedure for computation
of derivatives can be implemented conveniently 
by use of compiler-generated complex addition, subtraction,
and linkage to complex arithmetic subroutines.
 Evaluation <B>of a</B> function and derivative proceed in
parallel, as in Wengert's procedure, but with the 
"imaginary" parts of variables declared complex bearing
the values of the derivatives of the real parts. 
 This technique provides a simple way to compute the
derivatives of a function, without the need for 
deriving and programming the evaluation of
explicit formulas for the derivatives.

CACM September, 1967

Lesk, A. M.

CA670908 JB February 27, 1978  3:11 PM

1028	4	1536
1216	4	1536
1278	4	1536
1347	4	1536
1396	4	1536
1536	4	1536
1029	5	1536
1536	5	1536
1536	5	1536
1536	5	1536


************************

************************
Document:  CACM-2939.html
************************


Abstraction Mechanisms in CLU

CLU is a new programming language designed to support
the use <B>of a</B>bstractions in program construction. 
 Work in programming methodology has led to the realization
that three kinds of abstractions-procedural, 
control, and especially data abstractions-are useful
in the programming process.  Of these, only the 
procedural abstraction is supported well by conventional
languages, through the procedure or subroutine. 
 CLU provides, in addition to procedures, novel linguistic
mechanisms that support the use of data and 
control abstractions.  This paper provides an in troduction
to the abstraction mechanisms in CLU.  By 
means of programming examples, the utility of the three
kinds of abstractions in program construction 
is illustrated, and it is shown how CLU programs may
be written to use and implement abstractions.  The 
CLU library, which permits incremental program development
with complete type checking performed at compile 
time, is also discussed.

CACM August, 1977

Liskov, B.
Snyder, A.
Atkinson, R.
Schaffert, C.

programming languages, data types, data abstractions,
control abstractions, programming methodology, 
separate compilation

4.0 4.12 4.20 4.22

CA770804 JB December 28, 1977  7:49 AM

2319	4	2939
2480	4	2939
2594	4	2939
2709	4	2939
2868	4	2939
2939	4	2939
2939	4	2939
2941	4	2939
2972	4	2939
3155	4	2939
2204	5	2939
2558	5	2939
2939	5	2939
2939	5	2939
2939	5	2939
3031	5	2939
3105	5	2939
3148	5	2939
3150	5	2939
1471	6	2939
1860	6	2939
2060	6	2939
2625	6	2939
2632	6	2939
2704	6	2939
2817	6	2939
2842	6	2939
2865	6	2939
2868	6	2939
2939	6	2939
2939	6	2939
2939	6	2939
2939	6	2939
2940	6	2939
2941	6	2939
2943	6	2939
2958	6	2939
3068	6	2939
3073	6	2939
3073	6	2939
3148	6	2939


************************



Abstraction Mechanisms in CLU

CLU is a new programming language designed to support
the use of abstractions in program construction. 
 Work in programming methodology has led to the realization
that three kinds of abstractions-procedural, 
control, and especially data abstractions-are useful
in the programming process.  Of these, only the 
procedural abstraction is supported well by conventional
languages, through the procedure or subroutine. 
 CLU provides, in addition to procedures, novel linguistic
mechanisms that support the use of data and 
control abstractions.  This paper provides an in troduction
to the abstraction mechanisms in CLU.  By 
means of programming examples, the utility of the three
kinds of abstractions in program construction 
is illustrated, and <B>it is</B> shown how CLU programs may
be written to use and implement abstractions.  The 
CLU library, which permits incremental program development
with complete type checking performed at compile 
time, is also discussed.

CACM August, 1977

Liskov, B.
Snyder, A.
Atkinson, R.
Schaffert, C.

programming languages, data types, data abstractions,
control abstractions, programming methodology, 
separate compilation

4.0 4.12 4.20 4.22

CA770804 JB December 28, 1977  7:49 AM

2319	4	2939
2480	4	2939
2594	4	2939
2709	4	2939
2868	4	2939
2939	4	2939
2939	4	2939
2941	4	2939
2972	4	2939
3155	4	2939
2204	5	2939
2558	5	2939
2939	5	2939
2939	5	2939
2939	5	2939
3031	5	2939
3105	5	2939
3148	5	2939
3150	5	2939
1471	6	2939
1860	6	2939
2060	6	2939
2625	6	2939
2632	6	2939
2704	6	2939
2817	6	2939
2842	6	2939
2865	6	2939
2868	6	2939
2939	6	2939
2939	6	2939
2939	6	2939
2939	6	2939
2940	6	2939
2941	6	2939
2943	6	2939
2958	6	2939
3068	6	2939
3073	6	2939
3073	6	2939
3148	6	2939


************************

************************
Document:  CACM-2867.html
************************


Modularization and Hierarchy in a Family of Operating Systems

This paper describes the design philosophy
used in the construction <B>of a</B> family of operating 
systems. It is shown that the concepts of module and
level do not coincide in a hierarchy of functions. 
 Family members can share much software as a result
of the implementation of run-time modules at the 
lowest system level.

CACM May, 1976

Habermann,A. N.
Flon, L.
Cooprider, L.

incremental machine design, module,
data type, address space, virtual memory

4.0 4.30 4.35

CA760504 JB January 4, 1978  3:33 PM

1828	4	2867
1854	4	2867
1877	4	2867
1960	4	2867
2150	4	2867
2317	4	2867
2319	4	2867
2377	4	2867
2342	4	2867
2376	4	2867
2379	4	2867
2424	4	2867
2482	4	2867
2480	4	2867
2618	4	2867
2632	4	2867
2704	4	2867
2704	4	2867
2723	4	2867
2738	4	2867
2738	4	2867
2740	4	2867
2741	4	2867
2867	4	2867
2867	4	2867
2867	4	2867
3004	4	2867
3030	4	2867
3155	4	2867
3184	4	2867
1749	5	2867
2247	5	2867
2379	5	2867
2867	5	2867
2867	5	2867
2867	5	2867


************************

************************
Document:  CACM-2082.html
************************


Syntax-Directed Documentation For PL 360

The language PL 360, together with its phrase structure grammar, is used as a 
concrete basis for illustrating an idea called syntax-directed documentation. 
This idea is (1) to use the phrase structure <B>of a</B> program to define the 
structure of a formal documentation for that program; (2) to use the syntactic 
types and identifiers in the resulting structure to trigger the automatic
formation of questions to the programmer, whose answers will
become part of that documentation; and (3) to provide automatic storage
and retrieval facilities so that other programmers who want
to understand or modify the program can access the resulting documentation,
which is cross-indexed in various ways by syntactic types
and objects.  A small PL 360 program, already found
in the literature, is worked out as an example.

CACM April, 1970

Mills, H. D.

documentation, syntax analysis, PL 360, enforced documentation,
indexed documentation, automatic interrogation,
phase structured grammar, syntax-directed documentation, syntax processing

3.59 3.79 4.19 4.43

CA700402 JB February 13, 1978  3:28 PM

1542	4	2082
1683	4	2082
1693	4	2082
1781	4	2082
1787	4	2082
1836	4	2082
1945	4	2082
2060	4	2082
2061	4	2082
2082	4	2082
2082	4	2082
2091	4	2082
2152	4	2082
2179	4	2082
2340	4	2082
2356	4	2082
2546	4	2082
2603	4	2082
2698	4	2082
2708	4	2082
2824	4	2082
2982	4	2082
2986	4	2082
3045	4	2082
3093	4	2082
1491	5	2082
2082	5	2082
2082	5	2082
2082	5	2082
2314	5	2082
518	5	2082
1098	6	2082
1626	6	2082
2082	6	2082
2148	6	2082


************************

************************
Document:  CACM-2886.html
************************


Semantic Evaluation from Left to Right

This paper describes attribute grammars and their
use for the definition of programming languages 
and compilers; a formal definition <B>of a</B>ttribute grammars
and a discussion of some of its important aspects 
are included. The paper concentrates on the evaluation
of semantic attributes in a few passes from left 
to right over the derivation tree of a program.  A
condition for an attribute grammar is given which 
assures that the semantics of any program can be evaluated
in a single pass over the derivation tree, 
and an algorithm is discussed which decides how many
passes from left to right are in general necessary, 
given the attribute grammar. These notions are explained
in terms of an example grammar which describes 
the scope rules of Algol 60.  Practical questions, such
as the relative efficiency of different evaluation 
schemes, and the ease of adapting the attribute grammar
of a given programming language to the left-to-right 
evaluation scheme are discussed.

CACM February, 1976

Bochmann, G. V.

attribute grammars, semantics of programming languages,
semantic attributes, left-to-right parsing, 
multipass compilers, semantic evaluation, semantic conditions

4.10 4.20 5.23 5.24

CA760201 JB January 5, 1978  9:54 AM

2886	4	2886
2301	5	2886
2703	5	2886
2886	5	2886
2886	5	2886
2886	5	2886
2886	6	2886


************************

************************
Document:  CACM-0616.html
************************


An Information Algebra - Phase I Report-Language
Structure Group of the CODASYL Development Committee

This report represents the results of the
first phase of the work of the Language Structure 
Group.  The goal of this work is to arrive at a proper
structure for a machine-independent problem-defining 
language, at the systems level of data processing.  The
report is based, for the most part, on a mathematical 
model called "An Information Algebra" developed primarily
by R. Bosak.  It is hoped that this report 
will be read (a) with avid interest by programming language
designers and implementors, and all those 
<B>interested in</B> developing a theoretical approach to data
processing; (b) with interest and understanding 
by professional programmers and systems analysts; and (c)
with appreciation by the businessman-analyst-manager. 
 The authors have not attempted an exhaustive discourse
in this report.  Rather, they have tried to present 
a philosophy to the professional people who are vitally
concerned with providing a working language for 
the systems analyst's use.  They trust that the ideas
in this report will stimulate others to think along 
similar lines.  Questions and comments will be welcomed,
and can be addressed to any of the members of 
the Language Structure Group:  Robert Bosak, System
Development Corporation;  Richard F. Clippinger, 
Honeywell EDP Division;  Carey Dobbs, Remington Rand
Univac Division;  Roy Goldfinger (Chairman), IBM 
Corporation;  Renee B. Jasper, Navy Management Office;
 William Keating, National Cash Register;  George 
Kendrick, General Electric Company;  Jean E. Sammet, IBM Corporation.

CACM April, 1962

CA620401 JB March 20, 1978  2:40 PM

1135	5	616
1136	5	616
2710	5	616
2765	5	616
2888	5	616
2906	5	616
493	5	616
616	5	616
616	5	616
616	5	616
729	5	616
1515	6	616
288	6	616
1936	6	616
1976	6	616
2046	6	616
2046	6	616
2046	6	616
2451	6	616
2452	6	616
2715	6	616
493	6	616
616	6	616
616	6	616
616	6	616
616	6	616
616	6	616
616	6	616
616	6	616
616	6	616
657	6	616


************************

************************
Document:  CACM-1861.html
************************


The MAD Definition Facility

One of the first definition facilities for
higher level languages is described.  Users of the 
language can define new operators and/or data types
into the MAD language, so that their use appears 
as if they were predefined.  Information is given on
how one writes definitions, as well as on much of 
the motivation behind the form <B>in which</B> definitions are
written. Some conclusions are drawn about future 
definitional facilities.

CACM August, 1969

Arden, B. W.
Galler, B. A.
Graham, R. M.

MAD, definitions, operators, macros, higher level language

4.12 4.22

CA690802 JB February 15, 1978  6:07 PM

1134	4	1861
1179	4	1861
1665	4	1861
1693	4	1861
1768	4	1861
1781	4	1861
1787	4	1861
1824	4	1861
1824	4	1861
1825	4	1861
1836	4	1861
1861	4	1861
1861	4	1861
1861	4	1861
2015	4	1861
2110	4	1861
2126	4	1861
2127	4	1861
2187	4	1861
2317	4	1861
2545	4	1861
2698	4	1861
2733	4	1861
1614	5	1861
1781	5	1861
1861	5	1861
1861	5	1861
1861	5	1861
408	5	1861


************************



The MAD Definition Facility

One of the first definition facilities for
higher level languages is described.  Users of the 
language can define new operators and/or data types
into the MAD language, so that their use appears 
as if they were predefined.  Information is given on
<B>how one</B> writes definitions, as well as on much of 
the motivation behind the form in which definitions are
written. Some conclusions are drawn about future 
definitional facilities.

CACM August, 1969

Arden, B. W.
Galler, B. A.
Graham, R. M.

MAD, definitions, operators, macros, higher level language

4.12 4.22

CA690802 JB February 15, 1978  6:07 PM

1134	4	1861
1179	4	1861
1665	4	1861
1693	4	1861
1768	4	1861
1781	4	1861
1787	4	1861
1824	4	1861
1824	4	1861
1825	4	1861
1836	4	1861
1861	4	1861
1861	4	1861
1861	4	1861
2015	4	1861
2110	4	1861
2126	4	1861
2127	4	1861
2187	4	1861
2317	4	1861
2545	4	1861
2698	4	1861
2733	4	1861
1614	5	1861
1781	5	1861
1861	5	1861
1861	5	1861
1861	5	1861
408	5	1861


************************

************************
Document:  CACM-1768.html
************************


A Global Parser for Context-Free Phrase Structure Grammars

An algorithm for analyzing any context-free phrase
structure grammar and for generating a program 
which can then parse any sentence in the language (or
indicate that the given sentence is invalid) is 
described. The parser is of the "top-to-bottom" type
and is recursive . A number of heuristic procedures 
whose purpose is to shorten the basic algorithm by quickly
ascertaining that certain substrings of the 
input sentence cannot correspond to the target nonterminal
symbols are included.  Both the generating 
algorithm and the parser have been implemented in RCA
SNOBOL and have been tested successfully on a number 
<B>of a</B>rtificial grammars and on a subset of ALGOL.  A
number of the routines for extracting data about 
a grammar, such as minimum lengths of N-derivable strings
and possible prefixes, are given and may be 
of interest apart from their application in this particular context.

CACM April, 1968

Unger, S. H.

parser, syntax-directed compiler, context-free
grammars, syntactic analysis, translators

3.42 4.12 5.24

CA680402 JB February 23, 1978  11:27 AM

1350	4	1768
1399	4	1768
1496	4	1768
1659	4	1768
1665	4	1768
1683	4	1768
1768	4	1768
1768	4	1768
1768	4	1768
1781	4	1768
1787	4	1768
1787	4	1768
1824	4	1768
1825	4	1768
1836	4	1768
1861	4	1768
1945	4	1768
1945	4	1768
2015	4	1768
2061	4	1768
2110	4	1768
2110	4	1768
2127	4	1768
2187	4	1768
2317	4	1768
2545	4	1768
2698	4	1768
2733	4	1768
3094	4	1768
1141	5	1768
1265	5	1768
1768	5	1768
1768	5	1768
1768	5	1768
1781	5	1768


************************

************************
Document:  CACM-2989.html
************************


Empirical Evaluation of Some Features
of Instruction Set Processor Architectures

This paper presents methods for empirical evaluation
of features of Instruction Set Processors 
(ISPs).  ISP features are evaluated in terms of the time
used or saved by having or not having the feature. 
 The methods are based on analysis of traces of program
executions.  The concept <B>of a</B> register life is 
in troduced, and used to answer questions like: How many
registers are used simultaneously? How many would 
be sufficient all of the time? Most of the time? What
would the overhead be if the number of registers 
were reduced? What are registers used for during their
lives? The paper also discusses the problem of 
detecting desirable but non-existing instructions. Other
problems are briefly discussed.  Experimental 
results are presented, obtained by analyzing 41
programs running on the DEC system 10 ISP.

CACM March, 1977

Lunde, A.

computer architecture, program behavior, instruction
sets, op code utilization, register structures, 
register utilization, simultaneous register
lives, instruction tracing, execution time

6.20 6.21 6.33

CA770303 JB December 30, 1977  1:00 AM

1653	4	2989
2411	4	2989
2709	4	2989
2889	4	2989
2937	4	2989
2989	4	2989
2989	4	2989
3005	4	2989
3025	4	2989
3101	4	2989
1069	5	2989
2138	5	2989
2989	5	2989
2989	5	2989
2989	5	2989
3025	5	2989
2138	6	2989
2989	6	2989


************************

************************
Document:  CACM-1637.html
************************


Problems in the Statistical Analysis of Simulation
Experiments: The Comparison of Means and the 
Length of Sample Records

Research is continued into statistical analysis
of simulation experiments containing autocorrelated 
time series.  It is shown <B>how to</B> estimate the lengths
of sample records needed to use certain large sample 
results in measuring stability.  Analogies between autocorrelated
data and independent observations are 
described.  A way to test the difference of the mean
of two experiments is suggested.  It is shown how 
the variance of the sample mean relates to the spectrum
of the generating process, and estimation of 
the quantities of interest is described. The results
expand the possibilities of statistical spectral 
analysis as applied to simulation experiments.

CACM February, 1967

Fishman, G. S.

CA670205 JB February 28, 1978  3:34 PM

1637	5	1637
1637	5	1637
1637	5	1637


************************

************************
Document:  CACM-2265.html
************************


A Model for Type Checking

Most current programming languages treat computation
over different classes of objects (e.g. 
numbers, strings, labels and functions).  For correct
compilation and execution, the following question 
then arises: is a program properly constructed so that
its operations and operands are compatible?  The 
activity <B>of a</B>nswering this question is usually called
type checking.  This paper attempts to isolate 
the notion of type checking and presents a partial
solution to the type checking problem based on the 
notions of abstraction and application of functions. 
In particular, a program is mapped into an expression 
within a decidable subset of the Lambda calculus, which
characterizes the type relations within the program 
and eliminates all other information.  The determination
of the type-wise correctness or incorrectness 
of the program is resolved by reducing its corresponding
Lambda calculus expression to one of two normal 
forms, the constant "correct" for a type-wise correct
program or the constant "error".  An application 
to type checking in Algol 60 is made, and the attendant
problems faced for any notion of type checking 
are discussed.

CACM November, 1972

Ledgard, H. F.

type checking, types, Lambda calculus, models for
programming languages, syntax, semantics, compiler 
writing, language implementation, formal definition

4.12 4.22 5.2 5.21 5.23

CA721104 JB January 27, 1978  2:30 PM

2265	5	2265
2265	5	2265
2265	5	2265


************************



A Model for Type Checking

Most current programming languages treat computation
over different classes of objects (e.g. 
numbers, strings, labels and functions).  For correct
compilation and execution, the following question 
then arises: is a program properly constructed so that
its operations and operands are compatible?  The 
activity of answering this question is usually called
type checking.  This paper attempts to isolate 
the notion of type checking and presents a partial
solution to <B>the type</B> checking problem based on the 
notions of abstraction and application of functions. 
In particular, a program is mapped into an expression 
within a decidable subset of the Lambda calculus, which
characterizes the type relations within the program 
and eliminates all other information.  The determination
of the type-wise correctness or incorrectness 
of the program is resolved by reducing its corresponding
Lambda calculus expression to one of two normal 
forms, the constant "correct" for a type-wise correct
program or the constant "error".  An application 
to type checking in Algol 60 is made, and the attendant
problems faced for any notion of type checking 
are discussed.

CACM November, 1972

Ledgard, H. F.

type checking, types, Lambda calculus, models for
programming languages, syntax, semantics, compiler 
writing, language implementation, formal definition

4.12 4.22 5.2 5.21 5.23

CA721104 JB January 27, 1978  2:30 PM

2265	5	2265
2265	5	2265
2265	5	2265


************************

************************
Document:  CACM-2400.html
************************


Use of the Hough Transformation ToDetect Lines and Curves in Pictures

Hough has proposed an interesting and computationally
efficient procedure for detecting lines 
in pictures.  This paper points out that the use <B>of a</B>ngle-radius
rather than slope-intercept parameters 
simplifies the computation further.  It also shows
how the method can be used for more general curve 
fitting, and gives alternative interpretations
that explain the source of its efficiency.

CACM January, 1972

Duda, R. O.
Hart, P. E.

picture processing, pattern recognition, line detection,
curve detection, colinear points, point-line 
transformation, Hough transformation

3.63

CA720103 JB February 1, 1978  9:36 AM

2400	5	2400
2400	5	2400
2400	5	2400
2788	5	2400
2910	5	2400
2400	6	2400
2400	6	2400
2788	6	2400


************************

************************
Document:  CACM-0492.html
************************


Analysis <B>of a</B> File Addressing Method

This paper presents a new file addressing method
based on the calculation of an address from 
the identification of a record.  For large recirculating
type files, it seems to be more advantageous 
than customary ones.  The probability distribution of
the displacement of records from their calculated 
address, which is one less than the number of probes
required to address a record, is computed on the 
basis of a Markov chain model.  For the reader not interested
in the mathematics, the introduction and 
the summary should be sufficient.

CACM August, 1962

Schay Jr., G.
Spruth, W. G.

CA620836 JB March 17, 1978  9:02 PM

911	5	492
1785	5	492
2203	5	492
2860	5	492
492	5	492
492	5	492
492	5	492
911	6	492
911	6	492
1328	6	492
1785	6	492
1786	6	492
332	6	492
332	6	492
2107	6	492
2109	6	492
2203	6	492
492	6	492
492	6	492
492	6	492
492	6	492


************************

************************
Document:  CACM-2624.html
************************


Formal Requirements for Virtualizable Third Generation Architectures

Virtual machine systems have been implemented
on a limited number of third generation computer 
systems, e.g. CP-67 on the IBM 360/67.  From previous
empirical studies, it is known that certain third 
generation computer systems, e.g. the DEC PDP-10, cannot
support a virtual machine system.  In this paper, 
model <B>of a</B> third-generation-like computer system is
developed.  Formal techniques are used to derive 
precise sufficient conditions to test whether such
an architecture can support virtual machines.

CACM July, 1974

Popek, G. J.
Goldberg, R. P.

operating system, third generation architecture,
sensitive instruction, formal requirements, abstract 
model, proof, virtual machine, virtual memory,
hypervisor, virtual machine monitor

4.32 4.35 5.21 5.22

CA740707 JB January 17, 1978  11:19 AM

2624	5	2624
2624	5	2624
2624	5	2624
3144	5	2624
1471	6	2624
2298	6	2624
2491	6	2624
2597	6	2624
2624	6	2624
2625	6	2624
2632	6	2624


************************



Formal Requirements for Virtualizable Third Generation Architectures

Virtual machine systems have been implemented
on a limited number of third generation computer 
systems, e.g. CP-67 on the IBM 360/67.  From previous
empirical studies, <B>it is</B> known that certain third 
generation computer systems, e.g. the DEC PDP-10, cannot
support a virtual machine system.  In this paper, 
model of a third-generation-like computer system is
developed.  Formal techniques are used to derive 
precise sufficient conditions to test whether such
an architecture can support virtual machines.

CACM July, 1974

Popek, G. J.
Goldberg, R. P.

operating system, third generation architecture,
sensitive instruction, formal requirements, abstract 
model, proof, virtual machine, virtual memory,
hypervisor, virtual machine monitor

4.32 4.35 5.21 5.22

CA740707 JB January 17, 1978  11:19 AM

2624	5	2624
2624	5	2624
2624	5	2624
3144	5	2624
1471	6	2624
2298	6	2624
2491	6	2624
2597	6	2624
2624	6	2624
2625	6	2624
2632	6	2624


************************

************************
Document:  CACM-1470.html
************************


The Structure of Programming Languages

The following are identified as major components
of every programming language: (1) the elementary 
program statement, (2) mechanisms for linking elementary
statements together, (3) the means by which 
a program can obtain data inputs.  Several alternative
forms of each of these components are described, 
compared and evaluated.  Many examples, frequently from
list processing languages, illustrate the forms 
described.  Elementary program statements usually take
the form of commands, requirements, or implicit 
specifications.  A command is an imperative statement
that commands the action to be taken.  A requirement 
describes the effect to be achieved without saying anything
about the actions to be taken.  An implicit 
specification is similar to a requirement, but the programmer
must understand what actions will be taken 
to achieve the desired effect.  Subroutines may be entered
explicitly, by execute call, or by function 
composition.  Explicitly called subroutines generally
require special linkage conventions.  An execute 
subroutine call is syntactically indistinguishable from
a basic instruction of the programming language. 
 Function composition is a convenient alternative to
the explicit call.  The three principal ways of 
getting inputs for routines are (1) by referring to
the data itself, (2) by referring to the data by 
a "name", and (3) by referring to it implicitly by means
of variables or functions.  Names are useful 
entry points into permanent data structures, but can
be error-causing distractions in other contexts. 
The author discusses advantages, disadvantages, and factors
influencing the choice <B>of a</B> form of component 
for a language.   He concludes by suggesting the evolution
of programming languages toward one which 
will permit all the most convenient ways of structuring
programs, organizing systems, and referencing 
data.

CACM March, 1966

Raphael, B.

CA660302 JB March 3, 1978  2:20 PM

1470	5	1470
1470	5	1470
1470	5	1470


************************

************************
Document:  CACM-3060.html
************************


Fortran 77

There is a new standard Fortran.  The official
title is "American National Standard Programming 
Language Fortran, X3.9-1978," but it is more commonly
referred to as "Fortran 77," since its development 
was completed in 1977.  It replaces the Fortran standard
designated X3.9-1966.  This paper describes 
many of the features of Fortran 77 and also provides
some information <B>about how</B> and why the standard 
was developed. 

CACM October, 1978

Brainerd, W.

None

None

CA781001 DH January 29, 1979  6:28 PM

1613	4	3060
1646	4	3060
1900	4	3060
1955	4	3060
2025	4	3060
2154	4	3060
2154	4	3060
2365	4	3060
2506	4	3060
2915	4	3060
3060	4	3060
3060	4	3060
3060	4	3060
987	5	3060
1900	5	3060
2154	5	3060
3060	5	3060
3060	5	3060
3060	5	3060


************************



Fortran 77

There is a new standard Fortran.  The official
title is "American National Standard Programming 
Language Fortran, X3.9-1978," but <B>it is</B> more commonly
referred to as "Fortran 77," since its development 
was completed in 1977.  It replaces the Fortran standard
designated X3.9-1966.  This paper describes 
many of the features of Fortran 77 and also provides
some information about how and why the standard 
was developed. 

CACM October, 1978

Brainerd, W.

None

None

CA781001 DH January 29, 1979  6:28 PM

1613	4	3060
1646	4	3060
1900	4	3060
1955	4	3060
2025	4	3060
2154	4	3060
2154	4	3060
2365	4	3060
2506	4	3060
2915	4	3060
3060	4	3060
3060	4	3060
3060	4	3060
987	5	3060
1900	5	3060
2154	5	3060
3060	5	3060
3060	5	3060
3060	5	3060


************************

************************
Document:  CACM-2949.html
************************


A Correctness Proof <B>of a</B> Topology Information
Main tenance Protocol for a Distributed Computer 
Network

In order for the nodes of a distributed computer
network to communicate, each node must have 
information about the network's topology.  Since nodes
and links sometimes crash, a scheme is needed 
to update this information.  One of the major constrain ts
on such a topology information scheme is that 
it may not involve a central controller.  The Topology
Information Protocol that was implemented on the 
MERIT Computer Network is presented and explained; this
protocol is quite general and could be implemented 
on any computer network.  It is based on Baran's "Hot
Potato Heuristic Routing Doctrine."  A correctness 
proof of this Topology Information Protocol is also presented.

CACM July, 1977

Tajibnapis, W. D.

distributed computer network, correctness proofs,
computer networks, distributed control, network 
topology, routing problem in networks, distributed operating
system, store and forward packet switching, 
store and forward message switching, traffic control

3.81 4.32

CA770703 JB December 28, 1977  11:59 AM

2949	5	2949
2949	5	2949
2949	5	2949


************************

************************
Document:  CACM-2937.html
************************


An Experimental Evaluation of Data Type Conventions

The language <B>in which</B> programs are written
can have a substantial effect on the reliability 
of the resulting programs.  This paper discusses an experiment
that compares the programming reliability 
of subjects using a statically typed language and a "typeless"
language.  Analysis of the number of errors 
and the number of runs containing errors shows that, at
least in one environment, the use of a statically 
typed language can increase programming reliability. 
Detailed analysis of the errors made by the subjects 
in programming solutions to reasonably small problems
shows that the subjects had difficulty manipulating 
the representation of data.

CACM August, 1977

Gannon, J. D.

data types, experimentation, language
design, redundancy, reliable software

4.22

CA770806JB December 28, 1977  7:32 AM

2411	4	2937
2709	4	2937
2889	4	2937
2937	4	2937
2989	4	2937
3005	4	2937
3025	4	2937
3101	4	2937
2138	5	2937
2937	5	2937
2937	5	2937
2937	5	2937


************************



An Experimental Evaluation of Data Type Conventions

The language in which programs are written
can have a substantial effect on the reliability 
of the resulting programs.  This paper discusses an experiment
that compares the programming reliability 
of subjects using a statically typed language and a "typeless"
language.  Analysis of the number of errors 
and the number of runs containing errors shows that, at
least in one environment, the use <B>of a</B> statically 
typed language can increase programming reliability. 
Detailed analysis of the errors made by the subjects 
in programming solutions to reasonably small problems
shows that the subjects had difficulty manipulating 
the representation of data.

CACM August, 1977

Gannon, J. D.

data types, experimentation, language
design, redundancy, reliable software

4.22

CA770806JB December 28, 1977  7:32 AM

2411	4	2937
2709	4	2937
2889	4	2937
2937	4	2937
2989	4	2937
3005	4	2937
3025	4	2937
3101	4	2937
2138	5	2937
2937	5	2937
2937	5	2937
2937	5	2937


************************

************************
Document:  CACM-0675.html
************************


Coding Clinical Laboratory Data For Automatic Storage and Retrieval

A series of clinical laboratory codes have been
developed to accept and store urin analysis, blood 
chemistry, and hematology test results for automatic
data processing.  The codes, although constructed 
as part <B>of a</B> computerized hospital simulation, have been
able to handle the results of every laboratory 
test that they have encountered.  The unique feature of
these codes is that they can accept conventionally 
recorded qualitative as well as quantitative test results.
 Consequently, clinical test results need 
not be arbitrarily stratified, standardized, or altered
in any way to be coded.  This paper describes 
how the codes were developed and presents a listing of the
urin analysis codes.  Five criteria used in developing 
the codes are outlined and the problem of multiple-synonymous
terminology is discussed.  A solution to 
the problem is described.  Flexible, computer-produced,
composite laboratory reports are also discussed, 
along with reproduction of such a report. The paper concludes
that even though many problems remain unsolved, 
the next ten years could witness the emergence of a practical
automated information system in the laboratory.

CACM November, 1963

Gross, L. D.

CA631117 JB March 13, 1978  3:26 PM

675	5	675
675	5	675
675	5	675


************************

************************
Document:  CACM-1769.html
************************


The Expanding World of Computers

The onward sweep <B>of a</B>utomatic processing of
information is impeded by nine principal barriers: 
geography, cost, problem complexity, man-machine communication,
inadequate sensors, lack of understanding, 
distance, time, and size.  The main incentive for breaching
these barriers is the universal need for 
processing information, ever more urgent as the greater
part of human work activity changes from production 
to service.  Computer developments in hardware, programming,
time-sharing, education, data communication, 
and displays are judged by how effectively they remove these
barriers, and their barrier-smashing potentialities 
indicate continued rapid expansion.  Problem-oriented
languages are particularly effective over the entire 
front.  Online computers and time-sharing also rate high
by this measure.  Education and increased understanding 
are basic to all progress with the computer.  This complex
but powerful tool is the most important one 
available to governments and scientists to use in studying
the problems being created by the population 
explosion, and in analyzing possible solutions.

CACM April, 1968

Harder, E. L.

barriers, philosophy, developments, computer-aided design,
problem-oriented languages, data communication, 
education, computer science, forecast, survey, introduction

1.0 1.3 2.1 3.24 4.0 6.20 6.30

CA680401 JB February 23, 1978  11:36 AM

1769	5	1769
1769	5	1769
1769	5	1769


************************



The Expanding World of Computers

The onward sweep of automatic processing of
information is impeded by nine principal barriers: 
geography, cost, problem complexity, man-machine communication,
inadequate sensors, lack of understanding, 
distance, time, and size.  The main incentive for breaching
these barriers <B>is the</B> universal need for 
processing information, ever more urgent as the greater
part of human work activity changes from production 
to service.  Computer developments in hardware, programming,
time-sharing, education, data communication, 
and displays are judged by how effectively they remove these
barriers, and their barrier-smashing potentialities 
indicate continued rapid expansion.  Problem-oriented
languages are particularly effective over the entire 
front.  Online computers and time-sharing also rate high
by this measure.  Education and increased understanding 
are basic to all progress with the computer.  This complex
but powerful tool is the most important one 
available to governments and scientists to use in studying
the problems being created by the population 
explosion, and in analyzing possible solutions.

CACM April, 1968

Harder, E. L.

barriers, philosophy, developments, computer-aided design,
problem-oriented languages, data communication, 
education, computer science, forecast, survey, introduction

1.0 1.3 2.1 3.24 4.0 6.20 6.30

CA680401 JB February 23, 1978  11:36 AM

1769	5	1769
1769	5	1769
1769	5	1769


************************



The Expanding World of Computers

The onward sweep of automatic processing of
information is impeded by nine principal barriers: 
geography, cost, problem complexity, man-machine communication,
inadequate sensors, lack of understanding, 
distance, time, and size.  The main incentive for breaching
these barriers is the universal need for 
processing information, ever more urgent as the greater
part of human work activity changes from production 
to service.  Computer developments in hardware, programming,
time-sharing, education, data communication, 
and displays are judged by how effectively they remove these
barriers, and their barrier-smashing potentialities 
indicate continued rapid expansion.  Problem-oriented
languages are particularly effective over <B>the entire</B> 
front.  Online computers and time-sharing also rate high
by this measure.  Education and increased understanding 
are basic to all progress with the computer.  This complex
but powerful tool is the most important one 
available to governments and scientists to use in studying
the problems being created by the population 
explosion, and in analyzing possible solutions.

CACM April, 1968

Harder, E. L.

barriers, philosophy, developments, computer-aided design,
problem-oriented languages, data communication, 
education, computer science, forecast, survey, introduction

1.0 1.3 2.1 3.24 4.0 6.20 6.30

CA680401 JB February 23, 1978  11:36 AM

1769	5	1769
1769	5	1769
1769	5	1769


************************

************************
Document:  CACM-2390.html
************************


A Proposal for a Computer-Based Interactive Scientific Community

Because of the problems created by the explosion
of papers in the mathematical sciences and 
the drawbacks that this places on research, it is suggested
<B>that a</B> tree of all mathematical results and 
terminology be maintained in a multiterminal computer system.
 Users of the system can store in the computer 
an updated file of their current knowledge, and on selecting
a paper to read, they can obtain from the 
computer the minimum subtree of theorems required to bring
them from what they already know to the background 
knowledge which the paper assumes.  Under certain conditions,
means are also provided for the contribution 
of useful comments by the readers of a work and for interaction
between commentators and with the author. 
 This paper describes how the system can be organized
and the role required of readers, writers, and 
commentators. 

CACM February, 1972

Pager, D.

interactive system, organization of scientific community,
readers, writers, commentators, computer 
utility, information retrieval, trees, data structures

1.0 1.1 1.59 2.10 3.15 3.32 3.50 3.51 3.70 3.71 3.74 3.9

CA720201 JB February 1, 1978  8:51 AM

2390	5	2390
2390	5	2390
2390	5	2390
2519	5	2390
2390	6	2390


************************



A Proposal for a Computer-Based Interactive Scientific Community

Because of the problems created by the explosion
of papers in the mathematical sciences and 
the drawbacks that this places on research, <B>it is</B> suggested
that a tree of all mathematical results and 
terminology be maintained in a multiterminal computer system.
 Users of the system can store in the computer 
an updated file of their current knowledge, and on selecting
a paper to read, they can obtain from the 
computer the minimum subtree of theorems required to bring
them from what they already know to the background 
knowledge which the paper assumes.  Under certain conditions,
means are also provided for the contribution 
of useful comments by the readers of a work and for interaction
between commentators and with the author. 
 This paper describes how the system can be organized
and the role required of readers, writers, and 
commentators. 

CACM February, 1972

Pager, D.

interactive system, organization of scientific community,
readers, writers, commentators, computer 
utility, information retrieval, trees, data structures

1.0 1.1 1.59 2.10 3.15 3.32 3.50 3.51 3.70 3.71 3.74 3.9

CA720201 JB February 1, 1978  8:51 AM

2390	5	2390
2390	5	2390
2390	5	2390
2519	5	2390
2390	6	2390


************************



A Proposal for a Computer-Based Interactive Scientific Community

Because of the problems created by the explosion
of papers in the mathematical sciences and 
the drawbacks that this places on research, it is suggested
that a tree <B>of a</B>ll mathematical results and 
terminology be maintained in a multiterminal computer system.
 Users of the system can store in the computer 
an updated file of their current knowledge, and on selecting
a paper to read, they can obtain from the 
computer the minimum subtree of theorems required to bring
them from what they already know to the background 
knowledge which the paper assumes.  Under certain conditions,
means are also provided for the contribution 
of useful comments by the readers of a work and for interaction
between commentators and with the author. 
 This paper describes how the system can be organized
and the role required of readers, writers, and 
commentators. 

CACM February, 1972

Pager, D.

interactive system, organization of scientific community,
readers, writers, commentators, computer 
utility, information retrieval, trees, data structures

1.0 1.1 1.59 2.10 3.15 3.32 3.50 3.51 3.70 3.71 3.74 3.9

CA720201 JB February 1, 1978  8:51 AM

2390	5	2390
2390	5	2390
2390	5	2390
2519	5	2390
2390	6	2390


************************

************************
Document:  CACM-1456.html
************************


Storage and Retrieval of Aspects of Meaning in Directed Graph Structures

An experimental system that uses LISP to make
a conceptual dictionary is described.  The dictionary 
associates with each English word the syntactic information,
definitional material, and references to 
the contexts <B>in which</B> it has been used to define other words.
 Such relations as class inclusion, possession, 
and active or passive actions are used as definitional
material.  The resulting structure serves as a 
powerful vehicle for research on the logic of question answering.
 Examples of methods of inputting information 
and answering simple English questions are given.  An
important conclusion is that, although LISP and 
other list processing languages are ideally suited for
producing complex associative structures, they 
are inadequate vehicles for language processing on any
large scale-at east until they can use auxiliary 
memory as a continuous extension of core memory.

CACM March, 1966

Simmons, R. F.

CA660316 JB March 3, 1978  11:25 AM

1155	4	1456
1456	4	1456
1468	4	1456
1515	4	1456
1699	4	1456
1856	4	1456
2127	4	1456
1324	5	1456
1456	5	1456
1456	5	1456
1456	5	1456


************************



Storage and Retrieval of Aspects of Meaning in Directed Graph Structures

An experimental system that uses LISP to make
a conceptual dictionary is described.  The dictionary 
associates with each English word the syntactic information,
definitional material, and references to 
the contexts in <B>which it</B> has been used to define other words.
 Such relations as class inclusion, possession, 
and active or passive actions are used as definitional
material.  The resulting structure serves as a 
powerful vehicle for research on the logic of question answering.
 Examples of methods of inputting information 
and answering simple English questions are given.  An
important conclusion is that, although LISP and 
other list processing languages are ideally suited for
producing complex associative structures, they 
are inadequate vehicles for language processing on any
large scale-at east until they can use auxiliary 
memory as a continuous extension of core memory.

CACM March, 1966

Simmons, R. F.

CA660316 JB March 3, 1978  11:25 AM

1155	4	1456
1456	4	1456
1468	4	1456
1515	4	1456
1699	4	1456
1856	4	1456
2127	4	1456
1324	5	1456
1456	5	1456
1456	5	1456
1456	5	1456


************************



Storage and Retrieval of Aspects of Meaning in Directed Graph Structures

An experimental system that uses LISP to make
a conceptual dictionary is described.  The dictionary 
associates with each English word the syntactic information,
definitional material, and references to 
the <B>contexts in</B> which it has been used to define other words.
 Such relations as class inclusion, possession, 
and active or passive actions are used as definitional
material.  The resulting structure serves as a 
powerful vehicle for research on the logic of question answering.
 Examples of methods of inputting information 
and answering simple English questions are given.  An
important conclusion is that, although LISP and 
other list processing languages are ideally suited for
producing complex associative structures, they 
are inadequate vehicles for language processing on any
large scale-at east until they can use auxiliary 
memory as a continuous extension of core memory.

CACM March, 1966

Simmons, R. F.

CA660316 JB March 3, 1978  11:25 AM

1155	4	1456
1456	4	1456
1468	4	1456
1515	4	1456
1699	4	1456
1856	4	1456
2127	4	1456
1324	5	1456
1456	5	1456
1456	5	1456
1456	5	1456


************************

************************
Document:  CACM-1806.html
************************


On the Downhill Method

The downhill method is a numerical method for
solving complex equations f(z) = 0 on which the 
only restriction is that the function w = f(z) must
be analytical.  An introduction to this method is 
given and a critical review of relating literature is
presented.  Although in theory the method always 
converges, <B>it is</B> shown that a fundamental dilemma exists
which may cause a breakdown in practical applications. 
 To avoid this difficulty and to improve the rate of
convergence toward a root, some modifications of 
the original method are proposed and a program (FORTRAN)
based on the modified method is given in Algorithm 
365.  Some numerical examples are included.

CACM December, 1969

Bach, H.

downhill method, complex relaxation method, complex
iteration, complex equation, transcendental 
complex equation, algebraic complex equation

5.15

CA691206 JB February 15, 1978  2:54 PM

1806	4	1806
1806	5	1806
1806	5	1806
1806	5	1806
1803	5	1806
535	5	1806
1806	6	1806


************************



On the Downhill Method

The downhill method is a numerical method for
solving complex equations f(z) = 0 on which the 
only restriction is that the function w = f(z) must
be analytical.  An introduction to this method is 
given and a critical review of relating literature is
presented.  Although in theory the method always 
converges, it is shown <B>that a</B> fundamental dilemma exists
which may cause a breakdown in practical applications. 
 To avoid this difficulty and to improve the rate of
convergence toward a root, some modifications of 
the original method are proposed and a program (FORTRAN)
based on the modified method is given in Algorithm 
365.  Some numerical examples are included.

CACM December, 1969

Bach, H.

downhill method, complex relaxation method, complex
iteration, complex equation, transcendental 
complex equation, algebraic complex equation

5.15

CA691206 JB February 15, 1978  2:54 PM

1806	4	1806
1806	5	1806
1806	5	1806
1806	5	1806
1803	5	1806
535	5	1806
1806	6	1806


************************

************************
Document:  CACM-3052.html
************************


Cold-Start vs. Warm-Start Miss Ratios

In a two-level computer storage hierarchy, miss
ratio measurements are often made from a "cold 
start," that is made with the first-level  store initially
empty.  For large capacities the effect on 
the measured miss ratio of the misses incurred while
filling the first-level store can be significant, 
even for long reference strings.  Use of "warm-start"
rather than "cold-start" miss ratios cast doubt 
on the widespread belief that the observed "S-shape" of
lifetime (reciprocal of miss ratio) versus capacity 
curve indicates a property of behavior of programs that
maintain a constant number of pages in main storage. 
 On the other hand, if cold-start miss ratios are measured
as a function of capacity and measurement 
length, then they are useful in studying systems in which
operation of a program is periodically interrupted 
by task switches.  It is shown <B>how to</B> obtain, under simple
assumptions, the cache miss ratio for multiprogramming 
from cold-start miss ratio values and how to obtain
approximate cold-start miss ratios from warm-start 
miss ratios.

CACM October, 1978

Easton, M.
Fagin, R.

Miss ratio, cold start, warm start, storage hierarchy,
lifetime function, multiprogramming, S-shape

3.70 4.32 9.35

CA781009 DH January 29, 1979  5:16 PM

2374	4	3052
2481	4	3052
2669	4	3052
2863	4	3052
3016	4	3052
3052	4	3052
1901	5	3052
3052	5	3052
3052	5	3052
3052	5	3052


************************



Cold-Start vs. Warm-Start Miss Ratios

In a two-level computer storage hierarchy, miss
ratio measurements are often made from a "cold 
start," that is made with the first-level  store initially
empty.  For large capacities the effect on 
the measured miss ratio of the misses incurred while
filling the first-level store can be significant, 
even for long reference strings.  Use of "warm-start"
rather than "cold-start" miss ratios cast doubt 
on the widespread belief that the observed "S-shape" of
lifetime (reciprocal of miss ratio) versus capacity 
curve indicates a property of behavior of programs that
maintain a constant number of pages in main storage. 
 On the other hand, if cold-start miss ratios are measured
as a function of capacity and measurement 
length, then they are useful in studying systems in which
operation <B>of a</B> program is periodically interrupted 
by task switches.  It is shown how to obtain, under simple
assumptions, the cache miss ratio for multiprogramming 
from cold-start miss ratio values and how to obtain
approximate cold-start miss ratios from warm-start 
miss ratios.

CACM October, 1978

Easton, M.
Fagin, R.

Miss ratio, cold start, warm start, storage hierarchy,
lifetime function, multiprogramming, S-shape

3.70 4.32 9.35

CA781009 DH January 29, 1979  5:16 PM

2374	4	3052
2481	4	3052
2669	4	3052
2863	4	3052
3016	4	3052
3052	4	3052
1901	5	3052
3052	5	3052
3052	5	3052
3052	5	3052


************************



Cold-Start vs. Warm-Start Miss Ratios

In a two-level computer storage hierarchy, miss
ratio measurements are often made from a "cold 
start," that is made with the first-level  store initially
empty.  For large capacities the effect on 
the measured miss ratio of the misses incurred while
filling the first-level store can be significant, 
even for long reference strings.  Use of "warm-start"
rather than "cold-start" miss ratios cast doubt 
on the widespread belief that the observed "S-shape" of
lifetime (reciprocal of miss ratio) versus capacity 
curve indicates a property of behavior of programs that
maintain a constant number of pages in main storage. 
 On the other hand, if cold-start miss ratios are measured
as a function of capacity and measurement 
length, then they are useful in studying systems <B>in which</B>
operation of a program is periodically interrupted 
by task switches.  It is shown how to obtain, under simple
assumptions, the cache miss ratio for multiprogramming 
from cold-start miss ratio values and how to obtain
approximate cold-start miss ratios from warm-start 
miss ratios.

CACM October, 1978

Easton, M.
Fagin, R.

Miss ratio, cold start, warm start, storage hierarchy,
lifetime function, multiprogramming, S-shape

3.70 4.32 9.35

CA781009 DH January 29, 1979  5:16 PM

2374	4	3052
2481	4	3052
2669	4	3052
2863	4	3052
3016	4	3052
3052	4	3052
1901	5	3052
3052	5	3052
3052	5	3052
3052	5	3052


************************

************************
Document:  CACM-0670.html
************************


Some Legal Implications of the Use of Computers in the Banking Business

The introduction of computers in to the banking
business has a wide variety of legal implications 
that merit careful attention at this very early stage.
 The industry is highly regulated by government 
and, hence, is subject to many statutes and regulations.
 It also is affected by important common law 
rules established by courts.  The legal ramifications
involve not only the mechanization itself, but 
also the very significant, economically attractive phenomenon
of off premises processing.  It is essential 
to identify and provide for many legal aspects right
now, before systems and practices crystallize, in 
order to avoid the later impact of unanticipated physical
complications and expense.  The legal aspects 
of computerization in the banking business are especially
diverse.  In some states, there might be the 
basic question whether banks are authorized by law to
invest in the new facilities, either directly or 
through cooperatives.  More challenging are questions
relating to off-premises processors, particularly 
with respect to the obligation not to disclose information
concerning a bank's customers, the adequacy 
of fidelity bond coverage, the extent of liability for
improper refusal to pay a check, and susceptibility 
to regulation by government agencies.  Also pertinent
<B>is the</B> propriety of data processing by banks for 
nonbank entities and particularly of the rendering of
that service without charge for bank depositors.

CACM December, 1963

Freed, R. N.

CA631204 JB March 13, 1978  3:09 PM

670	5	670
670	5	670
670	5	670


************************



Some Legal Implications of the Use of Computers in the Banking Business

The introduction of computers in to the banking
business has a wide variety of legal implications 
that merit careful attention at this very early stage.
 The industry is highly regulated by government 
and, hence, is subject to many statutes and regulations.
 It also is affected by important common law 
rules established by courts.  The legal ramifications
involve not only the mechanization itself, but 
also the very significant, economically attractive phenomenon
of off premises processing.  It is essential 
to identify and provide for many legal aspects right
now, before systems and practices crystallize, in 
order <B>to avoid</B> the later impact of unanticipated physical
complications and expense.  The legal aspects 
of computerization in the banking business are especially
diverse.  In some states, there might be the 
basic question whether banks are authorized by law to
invest in the new facilities, either directly or 
through cooperatives.  More challenging are questions
relating to off-premises processors, particularly 
with respect to the obligation not to disclose information
concerning a bank's customers, the adequacy 
of fidelity bond coverage, the extent of liability for
improper refusal to pay a check, and susceptibility 
to regulation by government agencies.  Also pertinent
is the propriety of data processing by banks for 
nonbank entities and particularly of the rendering of
that service without charge for bank depositors.

CACM December, 1963

Freed, R. N.

CA631204 JB March 13, 1978  3:09 PM

670	5	670
670	5	670
670	5	670


************************

************************
Document:  CACM-1867.html
************************


On the Expected Lengths of Sequences Generated
in Sorting by Replacement Selecting

In the replacement-selecting technique of sorting,
one is interested in the ratio L(j) of the 
expected length of the j-th sequence generated by the
technique to the number of memory cells used.  
Using complex-variable theory, <B>it is</B> shown that L(j)
-> 2 and that, asymptotically, the average interval 
between sign changes of L(j)-2 is 2.6662.

CACM July, 1969

Hooker, W. W.

replacement selecting, sorting, sequence lengths,
asymptotic expected length, recursion relation, 
generating function, meromorphic function

3.74 5.31

CA690713 JB February 15, 1978  6:37 PM

1867	4	1867
2272	4	1867
1638	5	1867
1867	5	1867
1867	5	1867
1867	5	1867


************************



On the Expected Lengths of Sequences Generated
in Sorting by Replacement Selecting

In the replacement-selecting technique of sorting,
one is <B>interested in</B> the ratio L(j) of the 
expected length of the j-th sequence generated by the
technique to the number of memory cells used.  
Using complex-variable theory, it is shown that L(j)
-> 2 and that, asymptotically, the average interval 
between sign changes of L(j)-2 is 2.6662.

CACM July, 1969

Hooker, W. W.

replacement selecting, sorting, sequence lengths,
asymptotic expected length, recursion relation, 
generating function, meromorphic function

3.74 5.31

CA690713 JB February 15, 1978  6:37 PM

1867	4	1867
2272	4	1867
1638	5	1867
1867	5	1867
1867	5	1867
1867	5	1867


************************

************************
Document:  CACM-3002.html
************************


A Record and File Partitioning Model

One of the main objectives in the design of
a file system <B>is the</B> reduction of storage and data 
transfer costs.  This paper presents a model in which
several  requests access the file system, and each 
request requires information from one or more variable
length data-items.  The probabilities of access 
and the distribution of each data-item's length are assumed
to be known, and to be mutually independent. 
The file system uses one or more storage devices, and
each record may be partitioned into subrecords 
that are stored on different devices.  One of the subrecords
is designated as the primary record; when 
a request for a record is made, the primary record is
first accessed, and other subrecords are accessed 
only if the pertinent information is not stored in the
primary record.  The model that is presented in 
this paper, both as a nonlinear programming model and
a mixed integer programming model, is a very general 
one; several types of file systems may be derived from
it by an appropriate selection of its parameters. 
 This model has already been used in the optimization of
library routines' storage at a large scale operating 
system.

CACM January, 1977

Babad, J. M.

file system, file design, file partitioning, record partitioning

3.73

CA770103 JB January 3, 1978  12:28 AM

3002	5	3002
3002	5	3002
3002	5	3002
3168	5	3002
2965	6	3002
3002	6	3002


************************



A Record and File Partitioning Model

One of the main objectives in the design of
a file system is the reduction of storage and data 
transfer costs.  This paper presents a model in which
several  requests access the file system, and each 
request requires information from one or more variable
length data-items.  The probabilities <B>of a</B>ccess 
and the distribution of each data-item's length are assumed
to be known, and to be mutually independent. 
The file system uses one or more storage devices, and
each record may be partitioned into subrecords 
that are stored on different devices.  One of the subrecords
is designated as the primary record; when 
a request for a record is made, the primary record is
first accessed, and other subrecords are accessed 
only if the pertinent information is not stored in the
primary record.  The model that is presented in 
this paper, both as a nonlinear programming model and
a mixed integer programming model, is a very general 
one; several types of file systems may be derived from
it by an appropriate selection of its parameters. 
 This model has already been used in the optimization of
library routines' storage at a large scale operating 
system.

CACM January, 1977

Babad, J. M.

file system, file design, file partitioning, record partitioning

3.73

CA770103 JB January 3, 1978  12:28 AM

3002	5	3002
3002	5	3002
3002	5	3002
3168	5	3002
2965	6	3002
3002	6	3002


************************



A Record and File Partitioning Model

One of the main objectives in the design of
a file system is the reduction of storage and data 
transfer costs.  This paper presents a model in which
several  requests access the file system, and each 
request requires information from one or more variable
length data-items.  The probabilities of access 
and the distribution of each data-item's length are assumed
to be known, and to be mutually independent. 
The file system uses one or more storage devices, and
each record may be partitioned into subrecords 
<B>that a</B>re stored on different devices.  One of the subrecords
is designated as the primary record; when 
a request for a record is made, the primary record is
first accessed, and other subrecords are accessed 
only if the pertinent information is not stored in the
primary record.  The model that is presented in 
this paper, both as a nonlinear programming model and
a mixed integer programming model, is a very general 
one; several types of file systems may be derived from
it by an appropriate selection of its parameters. 
 This model has already been used in the optimization of
library routines' storage at a large scale operating 
system.

CACM January, 1977

Babad, J. M.

file system, file design, file partitioning, record partitioning

3.73

CA770103 JB January 3, 1978  12:28 AM

3002	5	3002
3002	5	3002
3002	5	3002
3168	5	3002
2965	6	3002
3002	6	3002


************************



A Record and File Partitioning Model

One of the main objectives in the design of
a file system is the reduction of storage and data 
transfer costs.  This paper presents a model <B>in which</B>
several  requests access the file system, and each 
request requires information from one or more variable
length data-items.  The probabilities of access 
and the distribution of each data-item's length are assumed
to be known, and to be mutually independent. 
The file system uses one or more storage devices, and
each record may be partitioned into subrecords 
that are stored on different devices.  One of the subrecords
is designated as the primary record; when 
a request for a record is made, the primary record is
first accessed, and other subrecords are accessed 
only if the pertinent information is not stored in the
primary record.  The model that is presented in 
this paper, both as a nonlinear programming model and
a mixed integer programming model, is a very general 
one; several types of file systems may be derived from
it by an appropriate selection of its parameters. 
 This model has already been used in the optimization of
library routines' storage at a large scale operating 
system.

CACM January, 1977

Babad, J. M.

file system, file design, file partitioning, record partitioning

3.73

CA770103 JB January 3, 1978  12:28 AM

3002	5	3002
3002	5	3002
3002	5	3002
3168	5	3002
2965	6	3002
3002	6	3002


************************

************************
Document:  CACM-2993.html
************************


Occurrences of Cycling and Other Phenomena
Arising in a Class of Linear Programming Models

An investigation into the average queue size
for a certain class of queues has resulted in 
the formulation of linear programming problems which
are ill-conditioned in some cases.  In attempting 
to solve these linear programming models, using IBM's
MPS package, instances of cycling were encountered. 
 Small perturbations in the input data resulted in problems
which did not cycle.  This fact, plus several 
other observed phenomena suggest that the primary reason
that cycling is not known to occur more frequently 
<B>is the</B> round-off errors in the computations perturb
the problem sufficiently to prevent cycling (or at 
least to prevent indefinite cycling).  In one case maximizing
and minimizing an objective function subject 
to the same constrain t set was attempted, but MPS solved
only one of these while giving an indication 
of infeasibility for the other.

CACM February, 1977

Kotiah, T. C. T.
Steinberg, D. I.

linear programming, cycling, queueing models

5.41 5.9

CA770208 JB December 30, 1977  2:11 AM

2993	5	2993
2993	5	2993
2993	5	2993


************************

