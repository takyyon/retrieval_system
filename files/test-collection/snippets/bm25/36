Snippets for the query:  Articles describing the relationship between data types and concurrency (e.g. what is the type of a process? when is a synchronization attempt between two processes "type correct"? in a message-passing system is there any notion of the types of messages?--i.e. any way to check that the sender of the message and the receiver are both treating the bit stream as some particular type)
************************
Total Hits:  318
************************

************************
Document:  CACM-2470.html
************************


Fen-An Axiomatic Basis for Program Semantics

A formal system is presented which abstracts
the notions of data item, function, and relation. 
 It is argued <B>that the</B> system is more suitable than set
theory (or its derivatives) for the concise and 
accurate description of program semantics.  It is shown
how the system can be used to build composite 
data types out of simper ones with the operations of rowing,
structuring, and uniting.  It is also demonstrated 
that completely new primitive types can be introduced
into languages through the mechanism of singleton 
data types.  Both deterministic and nondeterministic
functions are shown to be definable in the system. 
 It is described how the local environment can be modeled
as a data item and how imperative statements 
can be considered functions on the environment.  The
nature of recursive functions is briefly discussed, 
and a technique is presented by which they can be introduced
into the system.  The technique is contrasted 
with the use of the paradoxical combinator, Y.  The
questions of local and global environments and of 
various modes of function calling and parameter passing
are touched upon. The theory is applied to the 
proof of several elementary theorems concerning the semantics
of the assignment, conditional, and iterative 
statements.  An appendix is included which presents in
detail the formal system governing webs and fen, 
the abstractions used informally in the body of the paper.

CACM August, 1973

MacLennan, B. J.

semantics, formal systems, lambda-calculus, extensible
languages, data types, modes, axioms, correctness, 
formal language definition, formal description, data structures,
description languages, models of computation

4.22 5.21 5.24 5.26

CA730804 JB January 23, 1978  11:01 AM

1469	4	2470
1486	4	2470
1491	4	2470
1781	4	2470
2021	4	2470
2060	4	2470
2178	4	2470
2222	4	2470
2227	4	2470
2294	4	2470
2315	4	2470
2326	4	2470
2326	4	2470
2470	4	2470
2470	4	2470
2470	4	2470
2470	4	2470
2684	4	2470
2732	4	2470
2865	4	2470
2896	4	2470
2943	4	2470
3014	4	2470
3044	4	2470
3068	4	2470
3077	4	2470
3124	4	2470
3143	4	2470
1303	5	2470
1469	5	2470
1834	5	2470
2264	5	2470
2470	5	2470
2470	5	2470
2470	5	2470


************************



Fen-An Axiomatic Basis for Program Semantics

A formal system is presented which abstracts
the notions of data item, function, and relation. 
 It <B>is a</B>rgued that the system is more suitable than set
theory (or its derivatives) for the concise and 
accurate description of program semantics.  It is shown
how the system can be used to build composite 
data types out of simper ones with the operations of rowing,
structuring, and uniting.  It is also demonstrated 
that completely new primitive types can be introduced
into languages through the mechanism of singleton 
data types.  Both deterministic and nondeterministic
functions are shown to be definable in the system. 
 It is described how the local environment can be modeled
as a data item and how imperative statements 
can be considered functions on the environment.  The
nature of recursive functions is briefly discussed, 
and a technique is presented by which they can be introduced
into the system.  The technique is contrasted 
with the use of the paradoxical combinator, Y.  The
questions of local and global environments and of 
various modes of function calling and parameter passing
are touched upon. The theory is applied to the 
proof of several elementary theorems concerning the semantics
of the assignment, conditional, and iterative 
statements.  An appendix is included which presents in
detail the formal system governing webs and fen, 
the abstractions used informally in the body of the paper.

CACM August, 1973

MacLennan, B. J.

semantics, formal systems, lambda-calculus, extensible
languages, data types, modes, axioms, correctness, 
formal language definition, formal description, data structures,
description languages, models of computation

4.22 5.21 5.24 5.26

CA730804 JB January 23, 1978  11:01 AM

1469	4	2470
1486	4	2470
1491	4	2470
1781	4	2470
2021	4	2470
2060	4	2470
2178	4	2470
2222	4	2470
2227	4	2470
2294	4	2470
2315	4	2470
2326	4	2470
2326	4	2470
2470	4	2470
2470	4	2470
2470	4	2470
2470	4	2470
2684	4	2470
2732	4	2470
2865	4	2470
2896	4	2470
2943	4	2470
3014	4	2470
3044	4	2470
3068	4	2470
3077	4	2470
3124	4	2470
3143	4	2470
1303	5	2470
1469	5	2470
1834	5	2470
2264	5	2470
2470	5	2470
2470	5	2470
2470	5	2470


************************



Fen-An Axiomatic Basis for Program Semantics

A formal system is presented which abstracts
the notions of data item, function, and relation. 
 It is argued that the system is more suitable than set
theory (or its derivatives) for the concise and 
accurate description of program semantics.  It is shown
how the system can be used to build composite 
data types out of simper ones with the operations of rowing,
structuring, and uniting.  It is also demonstrated 
that completely new primitive types can be introduced
into languages through the mechanism of singleton 
data types.  Both deterministic and nondeterministic
functions are shown to be definable in the system. 
 It is described how the local environment can be modeled
as a data item and how imperative statements 
can be considered functions on the environment.  The
nature of recursive functions is briefly discussed, 
and a technique is presented by which they can be introduced
into the system.  The technique is contrasted 
with the use <B>of the</B> paradoxical combinator, Y.  The
questions of local and global environments and of 
various modes of function calling and parameter passing
are touched upon. The theory is applied to the 
proof of several elementary theorems concerning the semantics
of the assignment, conditional, and iterative 
statements.  An appendix is included which presents in
detail the formal system governing webs and fen, 
the abstractions used informally in the body of the paper.

CACM August, 1973

MacLennan, B. J.

semantics, formal systems, lambda-calculus, extensible
languages, data types, modes, axioms, correctness, 
formal language definition, formal description, data structures,
description languages, models of computation

4.22 5.21 5.24 5.26

CA730804 JB January 23, 1978  11:01 AM

1469	4	2470
1486	4	2470
1491	4	2470
1781	4	2470
2021	4	2470
2060	4	2470
2178	4	2470
2222	4	2470
2227	4	2470
2294	4	2470
2315	4	2470
2326	4	2470
2326	4	2470
2470	4	2470
2470	4	2470
2470	4	2470
2470	4	2470
2684	4	2470
2732	4	2470
2865	4	2470
2896	4	2470
2943	4	2470
3014	4	2470
3044	4	2470
3068	4	2470
3077	4	2470
3124	4	2470
3143	4	2470
1303	5	2470
1469	5	2470
1834	5	2470
2264	5	2470
2470	5	2470
2470	5	2470
2470	5	2470


************************



Fen-An Axiomatic Basis for Program Semantics

A formal system is presented which abstracts
the notions of data item, function, and relation. 
 It is argued that the system is more suitable than set
theory (or its derivatives) for the concise and 
accurate description of program semantics.  It is shown
how the system can be used to build composite 
<B>data types</B> out of simper ones with the operations of rowing,
structuring, and uniting.  It is also demonstrated 
that completely new primitive types can be introduced
into languages through the mechanism of singleton 
data types.  Both deterministic and nondeterministic
functions are shown to be definable in the system. 
 It is described how the local environment can be modeled
as a data item and how imperative statements 
can be considered functions on the environment.  The
nature of recursive functions is briefly discussed, 
and a technique is presented by which they can be introduced
into the system.  The technique is contrasted 
with the use of the paradoxical combinator, Y.  The
questions of local and global environments and of 
various modes of function calling and parameter passing
are touched upon. The theory is applied to the 
proof of several elementary theorems concerning the semantics
of the assignment, conditional, and iterative 
statements.  An appendix is included which presents in
detail the formal system governing webs and fen, 
the abstractions used informally in the body of the paper.

CACM August, 1973

MacLennan, B. J.

semantics, formal systems, lambda-calculus, extensible
languages, data types, modes, axioms, correctness, 
formal language definition, formal description, data structures,
description languages, models of computation

4.22 5.21 5.24 5.26

CA730804 JB January 23, 1978  11:01 AM

1469	4	2470
1486	4	2470
1491	4	2470
1781	4	2470
2021	4	2470
2060	4	2470
2178	4	2470
2222	4	2470
2227	4	2470
2294	4	2470
2315	4	2470
2326	4	2470
2326	4	2470
2470	4	2470
2470	4	2470
2470	4	2470
2470	4	2470
2684	4	2470
2732	4	2470
2865	4	2470
2896	4	2470
2943	4	2470
3014	4	2470
3044	4	2470
3068	4	2470
3077	4	2470
3124	4	2470
3143	4	2470
1303	5	2470
1469	5	2470
1834	5	2470
2264	5	2470
2470	5	2470
2470	5	2470
2470	5	2470


************************



Fen-An Axiomatic Basis for Program Semantics

A formal <B>system is</B> presented which abstracts
the notions of data item, function, and relation. 
 It is argued that the system is more suitable than set
theory (or its derivatives) for the concise and 
accurate description of program semantics.  It is shown
how the system can be used to build composite 
data types out of simper ones with the operations of rowing,
structuring, and uniting.  It is also demonstrated 
that completely new primitive types can be introduced
into languages through the mechanism of singleton 
data types.  Both deterministic and nondeterministic
functions are shown to be definable in the system. 
 It is described how the local environment can be modeled
as a data item and how imperative statements 
can be considered functions on the environment.  The
nature of recursive functions is briefly discussed, 
and a technique is presented by which they can be introduced
into the system.  The technique is contrasted 
with the use of the paradoxical combinator, Y.  The
questions of local and global environments and of 
various modes of function calling and parameter passing
are touched upon. The theory is applied to the 
proof of several elementary theorems concerning the semantics
of the assignment, conditional, and iterative 
statements.  An appendix is included which presents in
detail the formal system governing webs and fen, 
the abstractions used informally in the body of the paper.

CACM August, 1973

MacLennan, B. J.

semantics, formal systems, lambda-calculus, extensible
languages, data types, modes, axioms, correctness, 
formal language definition, formal description, data structures,
description languages, models of computation

4.22 5.21 5.24 5.26

CA730804 JB January 23, 1978  11:01 AM

1469	4	2470
1486	4	2470
1491	4	2470
1781	4	2470
2021	4	2470
2060	4	2470
2178	4	2470
2222	4	2470
2227	4	2470
2294	4	2470
2315	4	2470
2326	4	2470
2326	4	2470
2470	4	2470
2470	4	2470
2470	4	2470
2470	4	2470
2684	4	2470
2732	4	2470
2865	4	2470
2896	4	2470
2943	4	2470
3014	4	2470
3044	4	2470
3068	4	2470
3077	4	2470
3124	4	2470
3143	4	2470
1303	5	2470
1469	5	2470
1834	5	2470
2264	5	2470
2470	5	2470
2470	5	2470
2470	5	2470


************************

************************
Document:  CACM-1159.html
************************


Machine Independence: Its Technology and Economics

A survey is offered of techniques for transferring
programs, and especially compilers, from 
one computer to another.  Of the methods examined, the
"bootstrap" technique is singled out for detailed 
discussion, with emphasis on its economics. The considerations
that determine the applicability of bootstrapping 
in any specific case are discussed, and an attempt
is made to assign appropriate qualitative weights 
to them.  Finally, reasons are given for believing <B>that the</B>
machine-independence problem is being substantially 
diminished by current trends in computer design, and
that it is this process of convergence in hardware 
design rather than any foreseeable software developments
that will lead to its satisfactory resolution.

CACM December, 1965

Halpern, M. I.

CA651210 JB March 6, 1978  3:44 PM

1159	4	1159
1988	4	1159
381	4	1159
1159	5	1159
1159	5	1159
1159	5	1159
14	5	1159


************************



Machine Independence: Its Technology and Economics

A survey is offered of techniques for transferring
programs, and especially compilers, from 
one computer to another.  Of the methods examined, the
"bootstrap" technique is singled out for detailed 
discussion, with emphasis on its economics. The considerations
that determine the applicability of bootstrapping 
<B>in a</B>ny specific case are discussed, and an attempt
is made to assign appropriate qualitative weights 
to them.  Finally, reasons are given for believing that the
machine-independence problem is being substantially 
diminished by current trends in computer design, and
that it is this process of convergence in hardware 
design rather than any foreseeable software developments
that will lead to its satisfactory resolution.

CACM December, 1965

Halpern, M. I.

CA651210 JB March 6, 1978  3:44 PM

1159	4	1159
1988	4	1159
381	4	1159
1159	5	1159
1159	5	1159
1159	5	1159
14	5	1159


************************

************************
Document:  CACM-1426.html
************************


A Simulation of Hospital Admission Policy

A study is described which simulates different
admission policies of a large specialized hospital. 
 The objective is to determine better policies for
stabilization of admission and census rates while 
maintaining a reasonably full hospital.  There <B>types of</B>
policies were examined: admission based on percentages 
of discharge rates, discharge rates plus or minus a
constant, and fixed authorizations independent of 
discharge rates.  The last type policy produced more stable
simulated results, and when put into practice, 
improvements were realized.

CACM May, 1966

Smith, W. G.
Solomon Jr., M. B.

CA660511 JB March 3, 1978  9:42 AM

1426	5	1426
1426	5	1426
1426	5	1426


************************



A Simulation of Hospital Admission Policy

A study is described which simulates different
admission policies <B>of a</B> large specialized hospital. 
 The objective is to determine better policies for
stabilization of admission and census rates while 
maintaining a reasonably full hospital.  There types of
policies were examined: admission based on percentages 
of discharge rates, discharge rates plus or minus a
constant, and fixed authorizations independent of 
discharge rates.  The last type policy produced more stable
simulated results, and when put into practice, 
improvements were realized.

CACM May, 1966

Smith, W. G.
Solomon Jr., M. B.

CA660511 JB March 3, 1978  9:42 AM

1426	5	1426
1426	5	1426
1426	5	1426


************************

************************
Document:  CACM-2003.html
************************


An Interactive Software System for Computers-Aided
Design:  An Application to Circuit Project

The characteristics of an interactive software system, intended to constitute 
an interface between designer and computer during various steps of
the design process, are presented.  The main emphasis is given to the
description of the features of the two high level user oriented
languages, operating at different levels, on which the interaction
is based.  The first one is IMOL, an interactive monitor language,
which is designed to perform the overall and control functions
of the software system; its design criteria provide the user with
commands which are both simple and efficient in order to perform all
the functions needed in computer-aided circuit design.  The second one is 
COIF, a circuit oriented graphic language, which is designed
to describe, generate, and manipulate graphic problem specifications; 
it <B>is a</B>n  extension of Fortran with graphic-type variables,
so that the designer who is familiar with Fortran need not learn a new 
language.  The application to computer-aided circuit design
is in particular examined; on the other hand, the adopted design
criteria provide sufficient generality to extend the use of the two languages 
to different computer-assisted applications.

CACM September, 1970

Bracchi, G.
Somalvico, M.

interaction, graphics, computer graphics, computer-aided design, circuit
design, software system, software organization, language,
monitor language, graphic language, extended Fortran

3.24 3.25 4.13 4.22 4.3

CA700902 JB February 10, 1978  2:20 PM

1853	4	2003
2003	4	2003
2003	4	2003
2003	4	2003
2002	4	2003
2152	4	2003
1710	5	2003
1767	5	2003
2003	5	2003
2003	5	2003
2003	5	2003
2105	5	2003
2230	5	2003
2003	6	2003


************************



An Interactive Software System for Computers-Aided
Design:  An Application to Circuit Project

The characteristics <B>of a</B>n interactive software system, intended to constitute 
an interface between designer and computer during various steps of
the design process, are presented.  The main emphasis is given to the
description of the features of the two high level user oriented
languages, operating at different levels, on which the interaction
is based.  The first one is IMOL, an interactive monitor language,
which is designed to perform the overall and control functions
of the software system; its design criteria provide the user with
commands which are both simple and efficient in order to perform all
the functions needed in computer-aided circuit design.  The second one is 
COIF, a circuit oriented graphic language, which is designed
to describe, generate, and manipulate graphic problem specifications; 
it is an  extension of Fortran with graphic-type variables,
so that the designer who is familiar with Fortran need not learn a new 
language.  The application to computer-aided circuit design
is in particular examined; on the other hand, the adopted design
criteria provide sufficient generality to extend the use of the two languages 
to different computer-assisted applications.

CACM September, 1970

Bracchi, G.
Somalvico, M.

interaction, graphics, computer graphics, computer-aided design, circuit
design, software system, software organization, language,
monitor language, graphic language, extended Fortran

3.24 3.25 4.13 4.22 4.3

CA700902 JB February 10, 1978  2:20 PM

1853	4	2003
2003	4	2003
2003	4	2003
2003	4	2003
2002	4	2003
2152	4	2003
1710	5	2003
1767	5	2003
2003	5	2003
2003	5	2003
2003	5	2003
2105	5	2003
2230	5	2003
2003	6	2003


************************



An Interactive Software System for Computers-Aided
Design:  An Application to Circuit Project

The characteristics of an interactive software system, intended to constitute 
an interface between designer and computer during various steps of
the design process, are presented.  The main emphasis is given to the
description of the features of the two high level user oriented
languages, operating at different levels, on which the interaction
is based.  The first one is IMOL, an interactive monitor language,
which is designed to perform the overall and control functions
of the software system; its design criteria provide the user with
commands which <B>are both</B> simple and efficient in order to perform all
the functions needed in computer-aided circuit design.  The second one is 
COIF, a circuit oriented graphic language, which is designed
to describe, generate, and manipulate graphic problem specifications; 
it is an  extension of Fortran with graphic-type variables,
so that the designer who is familiar with Fortran need not learn a new 
language.  The application to computer-aided circuit design
is in particular examined; on the other hand, the adopted design
criteria provide sufficient generality to extend the use of the two languages 
to different computer-assisted applications.

CACM September, 1970

Bracchi, G.
Somalvico, M.

interaction, graphics, computer graphics, computer-aided design, circuit
design, software system, software organization, language,
monitor language, graphic language, extended Fortran

3.24 3.25 4.13 4.22 4.3

CA700902 JB February 10, 1978  2:20 PM

1853	4	2003
2003	4	2003
2003	4	2003
2003	4	2003
2002	4	2003
2152	4	2003
1710	5	2003
1767	5	2003
2003	5	2003
2003	5	2003
2003	5	2003
2105	5	2003
2230	5	2003
2003	6	2003


************************



An Interactive Software System for Computers-Aided
Design:  An Application to Circuit Project

The characteristics of an interactive software system, intended to constitute 
an interface between designer and computer during various steps of
the design process, are presented.  The main emphasis is given to the
description of the features of the two high level user oriented
languages, operating at different levels, on which the interaction
is based.  The first one is IMOL, an interactive monitor language,
which is designed to perform the overall and control functions
of the software system; its design criteria provide the user with
commands which are both simple and efficient in order to perform all
the functions needed in computer-aided circuit design.  The second one is 
COIF, a circuit oriented graphic language, which is designed
to describe, generate, and manipulate graphic problem specifications; 
it is an  extension of Fortran with graphic-type variables,
so <B>that the</B> designer who is familiar with Fortran need not learn a new 
language.  The application to computer-aided circuit design
is in particular examined; on the other hand, the adopted design
criteria provide sufficient generality to extend the use of the two languages 
to different computer-assisted applications.

CACM September, 1970

Bracchi, G.
Somalvico, M.

interaction, graphics, computer graphics, computer-aided design, circuit
design, software system, software organization, language,
monitor language, graphic language, extended Fortran

3.24 3.25 4.13 4.22 4.3

CA700902 JB February 10, 1978  2:20 PM

1853	4	2003
2003	4	2003
2003	4	2003
2003	4	2003
2002	4	2003
2152	4	2003
1710	5	2003
1767	5	2003
2003	5	2003
2003	5	2003
2003	5	2003
2105	5	2003
2230	5	2003
2003	6	2003


************************



An Interactive Software System for Computers-Aided
Design:  An Application to Circuit Project

The characteristics of an interactive software system, intended to constitute 
an interface between designer and computer during various steps of
the design process, are presented.  The main emphasis is given to the
description <B>of the</B> features of the two high level user oriented
languages, operating at different levels, on which the interaction
is based.  The first one is IMOL, an interactive monitor language,
which is designed to perform the overall and control functions
of the software system; its design criteria provide the user with
commands which are both simple and efficient in order to perform all
the functions needed in computer-aided circuit design.  The second one is 
COIF, a circuit oriented graphic language, which is designed
to describe, generate, and manipulate graphic problem specifications; 
it is an  extension of Fortran with graphic-type variables,
so that the designer who is familiar with Fortran need not learn a new 
language.  The application to computer-aided circuit design
is in particular examined; on the other hand, the adopted design
criteria provide sufficient generality to extend the use of the two languages 
to different computer-assisted applications.

CACM September, 1970

Bracchi, G.
Somalvico, M.

interaction, graphics, computer graphics, computer-aided design, circuit
design, software system, software organization, language,
monitor language, graphic language, extended Fortran

3.24 3.25 4.13 4.22 4.3

CA700902 JB February 10, 1978  2:20 PM

1853	4	2003
2003	4	2003
2003	4	2003
2003	4	2003
2002	4	2003
2152	4	2003
1710	5	2003
1767	5	2003
2003	5	2003
2003	5	2003
2003	5	2003
2105	5	2003
2230	5	2003
2003	6	2003


************************

************************
Document:  CACM-1698.html
************************


A Statistical Model for Console Behavior in Multiuser Computers

The ability of a computer system to communicate
with the outside world efficiently is as important 
as its ability to perform computations efficiently. 
It is quite difficult to characterize a particular 
user, but rather easy to characterize the entire user community.
 Based on the properties of this community 
we have postulated a hypothetical "virtual console."
 No claim is made that a virtual console behaves 
like any actual console, but the entire collection of
virtual consoles models the collection of actual 
consoles.  Using the model we answer questions like: 
How many processes are suspended waiting for console 
input?  What is the maximum rate at which a process can
execute?  What bounds can be set on overall buffer 
requirements?  Answers to these and similar questions
are needed in certa<B>in a</B>spects of operating system 
design.

CACM September, 1968

Denning, P. J.

statistical models for input-output, operating
system design, input-output design

4.30 4.41 5.5

CA680903 JB February 22, 1978  9:21 AM

1458	4	1698
1523	4	1698
1603	4	1698
1698	4	1698
1747	4	1698
1748	4	1698
1854	4	1698
1877	4	1698
1960	4	1698
2377	4	1698
2378	4	1698
2497	4	1698
2558	4	1698
2625	4	1698
2632	4	1698
2840	4	1698
2941	4	1698
3105	4	1698
3144	4	1698
1471	5	1698
1698	5	1698
1698	5	1698
1698	5	1698


************************



A Statistical Model for Console Behavior in Multiuser Computers

The ability of a computer system to communicate
with the outside world efficiently is as important 
as its ability to perform computations efficiently. 
It is quite difficult to characterize a particular 
user, but rather easy to characterize the entire user community.
 Based on the properties of this community 
we have postulated a hypothetical "virtual console."
 No claim is made that a virtual console behaves 
like any actual console, but the entire collection of
virtual consoles models the collection of actual 
consoles.  Using the model we answer questions like: 
How many processes are suspended waiting for console 
input?  What <B>is the</B> maximum rate at which a process can
execute?  What bounds can be set on overall buffer 
requirements?  Answers to these and similar questions
are needed in certain aspects of operating system 
design.

CACM September, 1968

Denning, P. J.

statistical models for input-output, operating
system design, input-output design

4.30 4.41 5.5

CA680903 JB February 22, 1978  9:21 AM

1458	4	1698
1523	4	1698
1603	4	1698
1698	4	1698
1747	4	1698
1748	4	1698
1854	4	1698
1877	4	1698
1960	4	1698
2377	4	1698
2378	4	1698
2497	4	1698
2558	4	1698
2625	4	1698
2632	4	1698
2840	4	1698
2941	4	1698
3105	4	1698
3144	4	1698
1471	5	1698
1698	5	1698
1698	5	1698
1698	5	1698


************************



A Statistical Model for Console Behavior in Multiuser Computers

The ability <B>of a</B> computer system to communicate
with the outside world efficiently is as important 
as its ability to perform computations efficiently. 
It is quite difficult to characterize a particular 
user, but rather easy to characterize the entire user community.
 Based on the properties of this community 
we have postulated a hypothetical "virtual console."
 No claim is made that a virtual console behaves 
like any actual console, but the entire collection of
virtual consoles models the collection of actual 
consoles.  Using the model we answer questions like: 
How many processes are suspended waiting for console 
input?  What is the maximum rate at which a process can
execute?  What bounds can be set on overall buffer 
requirements?  Answers to these and similar questions
are needed in certain aspects of operating system 
design.

CACM September, 1968

Denning, P. J.

statistical models for input-output, operating
system design, input-output design

4.30 4.41 5.5

CA680903 JB February 22, 1978  9:21 AM

1458	4	1698
1523	4	1698
1603	4	1698
1698	4	1698
1747	4	1698
1748	4	1698
1854	4	1698
1877	4	1698
1960	4	1698
2377	4	1698
2378	4	1698
2497	4	1698
2558	4	1698
2625	4	1698
2632	4	1698
2840	4	1698
2941	4	1698
3105	4	1698
3144	4	1698
1471	5	1698
1698	5	1698
1698	5	1698
1698	5	1698


************************



A Statistical Model for Console Behavior in Multiuser Computers

The ability of a computer system to communicate
with the outside world efficiently <B>is a</B>s important 
as its ability to perform computations efficiently. 
It is quite difficult to characterize a particular 
user, but rather easy to characterize the entire user community.
 Based on the properties of this community 
we have postulated a hypothetical "virtual console."
 No claim is made that a virtual console behaves 
like any actual console, but the entire collection of
virtual consoles models the collection of actual 
consoles.  Using the model we answer questions like: 
How many processes are suspended waiting for console 
input?  What is the maximum rate at which a process can
execute?  What bounds can be set on overall buffer 
requirements?  Answers to these and similar questions
are needed in certain aspects of operating system 
design.

CACM September, 1968

Denning, P. J.

statistical models for input-output, operating
system design, input-output design

4.30 4.41 5.5

CA680903 JB February 22, 1978  9:21 AM

1458	4	1698
1523	4	1698
1603	4	1698
1698	4	1698
1747	4	1698
1748	4	1698
1854	4	1698
1877	4	1698
1960	4	1698
2377	4	1698
2378	4	1698
2497	4	1698
2558	4	1698
2625	4	1698
2632	4	1698
2840	4	1698
2941	4	1698
3105	4	1698
3144	4	1698
1471	5	1698
1698	5	1698
1698	5	1698
1698	5	1698


************************

************************
Document:  CACM-2369.html
************************


Hidden Lines Elimination for a Rotating Object

A method is presented of determining which
parts of three-dimensional objects are visible and 
which are invisible when the objects are rotated about
some axis.  This paper describes a polygon comparison 
scheme in which the relationships of two polygons can
be classified into tree types, and also discusses 
how the relationship is changed for each pair of polygons
under rotation about some axis.  A rotation 
table is defined for each pair of polygons, which remains
fixed as long as rotation <B>is a</B>bout one axis 
and provides a means of rapidly determining the visible
and hidden line relationship between two polygons. 
 Additional work must be done to extend this approach
to simultaneous rotation about several axes.

CACM April, 1972

Matsushita, Y.

hidden line problem, display programming, computer
graphics, displays, graphics, computer drawn 
picture

4.40 4.41 4.49

CA720404 JB January 31, 1978  1:40 PM

2369	5	2369
2369	5	2369
2369	5	2369


************************



Hidden Lines Elimination for a Rotating Object

A method is presented of determining which
parts of three-dimensional objects are visible and 
which are invisible when the objects are rotated about
some axis.  This paper describes a polygon comparison 
scheme in which <B>the relationship</B>s of two polygons can
be classified into tree types, and also discusses 
how the relationship is changed for each pair of polygons
under rotation about some axis.  A rotation 
table is defined for each pair of polygons, which remains
fixed as long as rotation is about one axis 
and provides a means of rapidly determining the visible
and hidden line relationship between two polygons. 
 Additional work must be done to extend this approach
to simultaneous rotation about several axes.

CACM April, 1972

Matsushita, Y.

hidden line problem, display programming, computer
graphics, displays, graphics, computer drawn 
picture

4.40 4.41 4.49

CA720404 JB January 31, 1978  1:40 PM

2369	5	2369
2369	5	2369
2369	5	2369


************************



Hidden Lines Elimination for a Rotating Object

A method is presented of determining which
parts of three-dimensional objects are visible and 
which are invisible when the objects are rotated about
some axis.  This paper describes a polygon comparison 
scheme in which the relationships of two polygons can
be classified into tree types, and also discusses 
how the relationship is changed for each pair of polygons
under rotation about some axis.  A rotation 
table is defined for each pair of polygons, which remains
fixed as long as rotation is about one axis 
and provides a means of rapidly determining the visible
and hidden line relationship <B>between two</B> polygons. 
 Additional work must be done to extend this approach
to simultaneous rotation about several axes.

CACM April, 1972

Matsushita, Y.

hidden line problem, display programming, computer
graphics, displays, graphics, computer drawn 
picture

4.40 4.41 4.49

CA720404 JB January 31, 1978  1:40 PM

2369	5	2369
2369	5	2369
2369	5	2369


************************



Hidden Lines Elimination for a Rotating Object

A method is presented of determining which
parts of three-dimensional objects are visible and 
which are invisible when the objects are rotated about
some axis.  This paper describes a polygon comparison 
scheme in which the relationships of two polygons can
be classified into tree types, and also discusses 
how the relationship is changed for each pair of polygons
under rotation about some axis.  A rotation 
table is defined for each pair of polygons, which remains
fixed as long as rotation is about one axis 
and provides a means of rapidly determining the visible
and hidden line <B>relationship between</B> two polygons. 
 Additional work must be done to extend this approach
to simultaneous rotation about several axes.

CACM April, 1972

Matsushita, Y.

hidden line problem, display programming, computer
graphics, displays, graphics, computer drawn 
picture

4.40 4.41 4.49

CA720404 JB January 31, 1978  1:40 PM

2369	5	2369
2369	5	2369
2369	5	2369


************************

************************
Document:  CACM-1591.html
************************


A Model for a Multifunctional Teaching System

A teaching system model that was incorporated
into an operating system <B>of a</B> large computer 
is described.  The model transferred control to the
operating system to execute functions other than 
teaching, and then recovered control in order to resume
teaching.  The teaching system (ABAC-II) was 
written to run under the operating system (IBSYS) for
the IBM 7044 Graphic System.  Because the teaching 
system automatically terminated and rescheduled itself,
a student studying a course presented at a cathode-ray 
display terminal could switch readily between student
mode and programmer mode.  During the latter, the 
full resources of the operating system (language processors,
compilers, library and user's programs) 
were at his disposal.  He could for example, write, assemble,
debug, and execute at the terminal a program 
written in any language processed by the operating system.
 A course could therefore include text material 
interleaved with programming problems which the student
could solve without leaving the terminal.  Exercises 
in simulation and gaming could also be provided.  The
implications of a teaching system with this degree 
of flexibility for industrial and executive training
as well as academic education are discussed.  In 
addition, the advantages of this type of system for computer
programming and operation are also considered.

CACM June, 1967

Engvold, K. J.
Hughes, J. L.

CA670601 JB February 28, 1978  10:24 AM

1591	5	1591
1591	5	1591
1591	5	1591
1680	5	1591
1591	6	1591


************************



A Model for a Multifunctional Teaching System

A teaching system model that was incorporated
into an operating system of a large computer 
is described.  The model transferred control to the
operating system to execute functions other than 
teaching, and then recovered control in order to resume
teaching.  The teaching system (ABAC-II) was 
written to run under the operating system (IBSYS) for
the IBM 7044 Graphic System.  Because the teaching 
system automatically terminated and rescheduled itself,
a student studying a course presented at a cathode-ray 
display terminal could switch readily between student
mode and programmer mode.  During the latter, the 
full resources <B>of the</B> operating system (language processors,
compilers, library and user's programs) 
were at his disposal.  He could for example, write, assemble,
debug, and execute at the terminal a program 
written in any language processed by the operating system.
 A course could therefore include text material 
interleaved with programming problems which the student
could solve without leaving the terminal.  Exercises 
in simulation and gaming could also be provided.  The
implications of a teaching system with this degree 
of flexibility for industrial and executive training
as well as academic education are discussed.  In 
addition, the advantages of this type of system for computer
programming and operation are also considered.

CACM June, 1967

Engvold, K. J.
Hughes, J. L.

CA670601 JB February 28, 1978  10:24 AM

1591	5	1591
1591	5	1591
1591	5	1591
1680	5	1591
1591	6	1591


************************



A Model for a Multifunctional Teaching System

A teaching system model that was incorporated
into an operating system of a large computer 
is described.  The model transferred control to the
operating system to execute functions other than 
teaching, <B>and the</B>n recovered control in order to resume
teaching.  The teaching system (ABAC-II) was 
written to run under the operating system (IBSYS) for
the IBM 7044 Graphic System.  Because the teaching 
system automatically terminated and rescheduled itself,
a student studying a course presented at a cathode-ray 
display terminal could switch readily between student
mode and programmer mode.  During the latter, the 
full resources of the operating system (language processors,
compilers, library and user's programs) 
were at his disposal.  He could for example, write, assemble,
debug, and execute at the terminal a program 
written in any language processed by the operating system.
 A course could therefore include text material 
interleaved with programming problems which the student
could solve without leaving the terminal.  Exercises 
in simulation and gaming could also be provided.  The
implications of a teaching system with this degree 
of flexibility for industrial and executive training
as well as academic education are discussed.  In 
addition, the advantages of this type of system for computer
programming and operation are also considered.

CACM June, 1967

Engvold, K. J.
Hughes, J. L.

CA670601 JB February 28, 1978  10:24 AM

1591	5	1591
1591	5	1591
1591	5	1591
1680	5	1591
1591	6	1591


************************



A Model for a Multifunctional Teaching System

A teaching system model that was incorporated
into an operating system of a large computer 
is described.  The model transferred control to the
operating system to execute functions other than 
teaching, and then recovered control in order to resume
teaching.  The teaching system (ABAC-II) was 
written to run under the operating system (IBSYS) for
the IBM 7044 Graphic System.  Because the teaching 
system automatically terminated and rescheduled itself,
a student studying a course presented at a cathode-ray 
display terminal could switch readily between student
mode and programmer mode.  During the latter, the 
full resources of the operating system (language processors,
compilers, library and user's programs) 
were at his disposal.  He could for example, write, assemble,
debug, and execute at the terminal a program 
written <B>in a</B>ny language processed by the operating system.
 A course could therefore include text material 
interleaved with programming problems which the student
could solve without leaving the terminal.  Exercises 
in simulation and gaming could also be provided.  The
implications of a teaching system with this degree 
of flexibility for industrial and executive training
as well as academic education are discussed.  In 
addition, the advantages of this type of system for computer
programming and operation are also considered.

CACM June, 1967

Engvold, K. J.
Hughes, J. L.

CA670601 JB February 28, 1978  10:24 AM

1591	5	1591
1591	5	1591
1591	5	1591
1680	5	1591
1591	6	1591


************************



A Model for a Multifunctional Teaching System

A teaching system model that was incorporated
into an operating system of a large computer 
is described.  The model transferred control to the
operating system to execute functions other than 
teaching, and then recovered control in order to resume
teaching.  The teaching system (ABAC-II) was 
written to run under the operating system (IBSYS) for
the IBM 7044 Graphic System.  Because the teaching 
system automatically terminated and rescheduled itself,
a student studying a course presented at a cathode-ray 
display terminal could switch readily between student
mode and programmer mode.  During the latter, the 
full resources of the operating system (language processors,
compilers, library and user's programs) 
were at his disposal.  He could for example, write, assemble,
debug, and execute at the terminal a program 
written in any language processed by the operating system.
 A course could therefore include text material 
interleaved with programming problems which the student
could solve without leaving the terminal.  Exercises 
in simulation and gaming could also be provided.  The
implications of a teaching system with this degree 
of flexibility for industrial and executive training
as well as academic education are discussed.  In 
addition, the advantages of this <B>type of</B> system for computer
programming and operation are also considered.

CACM June, 1967

Engvold, K. J.
Hughes, J. L.

CA670601 JB February 28, 1978  10:24 AM

1591	5	1591
1591	5	1591
1591	5	1591
1680	5	1591
1591	6	1591


************************

************************
Document:  CACM-3066.html
************************


A Controlled Experiment in Program Testing
and Code Walkthroughs/Inspections

This paper describes an experiment in program
testing, employing 59 highly experienced data 
processing professionals using seven methods to test
a small PL/I program.  The results show <B>that the</B> 
popular code walk through/inspection method was as effective
as other computer-based methods in finding 
errors and that the most effective methods (in terms of
errors found and cost) employed pairs of subjects 
who tested the program independently and then pooled
their findings.  The study also shows that there 
is a tremendous amount of variability among subjects
and that the ability to detect certain types of 
errors varies from method to method.

CACM September, 1978

Myers, G.

Software reliability, program verification, debugging,
testing, code walkthroughs, code inspections, 
personnel selection

4.6

CA780906 DH February 5, 1979  10:47 AM

3066	5	3066
3066	5	3066
3066	5	3066


************************



A Controlled Experiment in Program Testing
and Code Walkthroughs/Inspections

This paper describes an experiment in program
testing, employing 59 highly experienced data 
processing professionals using seven methods to test
a small PL/I program.  The results show that the 
popular code walk through/inspection method was as effective
as other computer-based methods in finding 
errors and that the most effective methods (in terms of
errors found and cost) employed pairs of subjects 
who tested the program independently and then pooled
their findings.  The study also shows that there 
<B>is a</B> tremendous amount of variability among subjects
and that the ability to detect certain types of 
errors varies from method to method.

CACM September, 1978

Myers, G.

Software reliability, program verification, debugging,
testing, code walkthroughs, code inspections, 
personnel selection

4.6

CA780906 DH February 5, 1979  10:47 AM

3066	5	3066
3066	5	3066
3066	5	3066


************************



A Controlled Experiment in Program Testing
and Code Walkthroughs/Inspections

This paper describes an experiment in program
testing, employing 59 highly experienced data 
processing professionals using seven methods to test
a small PL/I program.  The results show that the 
popular code walk through/inspection method was as effective
as other computer-based methods in finding 
errors and that the most effective methods (in terms of
errors found and cost) employed pairs of subjects 
who tested the program independently <B>and the</B>n pooled
their findings.  The study also shows that there 
is a tremendous amount of variability among subjects
and that the ability to detect certain types of 
errors varies from method to method.

CACM September, 1978

Myers, G.

Software reliability, program verification, debugging,
testing, code walkthroughs, code inspections, 
personnel selection

4.6

CA780906 DH February 5, 1979  10:47 AM

3066	5	3066
3066	5	3066
3066	5	3066


************************



A Controlled Experiment in Program Testing
and Code Walkthroughs/Inspections

This paper describes an experiment in program
testing, employing 59 highly experienced data 
processing professionals using seven methods to test
a small PL/I program.  The results show that the 
popular code walk through/inspection method was as effective
as other computer-based methods in finding 
errors and that the most effective methods (in terms of
errors found and cost) employed pairs of subjects 
who tested the program independently and then pooled
their findings.  The study also shows that there 
is a tremendous amount of variability among subjects
and that the ability to detect certain <B>types of</B> 
errors varies from method to method.

CACM September, 1978

Myers, G.

Software reliability, program verification, debugging,
testing, code walkthroughs, code inspections, 
personnel selection

4.6

CA780906 DH February 5, 1979  10:47 AM

3066	5	3066
3066	5	3066
3066	5	3066


************************

************************
Document:  CACM-1768.html
************************


A Global Parser for Context-Free Phrase Structure Grammars

An algorithm for analyzing any context-free phrase
structure grammar and for generating a program 
which can then parse any sentence in the language (or
indicate that the given sentence is invalid) is 
described. The parser is of the "top-to-bottom" type
and is recursive . A number of heuristic procedures 
whose purpose is to shorten the basic algorithm by quickly
ascertaining that certain substrings of the 
input sentence cannot correspond to the target nonterminal
symbols are included.  Both the generating 
algorithm <B>and the</B> parser have been implemented in RCA
SNOBOL and have been tested successfully on a number 
of artificial grammars and on a subset of ALGOL.  A
number of the routines for extracting data about 
a grammar, such as minimum lengths of N-derivable strings
and possible prefixes, are given and may be 
of interest apart from their application in this particular context.

CACM April, 1968

Unger, S. H.

parser, syntax-directed compiler, context-free
grammars, syntactic analysis, translators

3.42 4.12 5.24

CA680402 JB February 23, 1978  11:27 AM

1350	4	1768
1399	4	1768
1496	4	1768
1659	4	1768
1665	4	1768
1683	4	1768
1768	4	1768
1768	4	1768
1768	4	1768
1781	4	1768
1787	4	1768
1787	4	1768
1824	4	1768
1825	4	1768
1836	4	1768
1861	4	1768
1945	4	1768
1945	4	1768
2015	4	1768
2061	4	1768
2110	4	1768
2110	4	1768
2127	4	1768
2187	4	1768
2317	4	1768
2545	4	1768
2698	4	1768
2733	4	1768
3094	4	1768
1141	5	1768
1265	5	1768
1768	5	1768
1768	5	1768
1768	5	1768
1781	5	1768


************************



A Global Parser for Context-Free Phrase Structure Grammars

An algorithm for analyzing any context-free phrase
structure grammar and for generating a program 
which can then parse any sentence in the language (or
indicate that the given sentence is invalid) is 
described. The parser is of the "top-to-bottom" type
and is recursive . A number of heuristic procedures 
whose purpose is to shorten the basic algorithm by quickly
ascertaining that certain substrings of the 
input sentence cannot correspond to the target nonterminal
symbols are included.  Both the generating 
algorithm and the parser have been implemented in RCA
SNOBOL and have been tested successfully on a number 
<B>of a</B>rtificial grammars and on a subset of ALGOL.  A
number of the routines for extracting data about 
a grammar, such as minimum lengths of N-derivable strings
and possible prefixes, are given and may be 
of interest apart from their application in this particular context.

CACM April, 1968

Unger, S. H.

parser, syntax-directed compiler, context-free
grammars, syntactic analysis, translators

3.42 4.12 5.24

CA680402 JB February 23, 1978  11:27 AM

1350	4	1768
1399	4	1768
1496	4	1768
1659	4	1768
1665	4	1768
1683	4	1768
1768	4	1768
1768	4	1768
1768	4	1768
1781	4	1768
1787	4	1768
1787	4	1768
1824	4	1768
1825	4	1768
1836	4	1768
1861	4	1768
1945	4	1768
1945	4	1768
2015	4	1768
2061	4	1768
2110	4	1768
2110	4	1768
2127	4	1768
2187	4	1768
2317	4	1768
2545	4	1768
2698	4	1768
2733	4	1768
3094	4	1768
1141	5	1768
1265	5	1768
1768	5	1768
1768	5	1768
1768	5	1768
1781	5	1768


************************



A Global Parser for Context-Free Phrase Structure Grammars

An algorithm for analyzing any context-free phrase
structure grammar and for generating a program 
which can then parse any sentence in the language (or
indicate <B>that the</B> given sentence is invalid) is 
described. The parser is of the "top-to-bottom" type
and is recursive . A number of heuristic procedures 
whose purpose is to shorten the basic algorithm by quickly
ascertaining that certain substrings of the 
input sentence cannot correspond to the target nonterminal
symbols are included.  Both the generating 
algorithm and the parser have been implemented in RCA
SNOBOL and have been tested successfully on a number 
of artificial grammars and on a subset of ALGOL.  A
number of the routines for extracting data about 
a grammar, such as minimum lengths of N-derivable strings
and possible prefixes, are given and may be 
of interest apart from their application in this particular context.

CACM April, 1968

Unger, S. H.

parser, syntax-directed compiler, context-free
grammars, syntactic analysis, translators

3.42 4.12 5.24

CA680402 JB February 23, 1978  11:27 AM

1350	4	1768
1399	4	1768
1496	4	1768
1659	4	1768
1665	4	1768
1683	4	1768
1768	4	1768
1768	4	1768
1768	4	1768
1781	4	1768
1787	4	1768
1787	4	1768
1824	4	1768
1825	4	1768
1836	4	1768
1861	4	1768
1945	4	1768
1945	4	1768
2015	4	1768
2061	4	1768
2110	4	1768
2110	4	1768
2127	4	1768
2187	4	1768
2317	4	1768
2545	4	1768
2698	4	1768
2733	4	1768
3094	4	1768
1141	5	1768
1265	5	1768
1768	5	1768
1768	5	1768
1768	5	1768
1781	5	1768


************************



A Global Parser for Context-Free Phrase Structure Grammars

An algorithm for analyzing any context-free phrase
structure grammar and for generating a program 
which can then parse any sentence in the language (or
indicate that the given sentence is invalid) is 
described. The parser is <B>of the</B> "top-to-bottom" type
and is recursive . A number of heuristic procedures 
whose purpose is to shorten the basic algorithm by quickly
ascertaining that certain substrings of the 
input sentence cannot correspond to the target nonterminal
symbols are included.  Both the generating 
algorithm and the parser have been implemented in RCA
SNOBOL and have been tested successfully on a number 
of artificial grammars and on a subset of ALGOL.  A
number of the routines for extracting data about 
a grammar, such as minimum lengths of N-derivable strings
and possible prefixes, are given and may be 
of interest apart from their application in this particular context.

CACM April, 1968

Unger, S. H.

parser, syntax-directed compiler, context-free
grammars, syntactic analysis, translators

3.42 4.12 5.24

CA680402 JB February 23, 1978  11:27 AM

1350	4	1768
1399	4	1768
1496	4	1768
1659	4	1768
1665	4	1768
1683	4	1768
1768	4	1768
1768	4	1768
1768	4	1768
1781	4	1768
1787	4	1768
1787	4	1768
1824	4	1768
1825	4	1768
1836	4	1768
1861	4	1768
1945	4	1768
1945	4	1768
2015	4	1768
2061	4	1768
2110	4	1768
2110	4	1768
2127	4	1768
2187	4	1768
2317	4	1768
2545	4	1768
2698	4	1768
2733	4	1768
3094	4	1768
1141	5	1768
1265	5	1768
1768	5	1768
1768	5	1768
1768	5	1768
1781	5	1768


************************

************************
Document:  CACM-3128.html
************************


Synchronization with Eventcounts and Sequencers

Synchronization of concurrent processes requires controlling the relative 
ordering of events in the processes.
A new synchronization mechanism is proposed, using 
abstract objects called eventcounts and sequencers, that allows processes
to control the ordering of events directly, rather than using mutual
exclusion to protect manipulations of shared variables that control
ordering of events.  Direct control of ordering seems to simplify
correctness arguments and also simplifies implementation in distributed
systems.  The mechanism is defined formally, and then several
examples of its use are given.  The relationship of the mechanism
to protection mechanisms in the system is explained; in particular,
eventcounts are shown to be applicable to situations where confinement
of information matters.  An implementation of eventcount
s and sequencers <B>in a</B> system with shared memory is described.

CACM February, 1979

Reed, D.
Kanodia, R.

Process synchronization, interprocess communication, distributed
systems, security models, mutual exclusion, semaphores

4.30 4.32

CA790207 DH April 12, 1979  10:03 AM

2320	4	3128
2597	4	3128
2700	4	3128
2777	4	3128
2840	4	3128
2851	4	3128
2865	4	3128
2866	4	3128
2869	4	3128
2895	4	3128
2898	4	3128
2912	4	3128
2938	4	3128
2945	4	3128
2946	4	3128
2946	4	3128
2972	4	3128
3043	4	3128
3128	4	3128
3128	4	3128
3128	4	3128
3128	4	3128
3128	4	3128
3128	4	3128
3128	4	3128
3128	4	3128
3128	4	3128
3144	4	3128
3148	4	3128
3158	4	3128
2150	5	3128
2376	5	3128
2436	5	3128
2597	5	3128
2865	5	3128
2866	5	3128
2870	5	3128
2912	5	3128
3082	5	3128
3128	5	3128
3128	5	3128
3128	5	3128


************************



Synchronization with Eventcounts and Sequencers

Synchronization of concurrent processes requires controlling the relative 
ordering of events in the processes.
A new synchronization mechanism is proposed, using 
abstract objects called eventcounts and sequencers, that allows processes
to control the ordering of events directly, rather than using mutual
exclusion to protect manipulations of shared variables that control
ordering of events.  Direct control of ordering seems to simplify
correctness arguments and also simplifies implementation in distributed
systems.  The mechanism is defined formally, and then several
examples of its use are given.  The relationship of the mechanism
to protection mechanisms in the <B>system is</B> explained; in particular,
eventcounts are shown to be applicable to situations where confinement
of information matters.  An implementation of eventcount
s and sequencers in a system with shared memory is described.

CACM February, 1979

Reed, D.
Kanodia, R.

Process synchronization, interprocess communication, distributed
systems, security models, mutual exclusion, semaphores

4.30 4.32

CA790207 DH April 12, 1979  10:03 AM

2320	4	3128
2597	4	3128
2700	4	3128
2777	4	3128
2840	4	3128
2851	4	3128
2865	4	3128
2866	4	3128
2869	4	3128
2895	4	3128
2898	4	3128
2912	4	3128
2938	4	3128
2945	4	3128
2946	4	3128
2946	4	3128
2972	4	3128
3043	4	3128
3128	4	3128
3128	4	3128
3128	4	3128
3128	4	3128
3128	4	3128
3128	4	3128
3128	4	3128
3128	4	3128
3128	4	3128
3144	4	3128
3148	4	3128
3158	4	3128
2150	5	3128
2376	5	3128
2436	5	3128
2597	5	3128
2865	5	3128
2866	5	3128
2870	5	3128
2912	5	3128
3082	5	3128
3128	5	3128
3128	5	3128
3128	5	3128


************************



Synchronization with Eventcounts and Sequencers

Synchronization of concurrent processes requires controlling the relative 
ordering of events in the processes.
A new synchronization mechanism is proposed, using 
abstract objects called eventcounts and sequencers, that allows processes
to control the ordering of events directly, rather than using mutual
exclusion to protect manipulations of shared variables that control
ordering of events.  Direct control of ordering seems to simplify
correctness arguments and also simplifies implementation in distributed
systems.  The mechanism is defined formally, <B>and the</B>n several
examples of its use are given.  The relationship of the mechanism
to protection mechanisms in the system is explained; in particular,
eventcounts are shown to be applicable to situations where confinement
of information matters.  An implementation of eventcount
s and sequencers in a system with shared memory is described.

CACM February, 1979

Reed, D.
Kanodia, R.

Process synchronization, interprocess communication, distributed
systems, security models, mutual exclusion, semaphores

4.30 4.32

CA790207 DH April 12, 1979  10:03 AM

2320	4	3128
2597	4	3128
2700	4	3128
2777	4	3128
2840	4	3128
2851	4	3128
2865	4	3128
2866	4	3128
2869	4	3128
2895	4	3128
2898	4	3128
2912	4	3128
2938	4	3128
2945	4	3128
2946	4	3128
2946	4	3128
2972	4	3128
3043	4	3128
3128	4	3128
3128	4	3128
3128	4	3128
3128	4	3128
3128	4	3128
3128	4	3128
3128	4	3128
3128	4	3128
3128	4	3128
3144	4	3128
3148	4	3128
3158	4	3128
2150	5	3128
2376	5	3128
2436	5	3128
2597	5	3128
2865	5	3128
2866	5	3128
2870	5	3128
2912	5	3128
3082	5	3128
3128	5	3128
3128	5	3128
3128	5	3128


************************



Synchronization with Eventcounts and Sequencers

Synchronization of concurrent processes requires controlling the relative 
ordering of events in the processes.
A new synchronization mechanism is proposed, using 
abstract objects called eventcounts and sequencers, that allows processes
to control the ordering of events directly, rather than using mutual
exclusion to protect manipulations of shared variables that control
ordering of events.  Direct control of ordering seems to simplify
correctness arguments and also simplifies implementation in distributed
systems.  The mechanism is defined formally, and then several
examples of its use are given.  The relationship <B>of the</B> mechanism
to protection mechanisms in the system is explained; in particular,
eventcounts are shown to be applicable to situations where confinement
of information matters.  An implementation of eventcount
s and sequencers in a system with shared memory is described.

CACM February, 1979

Reed, D.
Kanodia, R.

Process synchronization, interprocess communication, distributed
systems, security models, mutual exclusion, semaphores

4.30 4.32

CA790207 DH April 12, 1979  10:03 AM

2320	4	3128
2597	4	3128
2700	4	3128
2777	4	3128
2840	4	3128
2851	4	3128
2865	4	3128
2866	4	3128
2869	4	3128
2895	4	3128
2898	4	3128
2912	4	3128
2938	4	3128
2945	4	3128
2946	4	3128
2946	4	3128
2972	4	3128
3043	4	3128
3128	4	3128
3128	4	3128
3128	4	3128
3128	4	3128
3128	4	3128
3128	4	3128
3128	4	3128
3128	4	3128
3128	4	3128
3144	4	3128
3148	4	3128
3158	4	3128
2150	5	3128
2376	5	3128
2436	5	3128
2597	5	3128
2865	5	3128
2866	5	3128
2870	5	3128
2912	5	3128
3082	5	3128
3128	5	3128
3128	5	3128
3128	5	3128


************************

************************
Document:  CACM-2342.html
************************


Interference Between Communicating Parallel Processes

Various kinds of interference between communicating
parallel processes have been examined by 
Dijkstra, Knuth, and others.  Solutions have been given
for the mutual exclusion problem and associated 
subproblems, in the form of parallel programs, and informal
proofs of correctness have been given for 
these solutions.  In this paper a system of parallel
processes is regarded as a machine which proceeds 
from one state S (i.e. a collection of pertinent data
values and process configurations) to a next state 
S' <B>in a</B>ccordance with a transition rule S --> S'.  A
set of such rules yields sequences of states, which 
dictate the system's behavior.  The mutual exclusion problem
and the associated subproblems are formulated 
as questions of inclusion between sets of states, or
of the existence of certain sequences.  A mechanical 
proof procedure is shown, which will either verify (prove
the correctness of ) or discredit (prove the 
incorrectness of) an attempted solution, with respect
to any of the interference properties.  It is shown 
how to calculate transition rules from the "partial
rules" by which the individual processes operate. 
 The formation of partial rules and the calculation of
transition rules are both applicable to hardware 
processes as well as to software processes, and
symmetry between processes is not required.

CACM June, 1972

Gilbert, P.
Chandler, W. J.

concurrent programming control, cooperating processes,
formal programs, interference, mutual exclusion, 
operating systems, parallel processes

4.0 4.10 4.30 4.32 4.42 5.24 6.20

CA720603 JB January 31, 1978  8:44 AM

1781	4	2342
1828	4	2342
1854	4	2342
1877	4	2342
1960	4	2342
2150	4	2342
2150	4	2342
2150	4	2342
2228	4	2342
2228	4	2342
2256	4	2342
2256	4	2342
2317	4	2342
2317	4	2342
2319	4	2342
2377	4	2342
2342	4	2342
2342	4	2342
2342	4	2342
2376	4	2342
2376	4	2342
2379	4	2342
2424	4	2342
2482	4	2342
2618	4	2342
2618	4	2342
2618	4	2342
2632	4	2342
2704	4	2342
2723	4	2342
2738	4	2342
2740	4	2342
2741	4	2342
2867	4	2342
3184	4	2342
3184	4	2342
1198	5	2342
1338	5	2342
1749	5	2342
2342	5	2342
2342	5	2342
2342	5	2342


************************



Interference Between Communicating Parallel Processes

Various kinds of interference between communicating
parallel processes have been examined by 
Dijkstra, Knuth, and others.  Solutions have been given
for the mutual exclusion problem and associated 
subproblems, in the form of parallel programs, and informal
proofs of correctness have been given for 
these solutions.  In this paper a system of parallel
processes is regarded as a machine which proceeds 
from one state S (i.e. a collection of pertinent data
values and process configurations) to a next state 
S' in accordance with a transition rule S --> S'.  A
set of such rules yields sequences of states, which 
dictate the system's behavior.  The mutual exclusion problem
and the associated subproblems are formulated 
as questions of inclusion between sets of states, or
<B>of the</B> existence of certain sequences.  A mechanical 
proof procedure is shown, which will either verify (prove
the correctness of ) or discredit (prove the 
incorrectness of) an attempted solution, with respect
to any of the interference properties.  It is shown 
how to calculate transition rules from the "partial
rules" by which the individual processes operate. 
 The formation of partial rules and the calculation of
transition rules are both applicable to hardware 
processes as well as to software processes, and
symmetry between processes is not required.

CACM June, 1972

Gilbert, P.
Chandler, W. J.

concurrent programming control, cooperating processes,
formal programs, interference, mutual exclusion, 
operating systems, parallel processes

4.0 4.10 4.30 4.32 4.42 5.24 6.20

CA720603 JB January 31, 1978  8:44 AM

1781	4	2342
1828	4	2342
1854	4	2342
1877	4	2342
1960	4	2342
2150	4	2342
2150	4	2342
2150	4	2342
2228	4	2342
2228	4	2342
2256	4	2342
2256	4	2342
2317	4	2342
2317	4	2342
2319	4	2342
2377	4	2342
2342	4	2342
2342	4	2342
2342	4	2342
2376	4	2342
2376	4	2342
2379	4	2342
2424	4	2342
2482	4	2342
2618	4	2342
2618	4	2342
2618	4	2342
2632	4	2342
2704	4	2342
2723	4	2342
2738	4	2342
2740	4	2342
2741	4	2342
2867	4	2342
3184	4	2342
3184	4	2342
1198	5	2342
1338	5	2342
1749	5	2342
2342	5	2342
2342	5	2342
2342	5	2342


************************



Interference Between Communicating Parallel Processes

Various kinds of interference between communicating
parallel processes have been examined by 
Dijkstra, Knuth, and others.  Solutions have been given
for the mutual exclusion problem and associated 
subproblems, in the form of parallel programs, and informal
proofs of correctness have been given for 
these solutions.  In this paper a system of parallel
processes is regarded as a machine which proceeds 
from one state S (i.e. a collection of pertinent data
values and process configurations) to a next state 
S' in accordance with a transition rule S --> S'.  A
set of such rules yields sequences of states, which 
dictate the system's behavior.  The mutual exclusion problem
and the associated subproblems are formulated 
as questions of inclusion between sets of states, or
of the existence of certain sequences.  A mechanical 
proof procedure is shown, which will either verify (prove
the correctness of ) or discredit (prove the 
incorrectness of) an attempted solution, with respect
to any of the interference properties.  It is shown 
how to calculate transition rules from the "partial
rules" by which the individual processes operate. 
 The formation of partial rules and the calculation of
transition rules <B>are both</B> applicable to hardware 
processes as well as to software processes, and
symmetry between processes is not required.

CACM June, 1972

Gilbert, P.
Chandler, W. J.

concurrent programming control, cooperating processes,
formal programs, interference, mutual exclusion, 
operating systems, parallel processes

4.0 4.10 4.30 4.32 4.42 5.24 6.20

CA720603 JB January 31, 1978  8:44 AM

1781	4	2342
1828	4	2342
1854	4	2342
1877	4	2342
1960	4	2342
2150	4	2342
2150	4	2342
2150	4	2342
2228	4	2342
2228	4	2342
2256	4	2342
2256	4	2342
2317	4	2342
2317	4	2342
2319	4	2342
2377	4	2342
2342	4	2342
2342	4	2342
2342	4	2342
2376	4	2342
2376	4	2342
2379	4	2342
2424	4	2342
2482	4	2342
2618	4	2342
2618	4	2342
2618	4	2342
2632	4	2342
2704	4	2342
2723	4	2342
2738	4	2342
2740	4	2342
2741	4	2342
2867	4	2342
3184	4	2342
3184	4	2342
1198	5	2342
1338	5	2342
1749	5	2342
2342	5	2342
2342	5	2342
2342	5	2342


************************



Interference Between Communicating Parallel Processes

Various kinds of interference between communicating
parallel processes have been examined by 
Dijkstra, Knuth, and others.  Solutions have been given
for the mutual exclusion problem and associated 
subproblems, in the form of parallel programs, and informal
proofs of correctness have been given for 
these solutions.  In this paper a system of parallel
processes is regarded as a machine which proceeds 
from one state S (i.e. a collection of pertinent data
values and process configurations) to a next state 
S' in accordance with a transition rule S --> S'.  A
set of such rules yields sequences of states, which 
dictate the system's behavior.  The mutual exclusion problem
<B>and the</B> associated subproblems are formulated 
as questions of inclusion between sets of states, or
of the existence of certain sequences.  A mechanical 
proof procedure is shown, which will either verify (prove
the correctness of ) or discredit (prove the 
incorrectness of) an attempted solution, with respect
to any of the interference properties.  It is shown 
how to calculate transition rules from the "partial
rules" by which the individual processes operate. 
 The formation of partial rules and the calculation of
transition rules are both applicable to hardware 
processes as well as to software processes, and
symmetry between processes is not required.

CACM June, 1972

Gilbert, P.
Chandler, W. J.

concurrent programming control, cooperating processes,
formal programs, interference, mutual exclusion, 
operating systems, parallel processes

4.0 4.10 4.30 4.32 4.42 5.24 6.20

CA720603 JB January 31, 1978  8:44 AM

1781	4	2342
1828	4	2342
1854	4	2342
1877	4	2342
1960	4	2342
2150	4	2342
2150	4	2342
2150	4	2342
2228	4	2342
2228	4	2342
2256	4	2342
2256	4	2342
2317	4	2342
2317	4	2342
2319	4	2342
2377	4	2342
2342	4	2342
2342	4	2342
2342	4	2342
2376	4	2342
2376	4	2342
2379	4	2342
2424	4	2342
2482	4	2342
2618	4	2342
2618	4	2342
2618	4	2342
2632	4	2342
2704	4	2342
2723	4	2342
2738	4	2342
2740	4	2342
2741	4	2342
2867	4	2342
3184	4	2342
3184	4	2342
1198	5	2342
1338	5	2342
1749	5	2342
2342	5	2342
2342	5	2342
2342	5	2342


************************

************************
Document:  CACM-0252.html
************************


Programming a Duplex Computer System

This paper describes a method of duplex-computer
programming that has been used with two computers 
<B>in a</B> military defense system.  The method combines special
programs with a basic data processing program 
package.  The duplex operation gives the system greater
reliability.  After achieving the required level 
of integration, both computers do similar processing
on the same inputs and continually cross-check the 
intermediate and final results.

CACM November, 1961

Dow, J.

CA611116 JB March 15, 1978  10:40 PM

252	5	252
252	5	252
252	5	252


************************

************************
Document:  CACM-1455.html
************************


TRAC, A Procedure-Describing Language for the Reactive Typewriter

A description of the TRAC (Text Reckoning
And Compiling) language and processing algorithm 
is given.  The TRAC language was developed as the basis
of a software package for the reactive typewriter. 
 In the TRAC language, one can write procedures for
accepting, naming and storing any character string 
from the typewriter; for modifying any string <B>in a</B>ny way;
for treating any string at any time as an executable 
procedure, or as a name, or as text; and for printing
out any string.  The TRAC language is based upon 
an extension and generalization to character strings
of the programming concept of the "macro."  Through 
the ability of TRAC to accept and store definitions of
procedures, the capabilities of the language can 
be indefinitely extended, and can deal with character
strings, integers and Boolean vector variables.

CACM March, 1966

Mooers, C. N.

CA660317 JB March 3, 1978  11:18 AM

1455	5	1455
1455	5	1455
1455	5	1455
1530	5	1455
1531	5	1455
1565	5	1455
1703	5	1455
1945	5	1455
2036	5	1455
823	6	1455
914	6	1455
915	6	1455
917	6	1455
984	6	1455
989	6	1455
990	6	1455
1012	6	1455
1084	6	1455
1098	6	1455
1122	6	1455
1138	6	1455
1139	6	1455
1141	6	1455
1162	6	1455
1185	6	1455
1200	6	1455
1223	6	1455
1265	6	1455
1336	6	1455
1358	6	1455
1396	6	1455
1455	6	1455
1455	6	1455
1455	6	1455
1455	6	1455
1455	6	1455
1455	6	1455
1477	6	1455
1487	6	1455
1491	6	1455
1496	6	1455
1565	6	1455
205	6	1455
483	6	1455
584	6	1455
669	6	1455
680	6	1455
763	6	1455


************************



TRAC, A Procedure-Describing Language for the Reactive Typewriter

A description of the TRAC (Text Reckoning
And Compiling) language and processing algorithm 
is given.  The TRAC language was developed as the basis
<B>of a</B> software package for the reactive typewriter. 
 In the TRAC language, one can write procedures for
accepting, naming and storing any character string 
from the typewriter; for modifying any string in any way;
for treating any string at any time as an executable 
procedure, or as a name, or as text; and for printing
out any string.  The TRAC language is based upon 
an extension and generalization to character strings
of the programming concept of the "macro."  Through 
the ability of TRAC to accept and store definitions of
procedures, the capabilities of the language can 
be indefinitely extended, and can deal with character
strings, integers and Boolean vector variables.

CACM March, 1966

Mooers, C. N.

CA660317 JB March 3, 1978  11:18 AM

1455	5	1455
1455	5	1455
1455	5	1455
1530	5	1455
1531	5	1455
1565	5	1455
1703	5	1455
1945	5	1455
2036	5	1455
823	6	1455
914	6	1455
915	6	1455
917	6	1455
984	6	1455
989	6	1455
990	6	1455
1012	6	1455
1084	6	1455
1098	6	1455
1122	6	1455
1138	6	1455
1139	6	1455
1141	6	1455
1162	6	1455
1185	6	1455
1200	6	1455
1223	6	1455
1265	6	1455
1336	6	1455
1358	6	1455
1396	6	1455
1455	6	1455
1455	6	1455
1455	6	1455
1455	6	1455
1455	6	1455
1455	6	1455
1477	6	1455
1487	6	1455
1491	6	1455
1496	6	1455
1565	6	1455
205	6	1455
483	6	1455
584	6	1455
669	6	1455
680	6	1455
763	6	1455


************************



TRAC, A Procedure-Describing Language for the Reactive Typewriter

A description of the TRAC (Text Reckoning
And Compiling) language and processing algorithm 
is given.  The TRAC language was developed as the basis
of a software package for the reactive typewriter. 
 In the TRAC language, one can write procedures for
accepting, naming and storing any character string 
from <B>the type</B>writer; for modifying any string in any way;
for treating any string at any time as an executable 
procedure, or as a name, or as text; and for printing
out any string.  The TRAC language is based upon 
an extension and generalization to character strings
of the programming concept of the "macro."  Through 
the ability of TRAC to accept and store definitions of
procedures, the capabilities of the language can 
be indefinitely extended, and can deal with character
strings, integers and Boolean vector variables.

CACM March, 1966

Mooers, C. N.

CA660317 JB March 3, 1978  11:18 AM

1455	5	1455
1455	5	1455
1455	5	1455
1530	5	1455
1531	5	1455
1565	5	1455
1703	5	1455
1945	5	1455
2036	5	1455
823	6	1455
914	6	1455
915	6	1455
917	6	1455
984	6	1455
989	6	1455
990	6	1455
1012	6	1455
1084	6	1455
1098	6	1455
1122	6	1455
1138	6	1455
1139	6	1455
1141	6	1455
1162	6	1455
1185	6	1455
1200	6	1455
1223	6	1455
1265	6	1455
1336	6	1455
1358	6	1455
1396	6	1455
1455	6	1455
1455	6	1455
1455	6	1455
1455	6	1455
1455	6	1455
1455	6	1455
1477	6	1455
1487	6	1455
1491	6	1455
1496	6	1455
1565	6	1455
205	6	1455
483	6	1455
584	6	1455
669	6	1455
680	6	1455
763	6	1455


************************



TRAC, A Procedure-Describing Language for the Reactive Typewriter

A description of the TRAC (Text Reckoning
And Compiling) language and processing algorithm 
is given.  The TRAC language was developed as the basis
of a software package for the reactive typewriter. 
 In the TRAC language, one can write procedures for
accepting, naming and storing any character string 
from the typewriter; for modifying any string in <B>any way</B>;
for treating any string at any time as an executable 
procedure, or as a name, or as text; and for printing
out any string.  The TRAC language is based upon 
an extension and generalization to character strings
of the programming concept of the "macro."  Through 
the ability of TRAC to accept and store definitions of
procedures, the capabilities of the language can 
be indefinitely extended, and can deal with character
strings, integers and Boolean vector variables.

CACM March, 1966

Mooers, C. N.

CA660317 JB March 3, 1978  11:18 AM

1455	5	1455
1455	5	1455
1455	5	1455
1530	5	1455
1531	5	1455
1565	5	1455
1703	5	1455
1945	5	1455
2036	5	1455
823	6	1455
914	6	1455
915	6	1455
917	6	1455
984	6	1455
989	6	1455
990	6	1455
1012	6	1455
1084	6	1455
1098	6	1455
1122	6	1455
1138	6	1455
1139	6	1455
1141	6	1455
1162	6	1455
1185	6	1455
1200	6	1455
1223	6	1455
1265	6	1455
1336	6	1455
1358	6	1455
1396	6	1455
1455	6	1455
1455	6	1455
1455	6	1455
1455	6	1455
1455	6	1455
1455	6	1455
1477	6	1455
1487	6	1455
1491	6	1455
1496	6	1455
1565	6	1455
205	6	1455
483	6	1455
584	6	1455
669	6	1455
680	6	1455
763	6	1455


************************



TRAC, A Procedure-Describing Language for the Reactive Typewriter

A description <B>of the</B> TRAC (Text Reckoning
And Compiling) language and processing algorithm 
is given.  The TRAC language was developed as the basis
of a software package for the reactive typewriter. 
 In the TRAC language, one can write procedures for
accepting, naming and storing any character string 
from the typewriter; for modifying any string in any way;
for treating any string at any time as an executable 
procedure, or as a name, or as text; and for printing
out any string.  The TRAC language is based upon 
an extension and generalization to character strings
of the programming concept of the "macro."  Through 
the ability of TRAC to accept and store definitions of
procedures, the capabilities of the language can 
be indefinitely extended, and can deal with character
strings, integers and Boolean vector variables.

CACM March, 1966

Mooers, C. N.

CA660317 JB March 3, 1978  11:18 AM

1455	5	1455
1455	5	1455
1455	5	1455
1530	5	1455
1531	5	1455
1565	5	1455
1703	5	1455
1945	5	1455
2036	5	1455
823	6	1455
914	6	1455
915	6	1455
917	6	1455
984	6	1455
989	6	1455
990	6	1455
1012	6	1455
1084	6	1455
1098	6	1455
1122	6	1455
1138	6	1455
1139	6	1455
1141	6	1455
1162	6	1455
1185	6	1455
1200	6	1455
1223	6	1455
1265	6	1455
1336	6	1455
1358	6	1455
1396	6	1455
1455	6	1455
1455	6	1455
1455	6	1455
1455	6	1455
1455	6	1455
1455	6	1455
1477	6	1455
1487	6	1455
1491	6	1455
1496	6	1455
1565	6	1455
205	6	1455
483	6	1455
584	6	1455
669	6	1455
680	6	1455
763	6	1455


************************

************************
Document:  CACM-2341.html
************************


Blocks-A New Data type for SNOBOL4

A new data type, called a block, has been implemented
for SNOBOL4.  A block is a three-dimensional 
aggregate of characters in the form of a right parallelepiped,
best thought of as a three-dimensional 
extension to a string.  (The third dimension is used for
overstriking.)  Blocks may be printed, concatenated 
in any of three dimensions, and merged on the basis
of program-defined connection points.  Some blocks 
adapt in size and shape to their environment.  Blocks
and their operations are mainly used for composing 
printable output.  A variety of graphical problems (including
flowcharting, bargraphs, logic diagrams, 
mathematical-equation formation, and text justification
and preparation) have been programmed on a printer 
in what appears to be an easy and natural way.  In addition
to these somewhat specialized applications, 
blocks appear to be a good general purpose device-independent
output formation mechanism especially suitable 
for nonnumerical work.  The concept of a block is largely
language independenthat is, blocks require 
little in the way of specialized syntax and could readily
be absorbed into the external structure of 
most programming languages.

CACM June, 1972

Gimpel, J. F.

character manipulation, output formatting, string
processing, graphics, nonnumerical programming, 
SNOBOL4, <B>data types</B>, two-dimensional mathematics, test processing, flowcharting

4.22 4.41

CA720604 JB January 30, 1978  4:38 PM

1086	4	2341
1132	4	2341
1234	4	2341
1263	4	2341
1265	4	2341
1270	4	2341
1323	4	2341
1358	4	2341
1379	4	2341
1380	4	2341
1453	4	2341
1464	4	2341
1484	4	2341
1491	4	2341
1498	4	2341
1613	4	2341
1614	4	2341
1767	4	2341
1781	4	2341
1781	4	2341
1781	4	2341
1825	4	2341
1860	4	2341
1945	4	2341
2083	4	2341
2178	4	2341
2179	4	2341
2252	4	2341
2325	4	2341
2341	4	2341
2341	4	2341
2341	4	2341
2341	4	2341
2546	4	2341
2645	4	2341
2652	4	2341
2684	4	2341
2842	4	2341
2929	4	2341
2934	4	2341
3069	4	2341
669	4	2341
679	4	2341
691	4	2341
761	4	2341
949	4	2341
989	4	2341
990	5	2341
1466	5	2341
1468	5	2341
2341	5	2341
2341	5	2341
2341	5	2341
2545	5	2341
3184	5	2341
1739	6	2341
1781	6	2341
2341	6	2341


************************



Blocks-A New Data type for SNOBOL4

A new data type, called a block, has been implemented
for SNOBOL4.  A block is a three-dimensional 
aggregate of characters in the form of a right parallelepiped,
best thought of as a three-dimensional 
extension to a string.  (The third dimension is used for
overstriking.)  Blocks may be printed, concatenated 
<B>in a</B>ny of three dimensions, and merged on the basis
of program-defined connection points.  Some blocks 
adapt in size and shape to their environment.  Blocks
and their operations are mainly used for composing 
printable output.  A variety of graphical problems (including
flowcharting, bargraphs, logic diagrams, 
mathematical-equation formation, and text justification
and preparation) have been programmed on a printer 
in what appears to be an easy and natural way.  In addition
to these somewhat specialized applications, 
blocks appear to be a good general purpose device-independent
output formation mechanism especially suitable 
for nonnumerical work.  The concept of a block is largely
language independenthat is, blocks require 
little in the way of specialized syntax and could readily
be absorbed into the external structure of 
most programming languages.

CACM June, 1972

Gimpel, J. F.

character manipulation, output formatting, string
processing, graphics, nonnumerical programming, 
SNOBOL4, data types, two-dimensional mathematics, test processing, flowcharting

4.22 4.41

CA720604 JB January 30, 1978  4:38 PM

1086	4	2341
1132	4	2341
1234	4	2341
1263	4	2341
1265	4	2341
1270	4	2341
1323	4	2341
1358	4	2341
1379	4	2341
1380	4	2341
1453	4	2341
1464	4	2341
1484	4	2341
1491	4	2341
1498	4	2341
1613	4	2341
1614	4	2341
1767	4	2341
1781	4	2341
1781	4	2341
1781	4	2341
1825	4	2341
1860	4	2341
1945	4	2341
2083	4	2341
2178	4	2341
2179	4	2341
2252	4	2341
2325	4	2341
2341	4	2341
2341	4	2341
2341	4	2341
2341	4	2341
2546	4	2341
2645	4	2341
2652	4	2341
2684	4	2341
2842	4	2341
2929	4	2341
2934	4	2341
3069	4	2341
669	4	2341
679	4	2341
691	4	2341
761	4	2341
949	4	2341
989	4	2341
990	5	2341
1466	5	2341
1468	5	2341
2341	5	2341
2341	5	2341
2341	5	2341
2545	5	2341
3184	5	2341
1739	6	2341
1781	6	2341
2341	6	2341


************************



Blocks-A New Data type for SNOBOL4

A new data type, called a block, has been implemented
for SNOBOL4.  A block <B>is a</B> three-dimensional 
aggregate of characters in the form of a right parallelepiped,
best thought of as a three-dimensional 
extension to a string.  (The third dimension is used for
overstriking.)  Blocks may be printed, concatenated 
in any of three dimensions, and merged on the basis
of program-defined connection points.  Some blocks 
adapt in size and shape to their environment.  Blocks
and their operations are mainly used for composing 
printable output.  A variety of graphical problems (including
flowcharting, bargraphs, logic diagrams, 
mathematical-equation formation, and text justification
and preparation) have been programmed on a printer 
in what appears to be an easy and natural way.  In addition
to these somewhat specialized applications, 
blocks appear to be a good general purpose device-independent
output formation mechanism especially suitable 
for nonnumerical work.  The concept of a block is largely
language independenthat is, blocks require 
little in the way of specialized syntax and could readily
be absorbed into the external structure of 
most programming languages.

CACM June, 1972

Gimpel, J. F.

character manipulation, output formatting, string
processing, graphics, nonnumerical programming, 
SNOBOL4, data types, two-dimensional mathematics, test processing, flowcharting

4.22 4.41

CA720604 JB January 30, 1978  4:38 PM

1086	4	2341
1132	4	2341
1234	4	2341
1263	4	2341
1265	4	2341
1270	4	2341
1323	4	2341
1358	4	2341
1379	4	2341
1380	4	2341
1453	4	2341
1464	4	2341
1484	4	2341
1491	4	2341
1498	4	2341
1613	4	2341
1614	4	2341
1767	4	2341
1781	4	2341
1781	4	2341
1781	4	2341
1825	4	2341
1860	4	2341
1945	4	2341
2083	4	2341
2178	4	2341
2179	4	2341
2252	4	2341
2325	4	2341
2341	4	2341
2341	4	2341
2341	4	2341
2341	4	2341
2546	4	2341
2645	4	2341
2652	4	2341
2684	4	2341
2842	4	2341
2929	4	2341
2934	4	2341
3069	4	2341
669	4	2341
679	4	2341
691	4	2341
761	4	2341
949	4	2341
989	4	2341
990	5	2341
1466	5	2341
1468	5	2341
2341	5	2341
2341	5	2341
2341	5	2341
2545	5	2341
3184	5	2341
1739	6	2341
1781	6	2341
2341	6	2341


************************



Blocks-A New Data type for SNOBOL4

A new data type, called a block, has been implemented
for SNOBOL4.  A block is a three-dimensional 
aggregate of characters in the form of a right parallelepiped,
best thought of as a three-dimensional 
extension to a string.  (The third dimension is used for
overstriking.)  Blocks may be printed, concatenated 
in any of three dimensions, and merged on the basis
of program-defined connection points.  Some blocks 
adapt in size and shape to their environment.  Blocks
<B>and the</B>ir operations are mainly used for composing 
printable output.  A variety of graphical problems (including
flowcharting, bargraphs, logic diagrams, 
mathematical-equation formation, and text justification
and preparation) have been programmed on a printer 
in what appears to be an easy and natural way.  In addition
to these somewhat specialized applications, 
blocks appear to be a good general purpose device-independent
output formation mechanism especially suitable 
for nonnumerical work.  The concept of a block is largely
language independenthat is, blocks require 
little in the way of specialized syntax and could readily
be absorbed into the external structure of 
most programming languages.

CACM June, 1972

Gimpel, J. F.

character manipulation, output formatting, string
processing, graphics, nonnumerical programming, 
SNOBOL4, data types, two-dimensional mathematics, test processing, flowcharting

4.22 4.41

CA720604 JB January 30, 1978  4:38 PM

1086	4	2341
1132	4	2341
1234	4	2341
1263	4	2341
1265	4	2341
1270	4	2341
1323	4	2341
1358	4	2341
1379	4	2341
1380	4	2341
1453	4	2341
1464	4	2341
1484	4	2341
1491	4	2341
1498	4	2341
1613	4	2341
1614	4	2341
1767	4	2341
1781	4	2341
1781	4	2341
1781	4	2341
1825	4	2341
1860	4	2341
1945	4	2341
2083	4	2341
2178	4	2341
2179	4	2341
2252	4	2341
2325	4	2341
2341	4	2341
2341	4	2341
2341	4	2341
2341	4	2341
2546	4	2341
2645	4	2341
2652	4	2341
2684	4	2341
2842	4	2341
2929	4	2341
2934	4	2341
3069	4	2341
669	4	2341
679	4	2341
691	4	2341
761	4	2341
949	4	2341
989	4	2341
990	5	2341
1466	5	2341
1468	5	2341
2341	5	2341
2341	5	2341
2341	5	2341
2545	5	2341
3184	5	2341
1739	6	2341
1781	6	2341
2341	6	2341


************************



Blocks-A New Data type for SNOBOL4

A new data type, called a block, has been implemented
for SNOBOL4.  A block is a three-dimensional 
aggregate of characters in the form <B>of a</B> right parallelepiped,
best thought of as a three-dimensional 
extension to a string.  (The third dimension is used for
overstriking.)  Blocks may be printed, concatenated 
in any of three dimensions, and merged on the basis
of program-defined connection points.  Some blocks 
adapt in size and shape to their environment.  Blocks
and their operations are mainly used for composing 
printable output.  A variety of graphical problems (including
flowcharting, bargraphs, logic diagrams, 
mathematical-equation formation, and text justification
and preparation) have been programmed on a printer 
in what appears to be an easy and natural way.  In addition
to these somewhat specialized applications, 
blocks appear to be a good general purpose device-independent
output formation mechanism especially suitable 
for nonnumerical work.  The concept of a block is largely
language independenthat is, blocks require 
little in the way of specialized syntax and could readily
be absorbed into the external structure of 
most programming languages.

CACM June, 1972

Gimpel, J. F.

character manipulation, output formatting, string
processing, graphics, nonnumerical programming, 
SNOBOL4, data types, two-dimensional mathematics, test processing, flowcharting

4.22 4.41

CA720604 JB January 30, 1978  4:38 PM

1086	4	2341
1132	4	2341
1234	4	2341
1263	4	2341
1265	4	2341
1270	4	2341
1323	4	2341
1358	4	2341
1379	4	2341
1380	4	2341
1453	4	2341
1464	4	2341
1484	4	2341
1491	4	2341
1498	4	2341
1613	4	2341
1614	4	2341
1767	4	2341
1781	4	2341
1781	4	2341
1781	4	2341
1825	4	2341
1860	4	2341
1945	4	2341
2083	4	2341
2178	4	2341
2179	4	2341
2252	4	2341
2325	4	2341
2341	4	2341
2341	4	2341
2341	4	2341
2341	4	2341
2546	4	2341
2645	4	2341
2652	4	2341
2684	4	2341
2842	4	2341
2929	4	2341
2934	4	2341
3069	4	2341
669	4	2341
679	4	2341
691	4	2341
761	4	2341
949	4	2341
989	4	2341
990	5	2341
1466	5	2341
1468	5	2341
2341	5	2341
2341	5	2341
2341	5	2341
2545	5	2341
3184	5	2341
1739	6	2341
1781	6	2341
2341	6	2341


************************

************************
Document:  CACM-1844.html
************************


A Modular Computer Sharing System

An alternative approach to the design and organization
<B>of a</B> general purpose interactive multiterminal 
computing system is presented.  The system organization described
is a conceptually simple arrangement 
of a bank of interchangeable computers, each of which
is a memory/processor pair, that are assigned to 
process terminal jobs as they arrive.  One of the computers
serves as the master or control computer 
and supervises the collection and distribution of messages
from and to the remote terminals.  In the 
simplest form there is a disk drive for each connected
terminal.  A crosspoint switching network allows 
any such disk drive to be connected to any computer.
 Thus, while each active terminal user "occupies" 
a dedicated disk drive, he may share the computer with
many other terminal users in a simple manner. 
 The ratio of users to computers is dependent on both
the size and power of the machines used and the 
computation requirements of the particular mix of users.
 This system organization is inherently a simpler 
and therefore more reliable approach to time-sharing computers
and has the potential of a highly available 
system at relatively low cost.  Economic configurations
are possible for a range of systems sizes that 
span at least one order of magnitude.  Finally, problem
programs developed by remote terminal users can 
be run on a dedicated batch system if compatible computers are used.

CACM October, 1969

Baskin, H. B.
Horowitz, E. B.
Tennison, R. D.
Rittenhouse, L. E.

multiple terminal systems, terminal oriented systems,
multiple processor systems, high availability, 
conversational systems, general purpose time-sharing systems,
real-time response system, modular constructed 
systems, modular computer-sharing systems, graphics,
file switch, intercomputer communications, control 
computer, problem computer, roll-in, roll-out

6.21

CA691002 JB February 15, 1978  3:52 PM

1844	5	1844
1844	5	1844
1844	5	1844


************************



A Modular Computer Sharing System

An alternative approach to the design and organization
of a general purpose interactive multiterminal 
computing system is presented.  The system organization described
<B>is a</B> conceptually simple arrangement 
of a bank of interchangeable computers, each of which
is a memory/processor pair, that are assigned to 
process terminal jobs as they arrive.  One of the computers
serves as the master or control computer 
and supervises the collection and distribution of messages
from and to the remote terminals.  In the 
simplest form there is a disk drive for each connected
terminal.  A crosspoint switching network allows 
any such disk drive to be connected to any computer.
 Thus, while each active terminal user "occupies" 
a dedicated disk drive, he may share the computer with
many other terminal users in a simple manner. 
 The ratio of users to computers is dependent on both
the size and power of the machines used and the 
computation requirements of the particular mix of users.
 This system organization is inherently a simpler 
and therefore more reliable approach to time-sharing computers
and has the potential of a highly available 
system at relatively low cost.  Economic configurations
are possible for a range of systems sizes that 
span at least one order of magnitude.  Finally, problem
programs developed by remote terminal users can 
be run on a dedicated batch system if compatible computers are used.

CACM October, 1969

Baskin, H. B.
Horowitz, E. B.
Tennison, R. D.
Rittenhouse, L. E.

multiple terminal systems, terminal oriented systems,
multiple processor systems, high availability, 
conversational systems, general purpose time-sharing systems,
real-time response system, modular constructed 
systems, modular computer-sharing systems, graphics,
file switch, intercomputer communications, control 
computer, problem computer, roll-in, roll-out

6.21

CA691002 JB February 15, 1978  3:52 PM

1844	5	1844
1844	5	1844
1844	5	1844


************************



A Modular Computer Sharing System

An alternative approach to the design and organization
of a general purpose interactive multiterminal 
computing <B>system is</B> presented.  The system organization described
is a conceptually simple arrangement 
of a bank of interchangeable computers, each of which
is a memory/processor pair, that are assigned to 
process terminal jobs as they arrive.  One of the computers
serves as the master or control computer 
and supervises the collection and distribution of messages
from and to the remote terminals.  In the 
simplest form there is a disk drive for each connected
terminal.  A crosspoint switching network allows 
any such disk drive to be connected to any computer.
 Thus, while each active terminal user "occupies" 
a dedicated disk drive, he may share the computer with
many other terminal users in a simple manner. 
 The ratio of users to computers is dependent on both
the size and power of the machines used and the 
computation requirements of the particular mix of users.
 This system organization is inherently a simpler 
and therefore more reliable approach to time-sharing computers
and has the potential of a highly available 
system at relatively low cost.  Economic configurations
are possible for a range of systems sizes that 
span at least one order of magnitude.  Finally, problem
programs developed by remote terminal users can 
be run on a dedicated batch system if compatible computers are used.

CACM October, 1969

Baskin, H. B.
Horowitz, E. B.
Tennison, R. D.
Rittenhouse, L. E.

multiple terminal systems, terminal oriented systems,
multiple processor systems, high availability, 
conversational systems, general purpose time-sharing systems,
real-time response system, modular constructed 
systems, modular computer-sharing systems, graphics,
file switch, intercomputer communications, control 
computer, problem computer, roll-in, roll-out

6.21

CA691002 JB February 15, 1978  3:52 PM

1844	5	1844
1844	5	1844
1844	5	1844


************************



A Modular Computer Sharing System

An alternative approach to the design and organization
of a general purpose interactive multiterminal 
computing system is presented.  The system organization described
is a conceptually simple arrangement 
of a bank of interchangeable computers, each of which
is a memory/processor pair, that are assigned to 
process terminal jobs as they arrive.  One of the computers
serves as the master or control computer 
and supervises the collection and distribution of messages
from and to the remote terminals.  In the 
simplest form there is a disk drive for each connected
terminal.  A crosspoint switching network allows 
any such disk drive to be connected to any computer.
 Thus, while each active terminal user "occupies" 
a dedicated disk drive, he may share the computer with
many other terminal users in a simple manner. 
 The ratio of users to computers is dependent on both
the size and power of the machines used <B>and the</B> 
computation requirements of the particular mix of users.
 This system organization is inherently a simpler 
and therefore more reliable approach to time-sharing computers
and has the potential of a highly available 
system at relatively low cost.  Economic configurations
are possible for a range of systems sizes that 
span at least one order of magnitude.  Finally, problem
programs developed by remote terminal users can 
be run on a dedicated batch system if compatible computers are used.

CACM October, 1969

Baskin, H. B.
Horowitz, E. B.
Tennison, R. D.
Rittenhouse, L. E.

multiple terminal systems, terminal oriented systems,
multiple processor systems, high availability, 
conversational systems, general purpose time-sharing systems,
real-time response system, modular constructed 
systems, modular computer-sharing systems, graphics,
file switch, intercomputer communications, control 
computer, problem computer, roll-in, roll-out

6.21

CA691002 JB February 15, 1978  3:52 PM

1844	5	1844
1844	5	1844
1844	5	1844


************************



A Modular Computer Sharing System

An alternative approach to the design and organization
of a general purpose interactive multiterminal 
computing system is presented.  The system organization described
is a conceptually simple arrangement 
of a bank of interchangeable computers, each of which
is a memory/processor pair, that are assigned to 
process terminal jobs as they arrive.  One <B>of the</B> computers
serves as the master or control computer 
and supervises the collection and distribution of messages
from and to the remote terminals.  In the 
simplest form there is a disk drive for each connected
terminal.  A crosspoint switching network allows 
any such disk drive to be connected to any computer.
 Thus, while each active terminal user "occupies" 
a dedicated disk drive, he may share the computer with
many other terminal users in a simple manner. 
 The ratio of users to computers is dependent on both
the size and power of the machines used and the 
computation requirements of the particular mix of users.
 This system organization is inherently a simpler 
and therefore more reliable approach to time-sharing computers
and has the potential of a highly available 
system at relatively low cost.  Economic configurations
are possible for a range of systems sizes that 
span at least one order of magnitude.  Finally, problem
programs developed by remote terminal users can 
be run on a dedicated batch system if compatible computers are used.

CACM October, 1969

Baskin, H. B.
Horowitz, E. B.
Tennison, R. D.
Rittenhouse, L. E.

multiple terminal systems, terminal oriented systems,
multiple processor systems, high availability, 
conversational systems, general purpose time-sharing systems,
real-time response system, modular constructed 
systems, modular computer-sharing systems, graphics,
file switch, intercomputer communications, control 
computer, problem computer, roll-in, roll-out

6.21

CA691002 JB February 15, 1978  3:52 PM

1844	5	1844
1844	5	1844
1844	5	1844


************************



A Modular Computer Sharing System

An alternative approach to the design and organization
of a general purpose interactive multiterminal 
computing system is presented.  The system organization described
is a conceptually simple arrangement 
of a bank of interchangeable computers, each of which
is a memory/processor pair, that are assigned to 
process terminal jobs as they arrive.  One of the computers
serves as the master or control computer 
and supervises the collection and distribution of messages
from and to the remote terminals.  In the 
simplest form there is a disk drive for each connected
terminal.  A crosspoint switching network allows 
any such disk drive to be connected to any computer.
 Thus, while each active terminal user "occupies" 
a dedicated disk drive, he may share the computer with
many other terminal users <B>in a</B> simple manner. 
 The ratio of users to computers is dependent on both
the size and power of the machines used and the 
computation requirements of the particular mix of users.
 This system organization is inherently a simpler 
and therefore more reliable approach to time-sharing computers
and has the potential of a highly available 
system at relatively low cost.  Economic configurations
are possible for a range of systems sizes that 
span at least one order of magnitude.  Finally, problem
programs developed by remote terminal users can 
be run on a dedicated batch system if compatible computers are used.

CACM October, 1969

Baskin, H. B.
Horowitz, E. B.
Tennison, R. D.
Rittenhouse, L. E.

multiple terminal systems, terminal oriented systems,
multiple processor systems, high availability, 
conversational systems, general purpose time-sharing systems,
real-time response system, modular constructed 
systems, modular computer-sharing systems, graphics,
file switch, intercomputer communications, control 
computer, problem computer, roll-in, roll-out

6.21

CA691002 JB February 15, 1978  3:52 PM

1844	5	1844
1844	5	1844
1844	5	1844


************************

************************
Document:  CACM-1412.html
************************


The Banking Information System Concept

Most large commercial banks have progressed to
the  point where their major accounting applications 
have been automated and more sophisticated usage of
data processing equipment is being sought.  This, 
coupled with the availability of equipment well suited
to real-time, direct access processing,has led 
to development within some banks of the central file
of data base approach toward a banking information 
system.  The banking information system now serves the
two-fold purpose of providing real-time responses 
to inquires about individual account stasus and providing
more complex combinations of information for 
management use.  Both kinds of processing draw upon a
common store of data contained in the direct access 
central file.  This data base includes indexes which
facilitate cross referencing <B>of a</B>ccount information 
so that all relationships between bank and customer may
be discerned.  In introducing the banking information 
system concept, a gradual approach to account cross-referencing
and file conversion is most prudent. 
 Generally, this system must interface with other computer
applications already existing within the bank.

CACM July, 1966

Head, R. V.

CA660702 JB March 2, 1978  9:53 PM

1412	5	1412
1412	5	1412
1412	5	1412


************************



The Banking Information System Concept

Most large commercial banks have progressed to
the  point where their major accounting applications 
have been automated and more sophisticated usage of
data processing equipment is being sought.  This, 
coupled with the availability of equipment well suited
to real-time, direct access processing,has led 
to development within some banks <B>of the</B> central file
of data base approach toward a banking information 
system.  The banking information system now serves the
two-fold purpose of providing real-time responses 
to inquires about individual account stasus and providing
more complex combinations of information for 
management use.  Both kinds of processing draw upon a
common store of data contained in the direct access 
central file.  This data base includes indexes which
facilitate cross referencing of account information 
so that all relationships between bank and customer may
be discerned.  In introducing the banking information 
system concept, a gradual approach to account cross-referencing
and file conversion is most prudent. 
 Generally, this system must interface with other computer
applications already existing within the bank.

CACM July, 1966

Head, R. V.

CA660702 JB March 2, 1978  9:53 PM

1412	5	1412
1412	5	1412
1412	5	1412


************************

************************
Document:  CACM-1033.html
************************


Experimental Personalized Array Translator System

A system designed for intimate man-machine
interaction in a general-purpose problem-solving 
environment is experimentally operational.  The system
utilizers an array-oriented symbolic source language 
containing powerful statement types.  These include numeric,
Boolean, relational and selection operators 
on operands which can be entire arrays.  The system also
permits simple specification of test and argument 
arrays in single statements.  The completely symbolic
operating system includes display and entry of 
program and data.  Sequence control <B>is a</B>ided by an interrupt
switch which allows the user to interact 
with the program during execution. In addition to normal
stored program sequencing, the system provides 
trace options and the ability to enter any statement
for immediate execution.  Present implementation 
of the system is with an interpretive translator on an IBM 1620 computer.

CACM July, 1964

Hellerman, H.

CA640714 JB March 9, 1978  8:02 PM

1033	5	1033
1033	5	1033
1033	5	1033


************************



Experimental Personalized Array Translator System

A system designed for intimate man-machine
interaction in a general-purpose problem-solving 
environment is experimentally operational.  The system
utilizers an array-oriented symbolic source language 
containing powerful statement types.  These include numeric,
Boolean, relational and selection operators 
on operands which can be entire arrays.  The system also
permits simple specification of test and argument 
arrays in single statements.  The completely symbolic
operating system includes display and entry of 
program and data.  Sequence control is aided by an interrupt
switch which allows the user to interact 
with the program during execution. In addition to normal
stored program sequencing, the system provides 
trace options and the ability to enter any statement
for immediate execution.  Present implementation 
of the <B>system is</B> with an interpretive translator on an IBM 1620 computer.

CACM July, 1964

Hellerman, H.

CA640714 JB March 9, 1978  8:02 PM

1033	5	1033
1033	5	1033
1033	5	1033


************************



Experimental Personalized Array Translator System

A system designed for intimate man-machine
interaction in a general-purpose problem-solving 
environment is experimentally operational.  The system
utilizers an array-oriented symbolic source language 
containing powerful statement types.  These include numeric,
Boolean, relational and selection operators 
on operands which can be entire arrays.  The system also
permits simple specification of test and argument 
arrays in single statements.  The completely symbolic
operating system includes display and entry of 
program and data.  Sequence control is aided by an interrupt
switch which allows the user to interact 
with the program during execution. In addition to normal
stored program sequencing, the system provides 
trace options <B>and the</B> ability to enter any statement
for immediate execution.  Present implementation 
of the system is with an interpretive translator on an IBM 1620 computer.

CACM July, 1964

Hellerman, H.

CA640714 JB March 9, 1978  8:02 PM

1033	5	1033
1033	5	1033
1033	5	1033


************************



Experimental Personalized Array Translator System

A system designed for intimate man-machine
interaction in a general-purpose problem-solving 
environment is experimentally operational.  The system
utilizers an array-oriented symbolic source language 
containing powerful statement types.  These include numeric,
Boolean, relational and selection operators 
on operands which can be entire arrays.  The system also
permits simple specification of test and argument 
arrays in single statements.  The completely symbolic
operating system includes display and entry of 
program and data.  Sequence control is aided by an interrupt
switch which allows the user to interact 
with the program during execution. In addition to normal
stored program sequencing, the system provides 
trace options and the ability to enter any statement
for immediate execution.  Present implementation 
<B>of the</B> system is with an interpretive translator on an IBM 1620 computer.

CACM July, 1964

Hellerman, H.

CA640714 JB March 9, 1978  8:02 PM

1033	5	1033
1033	5	1033
1033	5	1033


************************



Experimental Personalized Array Translator System

A system designed for intimate man-machine
interaction <B>in a</B> general-purpose problem-solving 
environment is experimentally operational.  The system
utilizers an array-oriented symbolic source language 
containing powerful statement types.  These include numeric,
Boolean, relational and selection operators 
on operands which can be entire arrays.  The system also
permits simple specification of test and argument 
arrays in single statements.  The completely symbolic
operating system includes display and entry of 
program and data.  Sequence control is aided by an interrupt
switch which allows the user to interact 
with the program during execution. In addition to normal
stored program sequencing, the system provides 
trace options and the ability to enter any statement
for immediate execution.  Present implementation 
of the system is with an interpretive translator on an IBM 1620 computer.

CACM July, 1964

Hellerman, H.

CA640714 JB March 9, 1978  8:02 PM

1033	5	1033
1033	5	1033
1033	5	1033


************************

************************
Document:  CACM-2321.html
************************


On the Interface Between Computers and Data Communications Systems

Future systems that combine computers, digital
terminals, and communications equipment present 
design optimization problems that require reconsideration
of the traditional functional responsibilities 
of the respective subsystems.  Several "standard" interfaces,
by means of which computers and digital 
terminals connect to the communications systems will
be required.  When specifying these interfaces, 
consideration must be given to problems of coordination,
synchronization, error control, signaling, stream 
multiplexing, and switch control, in addition to minimizing
the technological interdependence of specific 
subsystem designs.  A focus on some of the problems is
obtained in a discussion <B>of a</B> detailed specification 
for a particular computer-communications system interface.

CACM July, 1972

Fraser, A. G.

communications, standard interface communications
protocol, virtual channel, multiplexed input/output, 
coordination of input/output

3.81 6.0 6.35

CA720707 JB January 30, 1978  2:46 PM

2321	5	2321
2321	5	2321
2321	5	2321


************************



On the Interface Between Computers and Data Communications Systems

Future systems that combine computers, digital
terminals, and communications equipment present 
design optimization problems that require reconsideration
of the traditional functional responsibilities 
of the respective subsystems.  Several "standard" interfaces,
by means of which computers and digital 
terminals connect to the communications systems will
be required.  When specifying these interfaces, 
consideration must be given to problems of coordination,
synchronization, error control, signaling, stream 
multiplexing, and switch control, <B>in a</B>ddition to minimizing
the technological interdependence of specific 
subsystem designs.  A focus on some of the problems is
obtained in a discussion of a detailed specification 
for a particular computer-communications system interface.

CACM July, 1972

Fraser, A. G.

communications, standard interface communications
protocol, virtual channel, multiplexed input/output, 
coordination of input/output

3.81 6.0 6.35

CA720707 JB January 30, 1978  2:46 PM

2321	5	2321
2321	5	2321
2321	5	2321


************************



On the Interface Between Computers and Data Communications Systems

Future systems that combine computers, digital
terminals, and communications equipment present 
design optimization problems that require reconsideration
<B>of the</B> traditional functional responsibilities 
of the respective subsystems.  Several "standard" interfaces,
by means of which computers and digital 
terminals connect to the communications systems will
be required.  When specifying these interfaces, 
consideration must be given to problems of coordination,
synchronization, error control, signaling, stream 
multiplexing, and switch control, in addition to minimizing
the technological interdependence of specific 
subsystem designs.  A focus on some of the problems is
obtained in a discussion of a detailed specification 
for a particular computer-communications system interface.

CACM July, 1972

Fraser, A. G.

communications, standard interface communications
protocol, virtual channel, multiplexed input/output, 
coordination of input/output

3.81 6.0 6.35

CA720707 JB January 30, 1978  2:46 PM

2321	5	2321
2321	5	2321
2321	5	2321


************************

************************
Document:  CACM-3048.html
************************


Performance Evaluation of Highly Concurrent
Computers by Deterministic Simulation

Simulation is presented as a practical technique
for performance evaluation of alternative 
configurations of highly concurrent computers.  A technique
is described for constructing a detailed 
deterministic simulation model of a system.  In the model
a control stream replaces the instruction and 
data streams of the real system.  Simulation of the
system model yields the timing and resource usage 
statistics needed for performance evaluation, without
the necessity of emulating the system.  As a case 
study, the implementation of a simulator of a model
of the CPU-memory subsystem of the IBM 360/91 is 
described.  The results of evaluating some alternative
system designs are discussed.  The experiments 
reveal that, for the case study, the major bottlenecks
in the system are the memory unit <B>and the</B> fixed 
point unit.  Further, it appears that many of the sophisticated
pipelining and buffering technique simplemented 
in the architecture of the IBM 360/91 are of little
value when high-speed (cache) memory is used, as 
in the IBM 360/195.

CACM November, 1978

Kumar, B.
Davidson, E.

Performance evaluation, deterministic simulation,
control stream, concurrent computers

6.20 8.1

CA781103 DH January 26, 1979  11:26 AM

3048	5	3048
3048	5	3048
3048	5	3048


************************



Performance Evaluation of Highly Concurrent
Computers by Deterministic Simulation

Simulation is presented as a practical technique
for performance evaluation of alternative 
configurations of highly concurrent computers.  A technique
is described for constructing a detailed 
deterministic simulation model of a system.  In the model
a control stream replaces the instruction and 
data streams <B>of the</B> real system.  Simulation of the
system model yields the timing and resource usage 
statistics needed for performance evaluation, without
the necessity of emulating the system.  As a case 
study, the implementation of a simulator of a model
of the CPU-memory subsystem of the IBM 360/91 is 
described.  The results of evaluating some alternative
system designs are discussed.  The experiments 
reveal that, for the case study, the major bottlenecks
in the system are the memory unit and the fixed 
point unit.  Further, it appears that many of the sophisticated
pipelining and buffering technique simplemented 
in the architecture of the IBM 360/91 are of little
value when high-speed (cache) memory is used, as 
in the IBM 360/195.

CACM November, 1978

Kumar, B.
Davidson, E.

Performance evaluation, deterministic simulation,
control stream, concurrent computers

6.20 8.1

CA781103 DH January 26, 1979  11:26 AM

3048	5	3048
3048	5	3048
3048	5	3048


************************



Performance Evaluation of Highly Concurrent
Computers by Deterministic Simulation

Simulation is presented as a practical technique
for performance evaluation <B>of a</B>lternative 
configurations of highly concurrent computers.  A technique
is described for constructing a detailed 
deterministic simulation model of a system.  In the model
a control stream replaces the instruction and 
data streams of the real system.  Simulation of the
system model yields the timing and resource usage 
statistics needed for performance evaluation, without
the necessity of emulating the system.  As a case 
study, the implementation of a simulator of a model
of the CPU-memory subsystem of the IBM 360/91 is 
described.  The results of evaluating some alternative
system designs are discussed.  The experiments 
reveal that, for the case study, the major bottlenecks
in the system are the memory unit and the fixed 
point unit.  Further, it appears that many of the sophisticated
pipelining and buffering technique simplemented 
in the architecture of the IBM 360/91 are of little
value when high-speed (cache) memory is used, as 
in the IBM 360/195.

CACM November, 1978

Kumar, B.
Davidson, E.

Performance evaluation, deterministic simulation,
control stream, concurrent computers

6.20 8.1

CA781103 DH January 26, 1979  11:26 AM

3048	5	3048
3048	5	3048
3048	5	3048


************************

************************
Document:  CACM-3031.html
************************


Abstract Data Types and Software Validation

A data abstraction can be naturally specified
using algebraic axioms.  The virtue of these 
axioms is <B>that the</B>y permit a representation-independent
formal specification of a data type.  An example 
is given which shows how to employ algebraic axioms at
successive levels of implementation.  The  major 
thrust of the paper is twofold.  First, it is shown how
the use of algebraic axiomatizations can simplify 
the process of proving the correctness of an implementation
of an abstract data type.  Second, semi-automatic 
tools are described which can be used both to automate
such proofs of correctness and to derive an immediate 
implementation from the axioms.  This implementation
allows for limited testing of programs at design 
time, before a conventional implementation is accomplished.

CACM December, 1978

Guttag, J.
Horowitz, E.
Musser, D.

Abstract data type, correctness proof,
data type, data structure, specification 

4.34 5.24

CA781208 DH January 18, 1979  2:51 PM   

3030	4	3031
3031	4	3031
3031	4	3031
3049	4	3031
3105	4	3031
3148	4	3031
3150	4	3031
2939	5	3031
2958	5	3031
3031	5	3031
3031	5	3031
3031	5	3031


************************



Abstract Data Types and Software Validation

A data abstraction can be naturally specified
using algebraic axioms.  The virtue of these 
axioms is that they permit a representation-independent
formal specification of a data type.  An example 
is given which shows how to employ algebraic axioms at
successive levels of implementation.  The  major 
thrust of the paper is twofold.  First, it is shown how
the use of algebraic axiomatizations can simplify 
the process of proving the correctness of an implementation
of an abstract data type.  Second, semi-automatic 
tools are described which can be used both to automate
such proofs of correctness and to derive an immediate 
implementation from the axioms.  This implementation
allows for limited testing of programs at design 
time, before a conventional implementation <B>is a</B>ccomplished.

CACM December, 1978

Guttag, J.
Horowitz, E.
Musser, D.

Abstract data type, correctness proof,
data type, data structure, specification 

4.34 5.24

CA781208 DH January 18, 1979  2:51 PM   

3030	4	3031
3031	4	3031
3031	4	3031
3049	4	3031
3105	4	3031
3148	4	3031
3150	4	3031
2939	5	3031
2958	5	3031
3031	5	3031
3031	5	3031
3031	5	3031


************************



Abstract Data Types and Software Validation

A data abstraction can be naturally specified
using algebraic axioms.  The virtue of these 
axioms is that they permit a representation-independent
formal specification <B>of a</B> data type.  An example 
is given which shows how to employ algebraic axioms at
successive levels of implementation.  The  major 
thrust of the paper is twofold.  First, it is shown how
the use of algebraic axiomatizations can simplify 
the process of proving the correctness of an implementation
of an abstract data type.  Second, semi-automatic 
tools are described which can be used both to automate
such proofs of correctness and to derive an immediate 
implementation from the axioms.  This implementation
allows for limited testing of programs at design 
time, before a conventional implementation is accomplished.

CACM December, 1978

Guttag, J.
Horowitz, E.
Musser, D.

Abstract data type, correctness proof,
data type, data structure, specification 

4.34 5.24

CA781208 DH January 18, 1979  2:51 PM   

3030	4	3031
3031	4	3031
3031	4	3031
3049	4	3031
3105	4	3031
3148	4	3031
3150	4	3031
2939	5	3031
2958	5	3031
3031	5	3031
3031	5	3031
3031	5	3031


************************



Abstract Data Types and Software Validation

A data abstraction can be naturally specified
using algebraic axioms.  The virtue <B>of the</B>se 
axioms is that they permit a representation-independent
formal specification of a data type.  An example 
is given which shows how to employ algebraic axioms at
successive levels of implementation.  The  major 
thrust of the paper is twofold.  First, it is shown how
the use of algebraic axiomatizations can simplify 
the process of proving the correctness of an implementation
of an abstract data type.  Second, semi-automatic 
tools are described which can be used both to automate
such proofs of correctness and to derive an immediate 
implementation from the axioms.  This implementation
allows for limited testing of programs at design 
time, before a conventional implementation is accomplished.

CACM December, 1978

Guttag, J.
Horowitz, E.
Musser, D.

Abstract data type, correctness proof,
data type, data structure, specification 

4.34 5.24

CA781208 DH January 18, 1979  2:51 PM   

3030	4	3031
3031	4	3031
3031	4	3031
3049	4	3031
3105	4	3031
3148	4	3031
3150	4	3031
2939	5	3031
2958	5	3031
3031	5	3031
3031	5	3031
3031	5	3031


************************

************************
Document:  CACM-2940.html
************************


Abstraction and Verification in Alphard: Defining
and Specifying Iteration and Generators

The Alphard "form" provides the programmer with
a great deal of control over the implementation 
of abstract data types.  In this paper the abstraction techniques
are extended from simple data representation 
and function definition to the iteration statement, the
most important poin t of interaction between data 
and the control structure <B>of the</B> language itself.  A
means of specializing Alphard's loops to operate 
on abstract entities without explicit dependence on the
representation of those entities is in troduced. 
 Specification and verification techniques that allow
the properties of the generators for such iterations 
to be expressed in the form of proof rules are developed.
 Results are obtained that for common special 
cases of these loops are essentially identical to the
corresponding constructs in other languages.  A 
means of showing that a generator will terminate is also provided.

CACM August, 1977

Shaw, M.
Wulf, W. A.

abstraction and representation, abstract data types,
assertions, control specialization, correctness, 
generators,invariants, iteration statements, modular
decomposition, program specifications, programming 
languages, programming methodology, proofs of correctness, types, verification

4.20 5.24

CA770803 JB December 28, 1977  7:59 AM

2940	5	2940
2940	5	2940
2940	5	2940
3150	5	2940
2060	6	2940
2704	6	2940
2842	6	2940
2939	6	2940
2940	6	2940
2941	6	2940
2943	6	2940
3073	6	2940
3148	6	2940


************************



Abstraction and Verification in Alphard: Defining
and Specifying Iteration and Generators

The Alphard "form" provides the programmer with
a great deal of control over the implementation 
<B>of a</B>bstract data types.  In this paper the abstraction techniques
are extended from simple data representation 
and function definition to the iteration statement, the
most important poin t of interaction between data 
and the control structure of the language itself.  A
means of specializing Alphard's loops to operate 
on abstract entities without explicit dependence on the
representation of those entities is in troduced. 
 Specification and verification techniques that allow
the properties of the generators for such iterations 
to be expressed in the form of proof rules are developed.
 Results are obtained that for common special 
cases of these loops are essentially identical to the
corresponding constructs in other languages.  A 
means of showing that a generator will terminate is also provided.

CACM August, 1977

Shaw, M.
Wulf, W. A.

abstraction and representation, abstract data types,
assertions, control specialization, correctness, 
generators,invariants, iteration statements, modular
decomposition, program specifications, programming 
languages, programming methodology, proofs of correctness, types, verification

4.20 5.24

CA770803 JB December 28, 1977  7:59 AM

2940	5	2940
2940	5	2940
2940	5	2940
3150	5	2940
2060	6	2940
2704	6	2940
2842	6	2940
2939	6	2940
2940	6	2940
2941	6	2940
2943	6	2940
3073	6	2940
3148	6	2940


************************



Abstraction and Verification in Alphard: Defining
and Specifying Iteration and Generators

The Alphard "form" provides the programmer with
a great deal of control over the implementation 
of abstract data types.  In this paper the abstraction techniques
are extended from simple data representation 
and function definition to the iteration statement, the
most important poin t of interaction <B>between data</B> 
and the control structure of the language itself.  A
means of specializing Alphard's loops to operate 
on abstract entities without explicit dependence on the
representation of those entities is in troduced. 
 Specification and verification techniques that allow
the properties of the generators for such iterations 
to be expressed in the form of proof rules are developed.
 Results are obtained that for common special 
cases of these loops are essentially identical to the
corresponding constructs in other languages.  A 
means of showing that a generator will terminate is also provided.

CACM August, 1977

Shaw, M.
Wulf, W. A.

abstraction and representation, abstract data types,
assertions, control specialization, correctness, 
generators,invariants, iteration statements, modular
decomposition, program specifications, programming 
languages, programming methodology, proofs of correctness, types, verification

4.20 5.24

CA770803 JB December 28, 1977  7:59 AM

2940	5	2940
2940	5	2940
2940	5	2940
3150	5	2940
2060	6	2940
2704	6	2940
2842	6	2940
2939	6	2940
2940	6	2940
2941	6	2940
2943	6	2940
3073	6	2940
3148	6	2940


************************



Abstraction and Verification in Alphard: Defining
and Specifying Iteration and Generators

The Alphard "form" provides the programmer with
a great deal of control over the implementation 
of abstract data types.  In this paper the abstraction techniques
are extended from simple data representation 
and function definition to the iteration statement, the
most important poin t of interaction between data 
and the control structure of the language itself.  A
means of specializing Alphard's loops to operate 
on abstract entities without explicit dependence on the
representation of those entities is in troduced. 
 Specification and verification techniques that allow
the properties of the generators for such iterations 
to be expressed in the form of proof rules are developed.
 Results are obtained that for common special 
cases of these loops are essentially identical to the
corresponding constructs in other languages.  A 
means of showing that a generator will terminate <B>is a</B>lso provided.

CACM August, 1977

Shaw, M.
Wulf, W. A.

abstraction and representation, abstract data types,
assertions, control specialization, correctness, 
generators,invariants, iteration statements, modular
decomposition, program specifications, programming 
languages, programming methodology, proofs of correctness, types, verification

4.20 5.24

CA770803 JB December 28, 1977  7:59 AM

2940	5	2940
2940	5	2940
2940	5	2940
3150	5	2940
2060	6	2940
2704	6	2940
2842	6	2940
2939	6	2940
2940	6	2940
2941	6	2940
2943	6	2940
3073	6	2940
3148	6	2940


************************



Abstraction and Verification in Alphard: Defining
and Specifying Iteration and Generators

The Alphard "form" provides the programmer with
a great deal of control over the implementation 
of abstract data types.  In this paper the abstraction techniques
are extended from simple data representation 
and function definition to the iteration statement, the
most important poin t of interaction between data 
<B>and the</B> control structure of the language itself.  A
means of specializing Alphard's loops to operate 
on abstract entities without explicit dependence on the
representation of those entities is in troduced. 
 Specification and verification techniques that allow
the properties of the generators for such iterations 
to be expressed in the form of proof rules are developed.
 Results are obtained that for common special 
cases of these loops are essentially identical to the
corresponding constructs in other languages.  A 
means of showing that a generator will terminate is also provided.

CACM August, 1977

Shaw, M.
Wulf, W. A.

abstraction and representation, abstract data types,
assertions, control specialization, correctness, 
generators,invariants, iteration statements, modular
decomposition, program specifications, programming 
languages, programming methodology, proofs of correctness, types, verification

4.20 5.24

CA770803 JB December 28, 1977  7:59 AM

2940	5	2940
2940	5	2940
2940	5	2940
3150	5	2940
2060	6	2940
2704	6	2940
2842	6	2940
2939	6	2940
2940	6	2940
2941	6	2940
2943	6	2940
3073	6	2940
3148	6	2940


************************



Abstraction and Verification in Alphard: Defining
and Specifying Iteration and Generators

The Alphard "form" provides the programmer with
a great deal of control over the implementation 
of abstract <B>data types</B>.  In this paper the abstraction techniques
are extended from simple data representation 
and function definition to the iteration statement, the
most important poin t of interaction between data 
and the control structure of the language itself.  A
means of specializing Alphard's loops to operate 
on abstract entities without explicit dependence on the
representation of those entities is in troduced. 
 Specification and verification techniques that allow
the properties of the generators for such iterations 
to be expressed in the form of proof rules are developed.
 Results are obtained that for common special 
cases of these loops are essentially identical to the
corresponding constructs in other languages.  A 
means of showing that a generator will terminate is also provided.

CACM August, 1977

Shaw, M.
Wulf, W. A.

abstraction and representation, abstract data types,
assertions, control specialization, correctness, 
generators,invariants, iteration statements, modular
decomposition, program specifications, programming 
languages, programming methodology, proofs of correctness, types, verification

4.20 5.24

CA770803 JB December 28, 1977  7:59 AM

2940	5	2940
2940	5	2940
2940	5	2940
3150	5	2940
2060	6	2940
2704	6	2940
2842	6	2940
2939	6	2940
2940	6	2940
2941	6	2940
2943	6	2940
3073	6	2940
3148	6	2940


************************

************************
Document:  CACM-2560.html
************************


A Queuing Model of a Multiprogrammed
Computer with a Two-Level Storage System

The results are presented of an analysis of
a probabilistic model of a multiprogrammed computer 
system with a two-level storage system in which there
is sequential dependency of accesses between the 
devices.  Expressions are obtained for the long-run probability
that both the CPU and each <B>of the</B> storage 
devices are busy.  Some numerical results are given which
quantify the gains in CPU utilization obtainable 
by multiprogramming in the presence of this type of storage system.

CACM January, 1973

Shedler, G. S.

multiprogrammed computer system, storage system, hierarchical index sets

4.32

CA730101 JB January 24, 1978  4:55 PM

2560	5	2560
2560	5	2560
2560	5	2560


************************



A Queuing Model <B>of a</B> Multiprogrammed
Computer with a Two-Level Storage System

The results are presented of an analysis of
a probabilistic model of a multiprogrammed computer 
system with a two-level storage system in which there
is sequential dependency of accesses between the 
devices.  Expressions are obtained for the long-run probability
that both the CPU and each of the storage 
devices are busy.  Some numerical results are given which
quantify the gains in CPU utilization obtainable 
by multiprogramming in the presence of this type of storage system.

CACM January, 1973

Shedler, G. S.

multiprogrammed computer system, storage system, hierarchical index sets

4.32

CA730101 JB January 24, 1978  4:55 PM

2560	5	2560
2560	5	2560
2560	5	2560


************************



A Queuing Model of a Multiprogrammed
Computer with a Two-Level Storage System

The results are presented of an analysis of
a probabilistic model of a multiprogrammed computer 
system with a two-level storage system in which there
is sequential dependency of accesses between the 
devices.  Expressions are obtained for the long-run probability
that both the CPU and each of the storage 
devices are busy.  Some numerical results are given which
quantify the gains in CPU utilization obtainable 
by multiprogramming in the presence of this <B>type of</B> storage system.

CACM January, 1973

Shedler, G. S.

multiprogrammed computer system, storage system, hierarchical index sets

4.32

CA730101 JB January 24, 1978  4:55 PM

2560	5	2560
2560	5	2560
2560	5	2560


************************

************************
Document:  CACM-2931.html
************************


Logic and Programming Languages

Logic has been long in terested in whether answers
to certain questions are computable in principle, 
since the outcome puts bounds on the possibilities of
formalization.  More recently, precise comparisons 
in the efficiency of decision methods have become available
through the developments in complexity theory. 
 These, however, are applications to logic, and a big question
is whether methods of logic have significance 
in the other direction for the more applied parts of
computability theory.  Programming languages offer 
an obvious opportunity as their syntactic formalization
is well advanced; however, the semantical theory 
can hardly be said to be complete.  Though we have
many examples, we have still to give wide-ranging 
mathematical answers to these queries:  What is a machine?
 What is a computable process?  How (or how 
well) does a machine simulate a process?  Programs naturally
enter in giving descriptions of processes. 
 The definition of the precise meaning of a program
then requires us to explain what are the objects 
of computation (in a way, the statics of the problem)
and how they are to be transformed (the dynamics). 
 So far the theories of automata and of nets, though
most in teresting for dynamics, have formalized only 
a portion of the field, and there has been perhaps too
much concentration on the finite-state and algebraic 
aspects.  It would seem <B>that the</B> understanding of higher-level
program features involves us with infinite 
objects and forces us to pass through several levels
of explanation to go from the conceptual ideas to 
the final simulation on a real machine.  These levels
can be made mathematically exact if we can find 
the right abstractions to represent the necessary structures.
 The experience of many independent workers 
with the method of data types as lattices (or partial
orderings) under an information content ordering, 
and with their continuous mappings, has demonstrated the
flexibility of this approach in providing definitions 
and proofs, which are clean and without undue dependence
on implementations.  Nevertheless much remains 
to be done in showing how abstract conceptualizations
can (or cannot) be actualized before we can say 
we have a unified theory.

CACM September, 1977

Scott, D. S.

logic, programming languages, automata, denotational
semantics, a-calculus models, computability, 
partial functions, approximation, function spaces

1.2 4.20 5.21 5.24 5.27

CA770902 JB December 28, 1977  6:49 AM

2931	5	2931
2931	5	2931
2931	5	2931


************************



Logic and Programming Languages

Logic has been long in terested in whether answers
to certain questions are computable in principle, 
since the outcome puts bounds on the possibilities of
formalization.  More recently, precise comparisons 
in the efficiency of decision methods have become available
through the developments in complexity theory. 
 These, however, are applications to logic, and a big question
is whether methods of logic have significance 
in the other direction for the more applied parts of
computability theory.  Programming languages offer 
an obvious opportunity as their syntactic formalization
is well advanced; however, the semantical theory 
can hardly be said to be complete.  Though we have
many examples, we have still to give wide-ranging 
mathematical answers to these queries:  What <B>is a</B> machine?
 What is a computable process?  How (or how 
well) does a machine simulate a process?  Programs naturally
enter in giving descriptions of processes. 
 The definition of the precise meaning of a program
then requires us to explain what are the objects 
of computation (in a way, the statics of the problem)
and how they are to be transformed (the dynamics). 
 So far the theories of automata and of nets, though
most in teresting for dynamics, have formalized only 
a portion of the field, and there has been perhaps too
much concentration on the finite-state and algebraic 
aspects.  It would seem that the understanding of higher-level
program features involves us with infinite 
objects and forces us to pass through several levels
of explanation to go from the conceptual ideas to 
the final simulation on a real machine.  These levels
can be made mathematically exact if we can find 
the right abstractions to represent the necessary structures.
 The experience of many independent workers 
with the method of data types as lattices (or partial
orderings) under an information content ordering, 
and with their continuous mappings, has demonstrated the
flexibility of this approach in providing definitions 
and proofs, which are clean and without undue dependence
on implementations.  Nevertheless much remains 
to be done in showing how abstract conceptualizations
can (or cannot) be actualized before we can say 
we have a unified theory.

CACM September, 1977

Scott, D. S.

logic, programming languages, automata, denotational
semantics, a-calculus models, computability, 
partial functions, approximation, function spaces

1.2 4.20 5.21 5.24 5.27

CA770902 JB December 28, 1977  6:49 AM

2931	5	2931
2931	5	2931
2931	5	2931


************************



Logic and Programming Languages

Logic has been long in terested in whether answers
to certain questions are computable in principle, 
since the outcome puts bounds on the possibilities of
formalization.  More recently, precise comparisons 
in the efficiency of decision methods have become available
through the developments in complexity theory. 
 These, however, are applications to logic, and a big question
is whether methods of logic have significance 
in the other direction for the more applied parts of
computability theory.  Programming languages offer 
an obvious opportunity as their syntactic formalization
is well advanced; however, the semantical theory 
can hardly be said to be complete.  Though we have
many examples, we have still to give wide-ranging 
mathematical answers to these queries:  What is a machine?
 What is a computable process?  How (or how 
well) does a machine simulate <B>a process?</B>  Programs naturally
enter in giving descriptions of processes. 
 The definition of the precise meaning of a program
then requires us to explain what are the objects 
of computation (in a way, the statics of the problem)
and how they are to be transformed (the dynamics). 
 So far the theories of automata and of nets, though
most in teresting for dynamics, have formalized only 
a portion of the field, and there has been perhaps too
much concentration on the finite-state and algebraic 
aspects.  It would seem that the understanding of higher-level
program features involves us with infinite 
objects and forces us to pass through several levels
of explanation to go from the conceptual ideas to 
the final simulation on a real machine.  These levels
can be made mathematically exact if we can find 
the right abstractions to represent the necessary structures.
 The experience of many independent workers 
with the method of data types as lattices (or partial
orderings) under an information content ordering, 
and with their continuous mappings, has demonstrated the
flexibility of this approach in providing definitions 
and proofs, which are clean and without undue dependence
on implementations.  Nevertheless much remains 
to be done in showing how abstract conceptualizations
can (or cannot) be actualized before we can say 
we have a unified theory.

CACM September, 1977

Scott, D. S.

logic, programming languages, automata, denotational
semantics, a-calculus models, computability, 
partial functions, approximation, function spaces

1.2 4.20 5.21 5.24 5.27

CA770902 JB December 28, 1977  6:49 AM

2931	5	2931
2931	5	2931
2931	5	2931


************************



Logic and Programming Languages

Logic has been long in terested in whether answers
to certain questions are computable in principle, 
since the outcome puts bounds on the possibilities of
formalization.  More recently, precise comparisons 
in the efficiency of decision methods have become available
through the developments in complexity theory. 
 These, however, are applications to logic, and a big question
is whether methods of logic have significance 
in the other direction for the more applied parts of
computability theory.  Programming languages offer 
an obvious opportunity as their syntactic formalization
is well advanced; however, the semantical theory 
can hardly be said to be complete.  Though we have
many examples, we have still to give wide-ranging 
mathematical answers to these queries:  What is a machine?
 What is a computable process?  How (or how 
well) does a machine simulate a process?  Programs naturally
enter in giving descriptions of processes. 
 The definition of the precise meaning <B>of a</B> program
then requires us to explain what are the objects 
of computation (in a way, the statics of the problem)
and how they are to be transformed (the dynamics). 
 So far the theories of automata and of nets, though
most in teresting for dynamics, have formalized only 
a portion of the field, and there has been perhaps too
much concentration on the finite-state and algebraic 
aspects.  It would seem that the understanding of higher-level
program features involves us with infinite 
objects and forces us to pass through several levels
of explanation to go from the conceptual ideas to 
the final simulation on a real machine.  These levels
can be made mathematically exact if we can find 
the right abstractions to represent the necessary structures.
 The experience of many independent workers 
with the method of data types as lattices (or partial
orderings) under an information content ordering, 
and with their continuous mappings, has demonstrated the
flexibility of this approach in providing definitions 
and proofs, which are clean and without undue dependence
on implementations.  Nevertheless much remains 
to be done in showing how abstract conceptualizations
can (or cannot) be actualized before we can say 
we have a unified theory.

CACM September, 1977

Scott, D. S.

logic, programming languages, automata, denotational
semantics, a-calculus models, computability, 
partial functions, approximation, function spaces

1.2 4.20 5.21 5.24 5.27

CA770902 JB December 28, 1977  6:49 AM

2931	5	2931
2931	5	2931
2931	5	2931


************************



Logic and Programming Languages

Logic has been long in terested in whether answers
to certain questions are computable in principle, 
since the outcome puts bounds on the possibilities of
formalization.  More recently, precise comparisons 
in the efficiency of decision methods have become available
through the developments in complexity theory. 
 These, however, are applications to logic, and a big question
is whether methods of logic have significance 
in the other direction for the more applied parts of
computability theory.  Programming languages offer 
an obvious opportunity as their syntactic formalization
is well advanced; however, the semantical theory 
can hardly be said to be complete.  Though we have
many examples, we have still to give wide-ranging 
mathematical answers to these queries:  What is a machine?
 What is a computable process?  How (or how 
well) does a machine simulate a process?  Programs naturally
enter in giving descriptions of processes. 
 The definition <B>of the</B> precise meaning of a program
then requires us to explain what are the objects 
of computation (in a way, the statics of the problem)
and how they are to be transformed (the dynamics). 
 So far the theories of automata and of nets, though
most in teresting for dynamics, have formalized only 
a portion of the field, and there has been perhaps too
much concentration on the finite-state and algebraic 
aspects.  It would seem that the understanding of higher-level
program features involves us with infinite 
objects and forces us to pass through several levels
of explanation to go from the conceptual ideas to 
the final simulation on a real machine.  These levels
can be made mathematically exact if we can find 
the right abstractions to represent the necessary structures.
 The experience of many independent workers 
with the method of data types as lattices (or partial
orderings) under an information content ordering, 
and with their continuous mappings, has demonstrated the
flexibility of this approach in providing definitions 
and proofs, which are clean and without undue dependence
on implementations.  Nevertheless much remains 
to be done in showing how abstract conceptualizations
can (or cannot) be actualized before we can say 
we have a unified theory.

CACM September, 1977

Scott, D. S.

logic, programming languages, automata, denotational
semantics, a-calculus models, computability, 
partial functions, approximation, function spaces

1.2 4.20 5.21 5.24 5.27

CA770902 JB December 28, 1977  6:49 AM

2931	5	2931
2931	5	2931
2931	5	2931


************************



Logic and Programming Languages

Logic has been long in terested in whether answers
to certain questions are computable in principle, 
since the outcome puts bounds on the possibilities of
formalization.  More recently, precise comparisons 
in the efficiency of decision methods have become available
through the developments in complexity theory. 
 These, however, are applications to logic, and a big question
is whether methods of logic have significance 
in the other direction for the more applied parts of
computability theory.  Programming languages offer 
an obvious opportunity as their syntactic formalization
is well advanced; however, the semantical theory 
can hardly be said to be complete.  Though we have
many examples, we have still to give wide-ranging 
mathematical answers to these queries:  What is a machine?
 What is a computable process?  How (or how 
well) does a machine simulate a process?  Programs naturally
enter in giving descriptions of processes. 
 The definition of the precise meaning of a program
then requires us to explain what are the objects 
of computation (in a way, the statics of the problem)
and how they are to be transformed (the dynamics). 
 So far the theories of automata and of nets, though
most in teresting for dynamics, have formalized only 
a portion of the field, <B>and the</B>re has been perhaps too
much concentration on the finite-state and algebraic 
aspects.  It would seem that the understanding of higher-level
program features involves us with infinite 
objects and forces us to pass through several levels
of explanation to go from the conceptual ideas to 
the final simulation on a real machine.  These levels
can be made mathematically exact if we can find 
the right abstractions to represent the necessary structures.
 The experience of many independent workers 
with the method of data types as lattices (or partial
orderings) under an information content ordering, 
and with their continuous mappings, has demonstrated the
flexibility of this approach in providing definitions 
and proofs, which are clean and without undue dependence
on implementations.  Nevertheless much remains 
to be done in showing how abstract conceptualizations
can (or cannot) be actualized before we can say 
we have a unified theory.

CACM September, 1977

Scott, D. S.

logic, programming languages, automata, denotational
semantics, a-calculus models, computability, 
partial functions, approximation, function spaces

1.2 4.20 5.21 5.24 5.27

CA770902 JB December 28, 1977  6:49 AM

2931	5	2931
2931	5	2931
2931	5	2931


************************



Logic and Programming Languages

Logic has been long in terested in whether answers
to certain questions are computable in principle, 
since the outcome puts bounds on the possibilities of
formalization.  More recently, precise comparisons 
in the efficiency of decision methods have become available
through the developments in complexity theory. 
 These, however, are applications to logic, and a big question
is whether methods of logic have significance 
in the other direction for the more applied parts of
computability theory.  Programming languages offer 
an obvious opportunity as their syntactic formalization
is well advanced; however, the semantical theory 
can hardly be said to be complete.  Though we have
many examples, we have still to give wide-ranging 
mathematical answers to these queries:  What is a machine?
 What is a computable process?  How (or how 
well) does a machine simulate a process?  Programs naturally
enter in giving descriptions of processes. 
 The definition of the precise meaning of a program
then requires us to explain what are the objects 
of computation (<B>in a</B> way, the statics of the problem)
and how they are to be transformed (the dynamics). 
 So far the theories of automata and of nets, though
most in teresting for dynamics, have formalized only 
a portion of the field, and there has been perhaps too
much concentration on the finite-state and algebraic 
aspects.  It would seem that the understanding of higher-level
program features involves us with infinite 
objects and forces us to pass through several levels
of explanation to go from the conceptual ideas to 
the final simulation on a real machine.  These levels
can be made mathematically exact if we can find 
the right abstractions to represent the necessary structures.
 The experience of many independent workers 
with the method of data types as lattices (or partial
orderings) under an information content ordering, 
and with their continuous mappings, has demonstrated the
flexibility of this approach in providing definitions 
and proofs, which are clean and without undue dependence
on implementations.  Nevertheless much remains 
to be done in showing how abstract conceptualizations
can (or cannot) be actualized before we can say 
we have a unified theory.

CACM September, 1977

Scott, D. S.

logic, programming languages, automata, denotational
semantics, a-calculus models, computability, 
partial functions, approximation, function spaces

1.2 4.20 5.21 5.24 5.27

CA770902 JB December 28, 1977  6:49 AM

2931	5	2931
2931	5	2931
2931	5	2931


************************



Logic and Programming Languages

Logic has been long in terested in whether answers
to certain questions are computable in principle, 
since the outcome puts bounds on the possibilities of
formalization.  More recently, precise comparisons 
in the efficiency of decision methods have become available
through the developments in complexity theory. 
 These, however, are applications to logic, and a big question
is whether methods of logic have significance 
in the other direction for the more applied parts of
computability theory.  Programming languages offer 
an obvious opportunity as their syntactic formalization
is well advanced; however, the semantical theory 
can hardly be said to be complete.  Though we have
many examples, we have still to give wide-ranging 
mathematical answers to these queries:  What is a machine?
 What is a computable process?  How (or how 
well) does a machine simulate a process?  Programs naturally
enter in giving descriptions of processes. 
 The definition of the precise meaning of a program
then requires us to explain what are the objects 
of computation (in a way, the statics of the problem)
and how they are to be transformed (the dynamics). 
 So far the theories of automata and of nets, though
most in teresting for dynamics, have formalized only 
a portion of the field, and there has been perhaps too
much concentration on the finite-state and algebraic 
aspects.  It would seem that the understanding of higher-level
program features involves us with infinite 
objects and forces us to pass through several levels
of explanation to go from the conceptual ideas to 
the final simulation on a real machine.  These levels
can be made mathematically exact if we can find 
the right abstractions to represent the necessary structures.
 The experience of many independent workers 
with the method of <B>data types</B> as lattices (or partial
orderings) under an information content ordering, 
and with their continuous mappings, has demonstrated the
flexibility of this approach in providing definitions 
and proofs, which are clean and without undue dependence
on implementations.  Nevertheless much remains 
to be done in showing how abstract conceptualizations
can (or cannot) be actualized before we can say 
we have a unified theory.

CACM September, 1977

Scott, D. S.

logic, programming languages, automata, denotational
semantics, a-calculus models, computability, 
partial functions, approximation, function spaces

1.2 4.20 5.21 5.24 5.27

CA770902 JB December 28, 1977  6:49 AM

2931	5	2931
2931	5	2931
2931	5	2931


************************

************************
Document:  CACM-2194.html
************************


How To Keep the Addresses Short

An algorithm is presented for minimizing the
sum of the lengths of the blocks of coding produced 
by an assembler or compiler when (1) the length of
each computer instruction <B>is a</B>ssumed to be either 
"long" or "short" ("long," if the memory location addressed
is more than a predetermined distance from 
the current location; "short," otherwise), and (2)
there are blocks of instructions whose beginnings 
(origins) are separated by prespecified amounts. For example,
some computers permit either 8-bit addressing 
(interpreted relative to the location counter) or full
16-bit addressing of all of memory.  When assembling 
or compiling two or more blocks of instructions which
have many mutual references in such a computer, 
there is no simple iterative procedure for keeping
as many of the addresses short as possible.  This 
paper demonstrates that a wide class of problems of
this type can be formulated as covering problems 
solvable by means of elementary arithmetic operations
on the column vectors of a ternary matrix.

CACM May, 1971

Richards, D. L.

addressing, assembler, covering problem, integer
programming, variable-length addressing

4.11 4.12 4.21 5.41

CA710505 JB February 3, 1978  2:40 PM

2194	5	2194
2194	5	2194
2194	5	2194
2858	5	2194
3110	5	2194
2194	6	2194
2194	6	2194
2629	6	2194
2858	6	2194


************************



How To Keep the Addresses Short

An algorithm is presented for minimizing the
sum of the lengths of the blocks of coding produced 
by an assembler or compiler when (1) the length of
each computer instruction is assumed to be either 
"long" or "short" ("long," if the memory location addressed
is more than a predetermined distance from 
the current location; "short," otherwise), and (2)
there are blocks of instructions whose beginnings 
(origins) are separated by prespecified amounts. For example,
some computers permit either 8-bit addressing 
(interpreted relative to the location counter) or full
16-bit addressing <B>of a</B>ll of memory.  When assembling 
or compiling two or more blocks of instructions which
have many mutual references in such a computer, 
there is no simple iterative procedure for keeping
as many of the addresses short as possible.  This 
paper demonstrates that a wide class of problems of
this type can be formulated as covering problems 
solvable by means of elementary arithmetic operations
on the column vectors of a ternary matrix.

CACM May, 1971

Richards, D. L.

addressing, assembler, covering problem, integer
programming, variable-length addressing

4.11 4.12 4.21 5.41

CA710505 JB February 3, 1978  2:40 PM

2194	5	2194
2194	5	2194
2194	5	2194
2858	5	2194
3110	5	2194
2194	6	2194
2194	6	2194
2629	6	2194
2858	6	2194


************************



How To Keep the Addresses Short

An algorithm is presented for minimizing the
sum <B>of the</B> lengths of the blocks of coding produced 
by an assembler or compiler when (1) the length of
each computer instruction is assumed to be either 
"long" or "short" ("long," if the memory location addressed
is more than a predetermined distance from 
the current location; "short," otherwise), and (2)
there are blocks of instructions whose beginnings 
(origins) are separated by prespecified amounts. For example,
some computers permit either 8-bit addressing 
(interpreted relative to the location counter) or full
16-bit addressing of all of memory.  When assembling 
or compiling two or more blocks of instructions which
have many mutual references in such a computer, 
there is no simple iterative procedure for keeping
as many of the addresses short as possible.  This 
paper demonstrates that a wide class of problems of
this type can be formulated as covering problems 
solvable by means of elementary arithmetic operations
on the column vectors of a ternary matrix.

CACM May, 1971

Richards, D. L.

addressing, assembler, covering problem, integer
programming, variable-length addressing

4.11 4.12 4.21 5.41

CA710505 JB February 3, 1978  2:40 PM

2194	5	2194
2194	5	2194
2194	5	2194
2858	5	2194
3110	5	2194
2194	6	2194
2194	6	2194
2629	6	2194
2858	6	2194


************************

************************
Document:  CACM-2941.html
************************


Early Experience with Mesa

The experiences of Mesa's first users-primarily
its implementers-are discussed, and some implications 
for Mesa and similar programming languages are suggested.
The specific topics addressed are: module structure 
and its use in defining abstractions, data-structuring
facilities in Mesa, an equivalence algorithm for 
types and type coercions, the benefits of the type system
and why it is breached occasionally, <B>and the</B> 
difficulty of making the treatment of variant records safe.

CACM August, 1977

Geschke, C. M.
Morris, J. H. Jr.
Satterthwaite, E. H.

programming languages, types, modules,
data structures, systems programming

4.22

CA770802 JB December 28, 1977  8:07 AM

1458	4	2941
1523	4	2941
1603	4	2941
1698	4	2941
1747	4	2941
1748	4	2941
1854	4	2941
1877	4	2941
1960	4	2941
2377	4	2941
2378	4	2941
2497	4	2941
2558	4	2941
2625	4	2941
2632	4	2941
2704	4	2941
2723	4	2941
2738	4	2941
2840	4	2941
2866	4	2941
2868	4	2941
2869	4	2941
2939	4	2941
2941	4	2941
2941	4	2941
2941	4	2941
2941	4	2941
2956	4	2941
2958	4	2941
3004	4	2941
3030	4	2941
3030	4	2941
3105	4	2941
3144	4	2941
1471	5	2941
2356	5	2941
2558	5	2941
2651	5	2941
2941	5	2941
2941	5	2941
2941	5	2941
3150	5	2941
2060	6	2941
2704	6	2941
2842	6	2941
2939	6	2941
2940	6	2941
2941	6	2941
2943	6	2941
3073	6	2941
3148	6	2941


************************



Early Experience with Mesa

The experiences of Mesa's first users-primarily
its implementers-are discussed, and some implications 
for Mesa and similar programming languages are suggested.
The specific topics addressed are: module structure 
and its use in defining abstractions, data-structuring
facilities in Mesa, an equivalence algorithm for 
<B>types and</B> type coercions, the benefits of the type system
and why it is breached occasionally, and the 
difficulty of making the treatment of variant records safe.

CACM August, 1977

Geschke, C. M.
Morris, J. H. Jr.
Satterthwaite, E. H.

programming languages, types, modules,
data structures, systems programming

4.22

CA770802 JB December 28, 1977  8:07 AM

1458	4	2941
1523	4	2941
1603	4	2941
1698	4	2941
1747	4	2941
1748	4	2941
1854	4	2941
1877	4	2941
1960	4	2941
2377	4	2941
2378	4	2941
2497	4	2941
2558	4	2941
2625	4	2941
2632	4	2941
2704	4	2941
2723	4	2941
2738	4	2941
2840	4	2941
2866	4	2941
2868	4	2941
2869	4	2941
2939	4	2941
2941	4	2941
2941	4	2941
2941	4	2941
2941	4	2941
2956	4	2941
2958	4	2941
3004	4	2941
3030	4	2941
3030	4	2941
3105	4	2941
3144	4	2941
1471	5	2941
2356	5	2941
2558	5	2941
2651	5	2941
2941	5	2941
2941	5	2941
2941	5	2941
3150	5	2941
2060	6	2941
2704	6	2941
2842	6	2941
2939	6	2941
2940	6	2941
2941	6	2941
2943	6	2941
3073	6	2941
3148	6	2941


************************



Early Experience with Mesa

The experiences of Mesa's first users-primarily
its implementers-are discussed, and some implications 
for Mesa and similar programming languages are suggested.
The specific topics addressed are: module structure 
and its use in defining abstractions, data-structuring
facilities in Mesa, an equivalence algorithm for 
types and type coercions, the benefits <B>of the</B> type system
and why it is breached occasionally, and the 
difficulty of making the treatment of variant records safe.

CACM August, 1977

Geschke, C. M.
Morris, J. H. Jr.
Satterthwaite, E. H.

programming languages, types, modules,
data structures, systems programming

4.22

CA770802 JB December 28, 1977  8:07 AM

1458	4	2941
1523	4	2941
1603	4	2941
1698	4	2941
1747	4	2941
1748	4	2941
1854	4	2941
1877	4	2941
1960	4	2941
2377	4	2941
2378	4	2941
2497	4	2941
2558	4	2941
2625	4	2941
2632	4	2941
2704	4	2941
2723	4	2941
2738	4	2941
2840	4	2941
2866	4	2941
2868	4	2941
2869	4	2941
2939	4	2941
2941	4	2941
2941	4	2941
2941	4	2941
2941	4	2941
2956	4	2941
2958	4	2941
3004	4	2941
3030	4	2941
3030	4	2941
3105	4	2941
3144	4	2941
1471	5	2941
2356	5	2941
2558	5	2941
2651	5	2941
2941	5	2941
2941	5	2941
2941	5	2941
3150	5	2941
2060	6	2941
2704	6	2941
2842	6	2941
2939	6	2941
2940	6	2941
2941	6	2941
2943	6	2941
3073	6	2941
3148	6	2941


************************



Early Experience with Mesa

The experiences of Mesa's first users-primarily
its implementers-are discussed, and some implications 
for Mesa and similar programming languages are suggested.
The specific topics addressed are: module structure 
and its use in defining abstractions, data-structuring
facilities in Mesa, an equivalence algorithm for 
types and type coercions, the benefits of <B>the type</B> system
and why it is breached occasionally, and the 
difficulty of making the treatment of variant records safe.

CACM August, 1977

Geschke, C. M.
Morris, J. H. Jr.
Satterthwaite, E. H.

programming languages, types, modules,
data structures, systems programming

4.22

CA770802 JB December 28, 1977  8:07 AM

1458	4	2941
1523	4	2941
1603	4	2941
1698	4	2941
1747	4	2941
1748	4	2941
1854	4	2941
1877	4	2941
1960	4	2941
2377	4	2941
2378	4	2941
2497	4	2941
2558	4	2941
2625	4	2941
2632	4	2941
2704	4	2941
2723	4	2941
2738	4	2941
2840	4	2941
2866	4	2941
2868	4	2941
2869	4	2941
2939	4	2941
2941	4	2941
2941	4	2941
2941	4	2941
2941	4	2941
2956	4	2941
2958	4	2941
3004	4	2941
3030	4	2941
3030	4	2941
3105	4	2941
3144	4	2941
1471	5	2941
2356	5	2941
2558	5	2941
2651	5	2941
2941	5	2941
2941	5	2941
2941	5	2941
3150	5	2941
2060	6	2941
2704	6	2941
2842	6	2941
2939	6	2941
2940	6	2941
2941	6	2941
2943	6	2941
3073	6	2941
3148	6	2941


************************

************************
Document:  CACM-1489.html
************************


Data, Documentation and Decision Tables

In business data processing systems, it is
necessary to be able to define and document data, 
files, programs and decision rules <B>in a</B> way that adequately
represents both (1) their changing information 
content, and (2) their continuous interaction.  Tabular
description makes this possible, being notably 
objective, through and economical in cost and time when
systems must be analyzed and programs prepared 
or modified.  To show how quickly tabular techniques
make an unfamiliar system manageable, a detailed 
example and a self-test are provided.

CACM January, 1966

Fisher, D. L.

CA660106 JB March 3, 1978  4:13 PM

1489	5	1489
1489	5	1489
1489	5	1489
1548	5	1489
2220	5	1489
2726	5	1489
1172	6	1489
1172	6	1489
1237	6	1489
1327	6	1489
1327	6	1489
1354	6	1489
1354	6	1489
1488	6	1489
1488	6	1489
1489	6	1489
1489	6	1489
1489	6	1489
1548	6	1489
1548	6	1489
250	6	1489
2220	6	1489
2221	6	1489
2263	6	1489


************************

************************
Document:  CACM-3105.html
************************


A Language Extension for Expressing Constraints on Data Access

Controlled sharing of information is needed and
desirable for many applications and is supported 
in operating systems by access control mechanisms.  This
paper shows how to extend programming languages 
to provide controlled sharing.  The extension permits
expression of access constraints on shared data. 
 Access constraints can apply both to simple objects, and
to objects that are components of larger objects, 
such as bank account records <B>in a</B> bank's data base.
 The constraints are stated declaratively, and can 
be enforced by static checking similar to type checking.
 The approach can be used to extend any strongly-typed 
language, but is particularly suitable for extending
languages that support the notion of abstract data 
types. 

CACM May, 1978

Jones, A.
Liskov,B.

Programming languages, access control, data types,
abstract data types, type checking, capabilities

4.20 4.35

CA780502 DH February 26, 1979  3:19 PM

1458	4	3105
1523	4	3105
1603	4	3105
1698	4	3105
1747	4	3105
1748	4	3105
1854	4	3105
1877	4	3105
1960	4	3105
2377	4	3105
2378	4	3105
2497	4	3105
2558	4	3105
2625	4	3105
2626	4	3105
2632	4	3105
2840	4	3105
2868	4	3105
2868	4	3105
2870	4	3105
2876	4	3105
2941	4	3105
3031	4	3105
3105	4	3105
3105	4	3105
3105	4	3105
3105	4	3105
3105	4	3105
3105	4	3105
3144	4	3105
3144	4	3105
3144	4	3105
3148	4	3105
3150	4	3105
1471	5	3105
2625	5	3105
2632	5	3105
2868	5	3105
2939	5	3105
3068	5	3105
3105	5	3105
3105	5	3105
3105	5	3105


************************



A Language Extension for Expressing Constraints on Data Access

Controlled sharing of information is needed and
desirable for many applications and is supported 
in operating systems by access control mechanisms.  This
paper shows how to extend programming languages 
to provide controlled sharing.  The extension permits
expression <B>of a</B>ccess constraints on shared data. 
 Access constraints can apply both to simple objects, and
to objects that are components of larger objects, 
such as bank account records in a bank's data base.
 The constraints are stated declaratively, and can 
be enforced by static checking similar to type checking.
 The approach can be used to extend any strongly-typed 
language, but is particularly suitable for extending
languages that support the notion of abstract data 
types. 

CACM May, 1978

Jones, A.
Liskov,B.

Programming languages, access control, data types,
abstract data types, type checking, capabilities

4.20 4.35

CA780502 DH February 26, 1979  3:19 PM

1458	4	3105
1523	4	3105
1603	4	3105
1698	4	3105
1747	4	3105
1748	4	3105
1854	4	3105
1877	4	3105
1960	4	3105
2377	4	3105
2378	4	3105
2497	4	3105
2558	4	3105
2625	4	3105
2626	4	3105
2632	4	3105
2840	4	3105
2868	4	3105
2868	4	3105
2870	4	3105
2876	4	3105
2941	4	3105
3031	4	3105
3105	4	3105
3105	4	3105
3105	4	3105
3105	4	3105
3105	4	3105
3105	4	3105
3144	4	3105
3144	4	3105
3144	4	3105
3148	4	3105
3150	4	3105
1471	5	3105
2625	5	3105
2632	5	3105
2868	5	3105
2939	5	3105
3068	5	3105
3105	5	3105
3105	5	3105
3105	5	3105


************************



A Language Extension for Expressing Constraints on Data Access

Controlled sharing of information is needed and
desirable for many applications and is supported 
in operating systems by access control mechanisms.  This
paper shows how to extend programming languages 
to provide controlled sharing.  The extension permits
expression of access constraints on shared data. 
 Access constraints can apply both to simple objects, and
to objects that are components of larger objects, 
such as bank account records in a bank's data base.
 The constraints are stated declaratively, and can 
be enforced by static checking similar to type checking.
 The approach can be used to extend any strongly-typed 
language, but is particularly suitable for extending
languages that support the notion of abstract data 
types. 

CACM May, 1978

Jones, A.
Liskov,B.

Programming languages, access control, <B>data types</B>,
abstract data types, type checking, capabilities

4.20 4.35

CA780502 DH February 26, 1979  3:19 PM

1458	4	3105
1523	4	3105
1603	4	3105
1698	4	3105
1747	4	3105
1748	4	3105
1854	4	3105
1877	4	3105
1960	4	3105
2377	4	3105
2378	4	3105
2497	4	3105
2558	4	3105
2625	4	3105
2626	4	3105
2632	4	3105
2840	4	3105
2868	4	3105
2868	4	3105
2870	4	3105
2876	4	3105
2941	4	3105
3031	4	3105
3105	4	3105
3105	4	3105
3105	4	3105
3105	4	3105
3105	4	3105
3105	4	3105
3144	4	3105
3144	4	3105
3144	4	3105
3148	4	3105
3150	4	3105
1471	5	3105
2625	5	3105
2632	5	3105
2868	5	3105
2939	5	3105
3068	5	3105
3105	5	3105
3105	5	3105
3105	5	3105


************************



A Language Extension for Expressing Constraints on Data Access

Controlled sharing of information is needed and
desirable for many applications and is supported 
in operating systems by access control mechanisms.  This
paper shows how to extend programming languages 
to provide controlled sharing.  The extension permits
expression of access constraints on shared data. 
 Access constraints can apply both to simple objects, and
to objects that are components of larger objects, 
such as bank account records in a bank's data base.
 The constraints are stated declaratively, and can 
be enforced by static checking similar to type checking.
 The approach can be used to extend any strongly-typed 
language, but is particularly suitable for extending
languages that support the <B>notion of</B> abstract data 
types. 

CACM May, 1978

Jones, A.
Liskov,B.

Programming languages, access control, data types,
abstract data types, type checking, capabilities

4.20 4.35

CA780502 DH February 26, 1979  3:19 PM

1458	4	3105
1523	4	3105
1603	4	3105
1698	4	3105
1747	4	3105
1748	4	3105
1854	4	3105
1877	4	3105
1960	4	3105
2377	4	3105
2378	4	3105
2497	4	3105
2558	4	3105
2625	4	3105
2626	4	3105
2632	4	3105
2840	4	3105
2868	4	3105
2868	4	3105
2870	4	3105
2876	4	3105
2941	4	3105
3031	4	3105
3105	4	3105
3105	4	3105
3105	4	3105
3105	4	3105
3105	4	3105
3105	4	3105
3144	4	3105
3144	4	3105
3144	4	3105
3148	4	3105
3150	4	3105
1471	5	3105
2625	5	3105
2632	5	3105
2868	5	3105
2939	5	3105
3068	5	3105
3105	5	3105
3105	5	3105
3105	5	3105


************************

************************
Document:  CACM-2749.html
************************


Significant Event Simulation

This paper compares a new method of simulation
organization, called the significant event method, 
with an old one, called the clock pulse method, using
as examples two automobile traffic models.  The 
significant event method is found to be more efficient
than the clock pulse method at low levels of system 
interaction and less efficient at high levels.  A simple
mathematical model for the trade-off in the 
relative running time of the two methods is developed. 
The model aids in choosing between the two simulation 
methods for a particular experiment.  It is concluded
<B>that the</B> significant event method can be of value 
in the simulation of some systems when computational
efficiency is of sufficient importance.

CACM June, 1975

Babich, A. F.
Grason, J.
Parnas, D. L.

simulation organization, event simulation, clock
pulse simulation, significant event simulation.

8.1

CA750604 JB January 9, 1978  1:20 PM

2749	5	2749
2749	5	2749
2749	5	2749


************************



Significant Event Simulation

This paper compares a new method of simulation
organization, called the significant event method, 
with an old one, called the clock pulse method, using
as examples two automobile traffic models.  The 
significant event method is found to be more efficient
than the clock pulse method at low levels of system 
interaction and less efficient at high levels.  A simple
mathematical model for the trade-off in the 
relative running time <B>of the</B> two methods is developed. 
The model aids in choosing between the two simulation 
methods for a particular experiment.  It is concluded
that the significant event method can be of value 
in the simulation of some systems when computational
efficiency is of sufficient importance.

CACM June, 1975

Babich, A. F.
Grason, J.
Parnas, D. L.

simulation organization, event simulation, clock
pulse simulation, significant event simulation.

8.1

CA750604 JB January 9, 1978  1:20 PM

2749	5	2749
2749	5	2749
2749	5	2749


************************

************************
Document:  CACM-2956.html
************************


Some Ideas on Data Types in High-Level Languages

A number of issues are explored concerning the
notion that a data type is a set of values together 
with a set of primitive operations on those values.  Among
these are the need for a notation for iterating 
over the elements of any finite set (instead of the
more narrow for i:= 1 to n notation), the use of 
the domain of an array as a data type, the need for
a simple notation for allowing <B>types of</B> parameters 
to be themselves parameters (but in a restrictive fashion),
and resulting problems with conversion of 
values from one type to another.

CACM June, 1977

Gries, D.
Gehani, N.

data types, generic procedures, programming languages

4.12 4.20 4.22

CA770607 JB December 28, 1977  1:27 PM

2167	4	2956
2723	4	2956
2941	4	2956
2956	4	2956
2956	4	2956
3030	4	2956
1379	5	2956
2651	5	2956
2956	5	2956
2956	5	2956
2956	5	2956
3049	5	2956
2956	6	2956
2958	6	2956
2957	6	2956
2960	6	2956


************************



Some Ideas on Data Types in High-Level Languages

A number of issues are explored concerning the
notion that a data type is a set of values together 
with a set of primitive operations on those values.  Among
these are the need for a notation for iterating 
over the elements of any finite set (instead of the
more narrow for i:= 1 to n notation), the use of 
the domain of an array as a data type, the need for
a simple notation for allowing types of parameters 
to be themselves parameters (but <B>in a</B> restrictive fashion),
and resulting problems with conversion of 
values from one type to another.

CACM June, 1977

Gries, D.
Gehani, N.

data types, generic procedures, programming languages

4.12 4.20 4.22

CA770607 JB December 28, 1977  1:27 PM

2167	4	2956
2723	4	2956
2941	4	2956
2956	4	2956
2956	4	2956
3030	4	2956
1379	5	2956
2651	5	2956
2956	5	2956
2956	5	2956
2956	5	2956
3049	5	2956
2956	6	2956
2958	6	2956
2957	6	2956
2960	6	2956


************************



Some Ideas on Data Types in High-Level Languages

A number of issues are explored concerning the
notion that a data type is a set of values together 
with a set of primitive operations on those values.  Among
these are the need for a notation for iterating 
over the elements <B>of a</B>ny finite set (instead of the
more narrow for i:= 1 to n notation), the use of 
the domain of an array as a data type, the need for
a simple notation for allowing types of parameters 
to be themselves parameters (but in a restrictive fashion),
and resulting problems with conversion of 
values from one type to another.

CACM June, 1977

Gries, D.
Gehani, N.

data types, generic procedures, programming languages

4.12 4.20 4.22

CA770607 JB December 28, 1977  1:27 PM

2167	4	2956
2723	4	2956
2941	4	2956
2956	4	2956
2956	4	2956
3030	4	2956
1379	5	2956
2651	5	2956
2956	5	2956
2956	5	2956
2956	5	2956
3049	5	2956
2956	6	2956
2958	6	2956
2957	6	2956
2960	6	2956


************************



Some Ideas on Data Types in High-Level Languages

A number of issues are explored concerning the
notion that a data type <B>is a</B> set of values together 
with a set of primitive operations on those values.  Among
these are the need for a notation for iterating 
over the elements of any finite set (instead of the
more narrow for i:= 1 to n notation), the use of 
the domain of an array as a data type, the need for
a simple notation for allowing types of parameters 
to be themselves parameters (but in a restrictive fashion),
and resulting problems with conversion of 
values from one type to another.

CACM June, 1977

Gries, D.
Gehani, N.

data types, generic procedures, programming languages

4.12 4.20 4.22

CA770607 JB December 28, 1977  1:27 PM

2167	4	2956
2723	4	2956
2941	4	2956
2956	4	2956
2956	4	2956
3030	4	2956
1379	5	2956
2651	5	2956
2956	5	2956
2956	5	2956
2956	5	2956
3049	5	2956
2956	6	2956
2958	6	2956
2957	6	2956
2960	6	2956


************************



Some Ideas on Data Types in High-Level Languages

A number of issues are explored concerning the
notion that a data type is a set of values together 
with a set of primitive operations on those values.  Among
these are the need for a notation for iterating 
over the elements of any finite set (instead <B>of the</B>
more narrow for i:= 1 to n notation), the use of 
the domain of an array as a data type, the need for
a simple notation for allowing types of parameters 
to be themselves parameters (but in a restrictive fashion),
and resulting problems with conversion of 
values from one type to another.

CACM June, 1977

Gries, D.
Gehani, N.

data types, generic procedures, programming languages

4.12 4.20 4.22

CA770607 JB December 28, 1977  1:27 PM

2167	4	2956
2723	4	2956
2941	4	2956
2956	4	2956
2956	4	2956
3030	4	2956
1379	5	2956
2651	5	2956
2956	5	2956
2956	5	2956
2956	5	2956
3049	5	2956
2956	6	2956
2958	6	2956
2957	6	2956
2960	6	2956


************************



Some Ideas on Data Types in High-Level Languages

A number of issues are explored concerning the
notion that a data type is a set of values together 
with a set of primitive operations on those values.  Among
these are the need for a notation for iterating 
over the elements of any finite set (instead of the
more narrow for i:= 1 to n notation), the use of 
the domain of an array as a data type, the need for
a simple notation for allowing types of parameters 
to be themselves parameters (but in a restrictive fashion),
and resulting problems with conversion of 
values from one type to another.

CACM June, 1977

Gries, D.
Gehani, N.

<B>data types</B>, generic procedures, programming languages

4.12 4.20 4.22

CA770607 JB December 28, 1977  1:27 PM

2167	4	2956
2723	4	2956
2941	4	2956
2956	4	2956
2956	4	2956
3030	4	2956
1379	5	2956
2651	5	2956
2956	5	2956
2956	5	2956
2956	5	2956
3049	5	2956
2956	6	2956
2958	6	2956
2957	6	2956
2960	6	2956


************************

************************
Document:  CACM-2184.html
************************


On the Meaning of Names in Programming Systems

It is assumed <B>that the</B>re is a similarity of
function between the data names of a programming 
language and the file names of an operating system.
 The two functions are discussed in terms of the 
same basic concepts in order to identify the extent
to which they overlap. It is suggested that there 
is some similarity between the idea of a file directory
and a storable object of type context.  Manipulations 
with contexts are then discussed at length.  It is noted
that there is a simple extension of Church's 
Lambda notation that deals nicely with these ideas of
context manipulation.  Whereas a function can be 
regarded as the abstraction based upon the first two terms of
the expression Lambda(name list)(expression)(value list), 
it is found that a context can be viewed as an abstraction
based upon the first two terms in the equivalent 
expression Mu(name list)(value list)(expression).

CACM July, 1971

Fraser, A. G.

file, operating system, programming language, functions,
names, context, file directory, file dictionary, 
lambda calculus, theory of programming

3.73 4.22 4.39 5.23 5.24

CA710606 JB February 3, 1978  9:58 AM

2184	5	2184
2184	5	2184
2184	5	2184


************************



On the Meaning of Names in Programming Systems

It is assumed that there is a similarity of
function between the data names <B>of a</B> programming 
language and the file names of an operating system.
 The two functions are discussed in terms of the 
same basic concepts in order to identify the extent
to which they overlap. It is suggested that there 
is some similarity between the idea of a file directory
and a storable object of type context.  Manipulations 
with contexts are then discussed at length.  It is noted
that there is a simple extension of Church's 
Lambda notation that deals nicely with these ideas of
context manipulation.  Whereas a function can be 
regarded as the abstraction based upon the first two terms of
the expression Lambda(name list)(expression)(value list), 
it is found that a context can be viewed as an abstraction
based upon the first two terms in the equivalent 
expression Mu(name list)(value list)(expression).

CACM July, 1971

Fraser, A. G.

file, operating system, programming language, functions,
names, context, file directory, file dictionary, 
lambda calculus, theory of programming

3.73 4.22 4.39 5.23 5.24

CA710606 JB February 3, 1978  9:58 AM

2184	5	2184
2184	5	2184
2184	5	2184


************************



On the Meaning of Names in Programming Systems

It is assumed that there is a similarity of
function between the data names of a programming 
language <B>and the</B> file names of an operating system.
 The two functions are discussed in terms of the 
same basic concepts in order to identify the extent
to which they overlap. It is suggested that there 
is some similarity between the idea of a file directory
and a storable object of type context.  Manipulations 
with contexts are then discussed at length.  It is noted
that there is a simple extension of Church's 
Lambda notation that deals nicely with these ideas of
context manipulation.  Whereas a function can be 
regarded as the abstraction based upon the first two terms of
the expression Lambda(name list)(expression)(value list), 
it is found that a context can be viewed as an abstraction
based upon the first two terms in the equivalent 
expression Mu(name list)(value list)(expression).

CACM July, 1971

Fraser, A. G.

file, operating system, programming language, functions,
names, context, file directory, file dictionary, 
lambda calculus, theory of programming

3.73 4.22 4.39 5.23 5.24

CA710606 JB February 3, 1978  9:58 AM

2184	5	2184
2184	5	2184
2184	5	2184


************************



On the Meaning of Names in Programming Systems

It is assumed that there is a similarity of
function between the data names of a programming 
language and the file names of an operating system.
 The two functions are discussed in terms <B>of the</B> 
same basic concepts in order to identify the extent
to which they overlap. It is suggested that there 
is some similarity between the idea of a file directory
and a storable object of type context.  Manipulations 
with contexts are then discussed at length.  It is noted
that there is a simple extension of Church's 
Lambda notation that deals nicely with these ideas of
context manipulation.  Whereas a function can be 
regarded as the abstraction based upon the first two terms of
the expression Lambda(name list)(expression)(value list), 
it is found that a context can be viewed as an abstraction
based upon the first two terms in the equivalent 
expression Mu(name list)(value list)(expression).

CACM July, 1971

Fraser, A. G.

file, operating system, programming language, functions,
names, context, file directory, file dictionary, 
lambda calculus, theory of programming

3.73 4.22 4.39 5.23 5.24

CA710606 JB February 3, 1978  9:58 AM

2184	5	2184
2184	5	2184
2184	5	2184


************************



On the Meaning of Names in Programming Systems

It <B>is a</B>ssumed that there is a similarity of
function between the data names of a programming 
language and the file names of an operating system.
 The two functions are discussed in terms of the 
same basic concepts in order to identify the extent
to which they overlap. It is suggested that there 
is some similarity between the idea of a file directory
and a storable object of type context.  Manipulations 
with contexts are then discussed at length.  It is noted
that there is a simple extension of Church's 
Lambda notation that deals nicely with these ideas of
context manipulation.  Whereas a function can be 
regarded as the abstraction based upon the first two terms of
the expression Lambda(name list)(expression)(value list), 
it is found that a context can be viewed as an abstraction
based upon the first two terms in the equivalent 
expression Mu(name list)(value list)(expression).

CACM July, 1971

Fraser, A. G.

file, operating system, programming language, functions,
names, context, file directory, file dictionary, 
lambda calculus, theory of programming

3.73 4.22 4.39 5.23 5.24

CA710606 JB February 3, 1978  9:58 AM

2184	5	2184
2184	5	2184
2184	5	2184


************************

************************
Document:  CACM-3114.html
************************


A Technique for Isolating Differences Between Files

A simple algorithm is described for isolating
the differences between two files.  One application 
is the comparing of two versions of a source program
or other file in order to display all differences. 
 The algorithm isolates differences in a way that corresponds
closely to our intuitive notion of difference, 
is easy to implement, and is computationally efficient,
with time linear in the file length.  For most 
applications the algorithm isolates differences similar
to those isolated by the longest common subsequence. 
 Another application of th<B>is a</B>lgorithm merges files
containing independently generated changes into a 
single file.  The algorithm can also be used to generate
efficient encodings of a file in the form of 
the differences between itself and a given "datum" file,
permitting reconstruction of the original file 
from the difference and datum files.   

CACM April, 1978

Heckel, P.

Difference isolation, word processing, text editing,
program maintenance, hash coding, file compression, 
bandwidth compression, longest common subsequence,
file comparison, molecular evolution

3.63 3.73 3.81 4.43

CA780402 DH February 27, 1979  10:52 AM

2299	4	3114
2501	4	3114
2629	4	3114
2915	4	3114
2963	4	3114
3114	4	3114
3114	4	3114
3114	4	3114
1502	5	3114
2499	5	3114
2745	5	3114
3114	5	3114
3114	5	3114
3114	5	3114


************************



A Technique for Isolating Differences Between Files

A simple algorithm is described for isolating
the differences between two files.  One application 
is the comparing of two versions <B>of a</B> source program
or other file in order to display all differences. 
 The algorithm isolates differences in a way that corresponds
closely to our intuitive notion of difference, 
is easy to implement, and is computationally efficient,
with time linear in the file length.  For most 
applications the algorithm isolates differences similar
to those isolated by the longest common subsequence. 
 Another application of this algorithm merges files
containing independently generated changes into a 
single file.  The algorithm can also be used to generate
efficient encodings of a file in the form of 
the differences between itself and a given "datum" file,
permitting reconstruction of the original file 
from the difference and datum files.   

CACM April, 1978

Heckel, P.

Difference isolation, word processing, text editing,
program maintenance, hash coding, file compression, 
bandwidth compression, longest common subsequence,
file comparison, molecular evolution

3.63 3.73 3.81 4.43

CA780402 DH February 27, 1979  10:52 AM

2299	4	3114
2501	4	3114
2629	4	3114
2915	4	3114
2963	4	3114
3114	4	3114
3114	4	3114
3114	4	3114
1502	5	3114
2499	5	3114
2745	5	3114
3114	5	3114
3114	5	3114
3114	5	3114


************************



A Technique for Isolating Differences Between Files

A simple algorithm is described for isolating
the differences between two files.  One application 
is the comparing of two versions of a source program
or other file in order to display all differences. 
 The algorithm isolates differences in a way that corresponds
closely to our intuitive notion of difference, 
is easy to implement, and is computationally efficient,
with time linear in the file length.  For most 
applications the algorithm isolates differences similar
to those isolated by the longest common subsequence. 
 Another application of this algorithm merges files
containing independently generated changes into a 
single file.  The algorithm can also be used to generate
efficient encodings of a file in the form of 
the differences between itself and a given "datum" file,
permitting reconstruction <B>of the</B> original file 
from the difference and datum files.   

CACM April, 1978

Heckel, P.

Difference isolation, word processing, text editing,
program maintenance, hash coding, file compression, 
bandwidth compression, longest common subsequence,
file comparison, molecular evolution

3.63 3.73 3.81 4.43

CA780402 DH February 27, 1979  10:52 AM

2299	4	3114
2501	4	3114
2629	4	3114
2915	4	3114
2963	4	3114
3114	4	3114
3114	4	3114
3114	4	3114
1502	5	3114
2499	5	3114
2745	5	3114
3114	5	3114
3114	5	3114
3114	5	3114


************************



A Technique for Isolating Differences Between Files

A simple algorithm is described for isolating
the differences between two files.  One application 
is the comparing of two versions of a source program
or other file in order to display all differences. 
 The algorithm isolates differences <B>in a</B> way that corresponds
closely to our intuitive notion of difference, 
is easy to implement, and is computationally efficient,
with time linear in the file length.  For most 
applications the algorithm isolates differences similar
to those isolated by the longest common subsequence. 
 Another application of this algorithm merges files
containing independently generated changes into a 
single file.  The algorithm can also be used to generate
efficient encodings of a file in the form of 
the differences between itself and a given "datum" file,
permitting reconstruction of the original file 
from the difference and datum files.   

CACM April, 1978

Heckel, P.

Difference isolation, word processing, text editing,
program maintenance, hash coding, file compression, 
bandwidth compression, longest common subsequence,
file comparison, molecular evolution

3.63 3.73 3.81 4.43

CA780402 DH February 27, 1979  10:52 AM

2299	4	3114
2501	4	3114
2629	4	3114
2915	4	3114
2963	4	3114
3114	4	3114
3114	4	3114
3114	4	3114
1502	5	3114
2499	5	3114
2745	5	3114
3114	5	3114
3114	5	3114
3114	5	3114


************************



A Technique for Isolating Differences Between Files

A simple algorithm is described for isolating
the differences between two files.  One application 
is the comparing of two versions of a source program
or other file in order to display all differences. 
 The algorithm isolates differences in a way that corresponds
closely to our intuitive <B>notion of</B> difference, 
is easy to implement, and is computationally efficient,
with time linear in the file length.  For most 
applications the algorithm isolates differences similar
to those isolated by the longest common subsequence. 
 Another application of this algorithm merges files
containing independently generated changes into a 
single file.  The algorithm can also be used to generate
efficient encodings of a file in the form of 
the differences between itself and a given "datum" file,
permitting reconstruction of the original file 
from the difference and datum files.   

CACM April, 1978

Heckel, P.

Difference isolation, word processing, text editing,
program maintenance, hash coding, file compression, 
bandwidth compression, longest common subsequence,
file comparison, molecular evolution

3.63 3.73 3.81 4.43

CA780402 DH February 27, 1979  10:52 AM

2299	4	3114
2501	4	3114
2629	4	3114
2915	4	3114
2963	4	3114
3114	4	3114
3114	4	3114
3114	4	3114
1502	5	3114
2499	5	3114
2745	5	3114
3114	5	3114
3114	5	3114
3114	5	3114


************************



A Technique for Isolating Differences Between Files

A simple algorithm is described for isolating
the differences between two files.  One application 
<B>is the</B> comparing of two versions of a source program
or other file in order to display all differences. 
 The algorithm isolates differences in a way that corresponds
closely to our intuitive notion of difference, 
is easy to implement, and is computationally efficient,
with time linear in the file length.  For most 
applications the algorithm isolates differences similar
to those isolated by the longest common subsequence. 
 Another application of this algorithm merges files
containing independently generated changes into a 
single file.  The algorithm can also be used to generate
efficient encodings of a file in the form of 
the differences between itself and a given "datum" file,
permitting reconstruction of the original file 
from the difference and datum files.   

CACM April, 1978

Heckel, P.

Difference isolation, word processing, text editing,
program maintenance, hash coding, file compression, 
bandwidth compression, longest common subsequence,
file comparison, molecular evolution

3.63 3.73 3.81 4.43

CA780402 DH February 27, 1979  10:52 AM

2299	4	3114
2501	4	3114
2629	4	3114
2915	4	3114
2963	4	3114
3114	4	3114
3114	4	3114
3114	4	3114
1502	5	3114
2499	5	3114
2745	5	3114
3114	5	3114
3114	5	3114
3114	5	3114


************************



A Technique for Isolating Differences Between Files

A simple algorithm is described for isolating
the differences <B>between two</B> files.  One application 
is the comparing of two versions of a source program
or other file in order to display all differences. 
 The algorithm isolates differences in a way that corresponds
closely to our intuitive notion of difference, 
is easy to implement, and is computationally efficient,
with time linear in the file length.  For most 
applications the algorithm isolates differences similar
to those isolated by the longest common subsequence. 
 Another application of this algorithm merges files
containing independently generated changes into a 
single file.  The algorithm can also be used to generate
efficient encodings of a file in the form of 
the differences between itself and a given "datum" file,
permitting reconstruction of the original file 
from the difference and datum files.   

CACM April, 1978

Heckel, P.

Difference isolation, word processing, text editing,
program maintenance, hash coding, file compression, 
bandwidth compression, longest common subsequence,
file comparison, molecular evolution

3.63 3.73 3.81 4.43

CA780402 DH February 27, 1979  10:52 AM

2299	4	3114
2501	4	3114
2629	4	3114
2915	4	3114
2963	4	3114
3114	4	3114
3114	4	3114
3114	4	3114
1502	5	3114
2499	5	3114
2745	5	3114
3114	5	3114
3114	5	3114
3114	5	3114


************************

************************
Document:  CACM-1143.html
************************


Analysis of Decay-Type Data*

A comparative study has been made <B>of a</B> variety
of numerical techniques for fitting experimental 
data of the decay type by forms involving the sums of
exponentials.  Statistical errors of the fitted 
parameters are also calculated.  These methods have been
applied to artificially-generated sets of data 
as well as to the results of experiments with radioactive
tracers on both human and animal subjects. 
 Results show that the values of the fitted parameters
are very sensitive to variations in the fitting 
procedure.  Therefore great care very sensitive to variations
in the fitting procedure.  Therefore great 
care must be exercised in identifying such values with
physical constants.  Although the values of functions 
derived from these fitted parameters which can definitely
be associated with physical entities are generally 
more stable under variations in the fitting techniques,
error bounds can be so large that no great confidence 
can be placed even in them.  It would therefore appear
best to select a uniform technique both for running 
the experiments and for analyzing the data, and then
to consider as significant only relative results 
between one subject and the next.

CACM January, 1964

Worsley, B. H.

CA640112 JB March 10, 1978 5:11 AM

1143	5	1143
1143	5	1143
1143	5	1143


************************



Analysis of Decay-Type Data*

A comparative study has been made of a variety
of numerical techniques for fitting experimental 
data of the decay type by forms involving the sums of
exponentials.  Statistical errors of the fitted 
parameters are also calculated.  These methods have been
applied to artificially-generated sets of data 
as well as to the results of experiments with radioactive
tracers on both human and animal subjects. 
 Results show that the values of the fitted parameters
are very sensitive to variations in the fitting 
procedure.  Therefore great care very sensitive to variations
in the fitting procedure.  Therefore great 
care must be exercised in identifying such values with
physical constants.  Although the values of functions 
derived from these fitted parameters which can definitely
be associated with physical entities are generally 
more stable under variations in the fitting techniques,
error bounds can be so large that no great confidence 
can be placed even in them.  It would therefore appear
best to select a uniform technique both for running 
the experiments and for analyzing the data, <B>and the</B>n
to consider as significant only relative results 
between one subject and the next.

CACM January, 1964

Worsley, B. H.

CA640112 JB March 10, 1978 5:11 AM

1143	5	1143
1143	5	1143
1143	5	1143


************************



Analysis of Decay-Type Data*

A comparative study has been made of a variety
of numerical techniques for fitting experimental 
data <B>of the</B> decay type by forms involving the sums of
exponentials.  Statistical errors of the fitted 
parameters are also calculated.  These methods have been
applied to artificially-generated sets of data 
as well as to the results of experiments with radioactive
tracers on both human and animal subjects. 
 Results show that the values of the fitted parameters
are very sensitive to variations in the fitting 
procedure.  Therefore great care very sensitive to variations
in the fitting procedure.  Therefore great 
care must be exercised in identifying such values with
physical constants.  Although the values of functions 
derived from these fitted parameters which can definitely
be associated with physical entities are generally 
more stable under variations in the fitting techniques,
error bounds can be so large that no great confidence 
can be placed even in them.  It would therefore appear
best to select a uniform technique both for running 
the experiments and for analyzing the data, and then
to consider as significant only relative results 
between one subject and the next.

CACM January, 1964

Worsley, B. H.

CA640112 JB March 10, 1978 5:11 AM

1143	5	1143
1143	5	1143
1143	5	1143


************************



Analysis of Decay-Type Data*

A comparative study has been made of a variety
of numerical techniques for fitting experimental 
data of the decay type by forms involving the sums of
exponentials.  Statistical errors of the fitted 
parameters are also calculated.  These methods have been
applied to artificially-generated sets of data 
as well as to the results of experiments with radioactive
tracers on both human and animal subjects. 
 Results show <B>that the</B> values of the fitted parameters
are very sensitive to variations in the fitting 
procedure.  Therefore great care very sensitive to variations
in the fitting procedure.  Therefore great 
care must be exercised in identifying such values with
physical constants.  Although the values of functions 
derived from these fitted parameters which can definitely
be associated with physical entities are generally 
more stable under variations in the fitting techniques,
error bounds can be so large that no great confidence 
can be placed even in them.  It would therefore appear
best to select a uniform technique both for running 
the experiments and for analyzing the data, and then
to consider as significant only relative results 
between one subject and the next.

CACM January, 1964

Worsley, B. H.

CA640112 JB March 10, 1978 5:11 AM

1143	5	1143
1143	5	1143
1143	5	1143


************************

************************
Document:  CACM-2702.html
************************


On the Complexity of LR(k) Testing

The problem of determining whether an arbitrary
context-free grammar is a member of some easily 
parsed subclass of grammars such as the LR(k) grammars
is considered.  The time complexity of this problem 
is analyzed both when k is considered to be a fixed
integer and when k is considered to be a parameter 
of the test.  In the first case, it is shown that for
every k there exists an O(n(k+2)) algorithm for 
testing the LR(k) property, where n <B>is the</B> size of the
grammar in question.  On the other hand, if both 
k and the subject grammar are problem parameters, then
the complexity of the problem depends very strongly 
on the representation chosen for k.  More specifically,
it is shown that this problem is NP-complete 
when k is expressed in unary.  When k is expressed in
binary the problem is complete for nondeterministic 
exponential time.  These results carry over to many
other parameterized classes of grammars, such as 
the LL(k), strong LL(k), SLR(k), LC(k), and strong LC(k) grammars.

CACM December, 1975

Hunt, H. B. III
Szymanski, T. G.
Ullman, J. D.

computational complexity, context-free grammars,
parsing, LR(k) grammars, NP-complete problems

4.12 5.23 5.25

CA751205 JB January 5, 1978  4:28 PM

2702	5	2702
2702	5	2702
2702	5	2702


************************



On the Complexity of LR(k) Testing

The problem of determining whether an arbitrary
context-free grammar is a member of some easily 
parsed subclass of grammars such as the LR(k) grammars
is considered.  The time complexity of this problem 
is analyzed both when k is considered to be a fixed
integer and when k is considered to be a parameter 
of the test.  In the first case, it is shown that for
every k there exists an O(n(k+2)) algorithm for 
testing the LR(k) property, where n is the size of the
grammar in question.  On the other hand, if both 
k <B>and the</B> subject grammar are problem parameters, then
the complexity of the problem depends very strongly 
on the representation chosen for k.  More specifically,
it is shown that this problem is NP-complete 
when k is expressed in unary.  When k is expressed in
binary the problem is complete for nondeterministic 
exponential time.  These results carry over to many
other parameterized classes of grammars, such as 
the LL(k), strong LL(k), SLR(k), LC(k), and strong LC(k) grammars.

CACM December, 1975

Hunt, H. B. III
Szymanski, T. G.
Ullman, J. D.

computational complexity, context-free grammars,
parsing, LR(k) grammars, NP-complete problems

4.12 5.23 5.25

CA751205 JB January 5, 1978  4:28 PM

2702	5	2702
2702	5	2702
2702	5	2702


************************



On the Complexity of LR(k) Testing

The problem of determining whether an arbitrary
context-free grammar <B>is a</B> member of some easily 
parsed subclass of grammars such as the LR(k) grammars
is considered.  The time complexity of this problem 
is analyzed both when k is considered to be a fixed
integer and when k is considered to be a parameter 
of the test.  In the first case, it is shown that for
every k there exists an O(n(k+2)) algorithm for 
testing the LR(k) property, where n is the size of the
grammar in question.  On the other hand, if both 
k and the subject grammar are problem parameters, then
the complexity of the problem depends very strongly 
on the representation chosen for k.  More specifically,
it is shown that this problem is NP-complete 
when k is expressed in unary.  When k is expressed in
binary the problem is complete for nondeterministic 
exponential time.  These results carry over to many
other parameterized classes of grammars, such as 
the LL(k), strong LL(k), SLR(k), LC(k), and strong LC(k) grammars.

CACM December, 1975

Hunt, H. B. III
Szymanski, T. G.
Ullman, J. D.

computational complexity, context-free grammars,
parsing, LR(k) grammars, NP-complete problems

4.12 5.23 5.25

CA751205 JB January 5, 1978  4:28 PM

2702	5	2702
2702	5	2702
2702	5	2702


************************



On the Complexity of LR(k) Testing

The problem of determining whether an arbitrary
context-free grammar is a member of some easily 
parsed subclass of grammars such as the LR(k) grammars
is considered.  The time complexity of this problem 
is analyzed both when k is considered to be a fixed
integer and when k is considered to be a parameter 
<B>of the</B> test.  In the first case, it is shown that for
every k there exists an O(n(k+2)) algorithm for 
testing the LR(k) property, where n is the size of the
grammar in question.  On the other hand, if both 
k and the subject grammar are problem parameters, then
the complexity of the problem depends very strongly 
on the representation chosen for k.  More specifically,
it is shown that this problem is NP-complete 
when k is expressed in unary.  When k is expressed in
binary the problem is complete for nondeterministic 
exponential time.  These results carry over to many
other parameterized classes of grammars, such as 
the LL(k), strong LL(k), SLR(k), LC(k), and strong LC(k) grammars.

CACM December, 1975

Hunt, H. B. III
Szymanski, T. G.
Ullman, J. D.

computational complexity, context-free grammars,
parsing, LR(k) grammars, NP-complete problems

4.12 5.23 5.25

CA751205 JB January 5, 1978  4:28 PM

2702	5	2702
2702	5	2702
2702	5	2702


************************

************************
Document:  CACM-2651.html
************************


The Treatment of Data Types in EL1

In constructing a general purpose programming
language, a key issue is providing a sufficient 
set of data types and associated operations <B>in a</B> manner
that permits both natural problem-oriented notation 
and efficient implementation.  The EL1 language contains
a number of features specifically designed to 
simultaneously satisfy both requirements.  The resulting
treatment of data types includes provision for 
programmer-defined data types data types and generic
routines, programmer control over type conversion, 
and very flexible data type behavior, in a context that
allows efficient compiled code and compact data 
representation.

CACM May, 1974

Wegbreit, B.

data types, modes, mode unions, type conversion,
coercion, generic functions, extensible languages, 
data type definition, data description language, compilation

4.12 4.13 4.22

CA740502 JB January 17, 1978  4:32 PM

2651	5	2651
2651	5	2651
2651	5	2651
2723	5	2651
2941	5	2651
2956	5	2651
3030	5	2651
1379	6	2651
1471	6	2651
1549	6	2651
1749	6	2651
1826	6	2651
210	6	2651
2247	6	2651
2356	6	2651
2356	6	2651
2457	6	2651
2558	6	2651
2651	6	2651
2651	6	2651
2651	6	2651
2651	6	2651
2958	6	2651
2972	6	2651
627	6	2651
731	6	2651


************************



The Treatment of Data Types in EL1

In constructing a general purpose programming
language, a key issue is providing a sufficient 
set of data <B>types and</B> associated operations in a manner
that permits both natural problem-oriented notation 
and efficient implementation.  The EL1 language contains
a number of features specifically designed to 
simultaneously satisfy both requirements.  The resulting
treatment of data types includes provision for 
programmer-defined data types data types and generic
routines, programmer control over type conversion, 
and very flexible data type behavior, in a context that
allows efficient compiled code and compact data 
representation.

CACM May, 1974

Wegbreit, B.

data types, modes, mode unions, type conversion,
coercion, generic functions, extensible languages, 
data type definition, data description language, compilation

4.12 4.13 4.22

CA740502 JB January 17, 1978  4:32 PM

2651	5	2651
2651	5	2651
2651	5	2651
2723	5	2651
2941	5	2651
2956	5	2651
3030	5	2651
1379	6	2651
1471	6	2651
1549	6	2651
1749	6	2651
1826	6	2651
210	6	2651
2247	6	2651
2356	6	2651
2356	6	2651
2457	6	2651
2558	6	2651
2651	6	2651
2651	6	2651
2651	6	2651
2651	6	2651
2958	6	2651
2972	6	2651
627	6	2651
731	6	2651


************************



The Treatment of Data Types in EL1

In constructing a general purpose programming
language, a key issue is providing a sufficient 
set of <B>data types</B> and associated operations in a manner
that permits both natural problem-oriented notation 
and efficient implementation.  The EL1 language contains
a number of features specifically designed to 
simultaneously satisfy both requirements.  The resulting
treatment of data types includes provision for 
programmer-defined data types data types and generic
routines, programmer control over type conversion, 
and very flexible data type behavior, in a context that
allows efficient compiled code and compact data 
representation.

CACM May, 1974

Wegbreit, B.

data types, modes, mode unions, type conversion,
coercion, generic functions, extensible languages, 
data type definition, data description language, compilation

4.12 4.13 4.22

CA740502 JB January 17, 1978  4:32 PM

2651	5	2651
2651	5	2651
2651	5	2651
2723	5	2651
2941	5	2651
2956	5	2651
3030	5	2651
1379	6	2651
1471	6	2651
1549	6	2651
1749	6	2651
1826	6	2651
210	6	2651
2247	6	2651
2356	6	2651
2356	6	2651
2457	6	2651
2558	6	2651
2651	6	2651
2651	6	2651
2651	6	2651
2651	6	2651
2958	6	2651
2972	6	2651
627	6	2651
731	6	2651


************************

************************
Document:  CACM-1441.html
************************


Methods of Numerical Integration Applied to
a System Having Trivial Function Evaluations

A study has been made to determine which methods
of numerical integration require the least 
computation time for a given amount of truncation error
when applied to a particular system of ordinary 
differential equations where function evaluations are
relatively trivial.  Recent methods due to Butcher 
and Gear are compared with classic Runge-Kutta, Kutta-Nystrom
and Adams methods.  Some <B>of the</B> newer one-step 
methods due to Butcher are found to be slightly superior,
but no one method is found to have any great 
advantage over the others in the application to this particular problem.

CACM April, 1966

Waters, J.

CA660408 JB March 3, 1978  10:37 AM

1441	5	1441
1441	5	1441
1441	5	1441


************************

************************
Document:  CACM-2051.html
************************


A PL/I Program to Assist the Comparative Linguist

A practical PL/I program is described which
can assist comparative linguists to determine
the regular sound correspondences between genetically related languages.
The investigator must arrange data for input by aligning pairs
of suspected cognates.  The program tabulates the correspondences,
and uses list processing techniques to sort and count them.
Each pair of words is then assigned a relative value that <B>is a</B> function
of the total frequency in the data of each correspondence found
in that pair of words.  The output is a list of all correspondence
types with their frequency of occurrence in the data, and a
separate listing of each correspondence with all word-pairs showing
that correspondence (unless their relative value is below an arbitrarily 
chosen cutoff point).  The article explains the usefulness,
as well as the limitations, of the programs, and illustrates its
use with a small portion of hypothetical data.

CACM June, 1970

Frantz, D. G.

comparative linguistics, natural
language processing, comparative method, historical linguistics, diachronic
linguistics, genetic relationship, sound change, sound
correspondence, regular correspondence, list processing

3.42

CA700604 JB February 13, 1978  11:51 AM

2051	5	2051
2051	5	2051
2051	5	2051


************************



A PL/I Program to Assist the Comparative Linguist

A practical PL/I program is described which
can assist comparative linguists to determine
the regular sound correspondences between genetically related languages.
The investigator must arrange data for input by aligning pairs
of suspected cognates.  The program tabulates the correspondences,
and uses list processing techniques to sort and count them.
Each pair of words <B>is the</B>n assigned a relative value that is a function
of the total frequency in the data of each correspondence found
in that pair of words.  The output is a list of all correspondence
types with their frequency of occurrence in the data, and a
separate listing of each correspondence with all word-pairs showing
that correspondence (unless their relative value is below an arbitrarily 
chosen cutoff point).  The article explains the usefulness,
as well as the limitations, of the programs, and illustrates its
use with a small portion of hypothetical data.

CACM June, 1970

Frantz, D. G.

comparative linguistics, natural
language processing, comparative method, historical linguistics, diachronic
linguistics, genetic relationship, sound change, sound
correspondence, regular correspondence, list processing

3.42

CA700604 JB February 13, 1978  11:51 AM

2051	5	2051
2051	5	2051
2051	5	2051


************************



A PL/I Program to Assist the Comparative Linguist

A practical PL/I program is described which
can assist comparative linguists to determine
the regular sound correspondences between genetically related languages.
The investigator must arrange data for input by aligning pairs
of suspected cognates.  The program tabulates the correspondences,
and uses list processing techniques to sort and count them.
Each pair of words is then assigned a relative value that is a function
of the total frequency in the data of each correspondence found
in that pair of words.  The output is a list <B>of a</B>ll correspondence
types with their frequency of occurrence in the data, and a
separate listing of each correspondence with all word-pairs showing
that correspondence (unless their relative value is below an arbitrarily 
chosen cutoff point).  The article explains the usefulness,
as well as the limitations, of the programs, and illustrates its
use with a small portion of hypothetical data.

CACM June, 1970

Frantz, D. G.

comparative linguistics, natural
language processing, comparative method, historical linguistics, diachronic
linguistics, genetic relationship, sound change, sound
correspondence, regular correspondence, list processing

3.42

CA700604 JB February 13, 1978  11:51 AM

2051	5	2051
2051	5	2051
2051	5	2051


************************



A PL/I Program to Assist the Comparative Linguist

A practical PL/I program is described which
can assist comparative linguists to determine
the regular sound correspondences between genetically related languages.
The investigator must arrange data for input by aligning pairs
of suspected cognates.  The program tabulates the correspondences,
and uses list processing techniques to sort and count them.
Each pair of words is then assigned a relative value that is a function
<B>of the</B> total frequency in the data of each correspondence found
in that pair of words.  The output is a list of all correspondence
types with their frequency of occurrence in the data, and a
separate listing of each correspondence with all word-pairs showing
that correspondence (unless their relative value is below an arbitrarily 
chosen cutoff point).  The article explains the usefulness,
as well as the limitations, of the programs, and illustrates its
use with a small portion of hypothetical data.

CACM June, 1970

Frantz, D. G.

comparative linguistics, natural
language processing, comparative method, historical linguistics, diachronic
linguistics, genetic relationship, sound change, sound
correspondence, regular correspondence, list processing

3.42

CA700604 JB February 13, 1978  11:51 AM

2051	5	2051
2051	5	2051
2051	5	2051


************************

************************
Document:  CACM-1309.html
************************


A Computer User-Oriented System

A computer language system has been developed
which makes possible fast preparation of management 
reports, regardless of computational complexity or format
variety.  Costs are sufficiently low so that 
individually tailored reports can be prepared for every
manager.  The system requires initial preparation 
of large data banks containing data in elementary form.
 Use of two special languages, EXTRACT and MATRAN, 
permits selective extraction <B>of a</B>ny data subset, efficient
processing through any computational sequence, 
and flexible presentation of results in either tabular
or graphical form.  Matrix algebra is used as 
a fundamental vehicle for accomplishing both manipulation and computation.

CACM February, 1965

Montillon, G. D.

CA650215 JB March 7, 1978  10:51 PM

1309	4	1309
892	4	1309
1309	5	1309
1309	5	1309
1309	5	1309
656	5	1309


************************

************************
Document:  CACM-2200.html
************************


On Complement Division

The division algorithm theorem is expressed
<B>in a</B> form that permits it to serve as the basis 
for devising division operations that produce both quotient
and remainder in complement form.  Algorithms 
for division yielding complement results are derived
for numbers represented in any base greater than 
one.  Both radix and radix-less-one complementation schemes
are considered.  The binary form of the algorithms 
thus includes both two's and one's complement implementation.
 The problem of quotient overflow for complement 
results is dealt with as is that of selecting an appropriate
form of the remainder condition for complement 
division. 

CACM April, 1971

Stein, M. L.
Munro, W. D.

division algorithm, complement arithmetic, complement
division, one's complement arithmetic, two's 
complement arithmetic

3.15 4.0 4.9 5.11 6.32

CA710405 JB February 3, 1978  3:28 PM

1965	4	2200
2200	4	2200
1718	5	2200
2200	5	2200
2200	5	2200
2200	5	2200


************************



On Complement Division

The division algorithm theorem is expressed
in a form that permits it to serve as the basis 
for devising division operations that produce both quotient
and remainder in complement form.  Algorithms 
for division yielding complement results are derived
for numbers represented in any base greater than 
one.  Both radix and radix-less-one complementation schemes
are considered.  The binary form <B>of the</B> algorithms 
thus includes both two's and one's complement implementation.
 The problem of quotient overflow for complement 
results is dealt with as is that of selecting an appropriate
form of the remainder condition for complement 
division. 

CACM April, 1971

Stein, M. L.
Munro, W. D.

division algorithm, complement arithmetic, complement
division, one's complement arithmetic, two's 
complement arithmetic

3.15 4.0 4.9 5.11 6.32

CA710405 JB February 3, 1978  3:28 PM

1965	4	2200
2200	4	2200
1718	5	2200
2200	5	2200
2200	5	2200
2200	5	2200


************************

************************
Document:  CACM-1571.html
************************


A User-Oriented Time-Shared Online System

An existing system and planned additions within
the Data Processing Laboratory of the Brain 
Research Institute at UCLA is described.  The system
represents an attempt to provide research workers 
of the Institute with the ability to interact directly
with a highly sophisticated digital computing 
complex in the most direct and simple fashion possible.
 It <B>is a</B>nticipated that, with the accumulation 
of experience using the present system, significant advances
will be possible in the system design through 
determination of interface parameters between the
biological scientist and the digital computer.

CACM July, 1967

Betyar, L.

CA670702 JB February 28, 1978  9:08 AM

1571	5	1571
1571	5	1571
1571	5	1571


************************



A User-Oriented Time-Shared Online System

An existing system and planned additions within
the Data Processing Laboratory of the Brain 
Research Institute at UCLA is described.  The system
represents an attempt to provide research workers 
of the Institute with the ability to interact directly
with a highly sophisticated digital computing 
complex in the most direct and simple fashion possible.
 It is anticipated that, with the accumulation 
of experience using the present system, significant advances
will be possible in the system design through 
determination of interface parameters between the
biological scientist <B>and the</B> digital computer.

CACM July, 1967

Betyar, L.

CA670702 JB February 28, 1978  9:08 AM

1571	5	1571
1571	5	1571
1571	5	1571


************************



A User-Oriented Time-Shared Online System

An existing system and planned additions within
the Data Processing Laboratory <B>of the</B> Brain 
Research Institute at UCLA is described.  The system
represents an attempt to provide research workers 
of the Institute with the ability to interact directly
with a highly sophisticated digital computing 
complex in the most direct and simple fashion possible.
 It is anticipated that, with the accumulation 
of experience using the present system, significant advances
will be possible in the system design through 
determination of interface parameters between the
biological scientist and the digital computer.

CACM July, 1967

Betyar, L.

CA670702 JB February 28, 1978  9:08 AM

1571	5	1571
1571	5	1571
1571	5	1571


************************

************************
Document:  CACM-2265.html
************************


A Model for Type Checking

Most current programming languages treat computation
over different classes of objects (e.g. 
numbers, strings, labels and functions).  For correct
compilation and execution, the following question 
then arises: is a program properly constructed so that
its operations and operands are compatible?  The 
activity of answering this question is usually called
type checking.  This paper attempts to isolate 
the <B>notion of</B> type checking and presents a partial
solution to the type checking problem based on the 
notions of abstraction and application of functions. 
In particular, a program is mapped into an expression 
within a decidable subset of the Lambda calculus, which
characterizes the type relations within the program 
and eliminates all other information.  The determination
of the type-wise correctness or incorrectness 
of the program is resolved by reducing its corresponding
Lambda calculus expression to one of two normal 
forms, the constant "correct" for a type-wise correct
program or the constant "error".  An application 
to type checking in Algol 60 is made, and the attendant
problems faced for any notion of type checking 
are discussed.

CACM November, 1972

Ledgard, H. F.

type checking, types, Lambda calculus, models for
programming languages, syntax, semantics, compiler 
writing, language implementation, formal definition

4.12 4.22 5.2 5.21 5.23

CA721104 JB January 27, 1978  2:30 PM

2265	5	2265
2265	5	2265
2265	5	2265


************************



A Model for Type Checking

Most current programming languages treat computation
over different classes of objects (e.g. 
numbers, strings, labels and functions).  For correct
compilation and execution, the following question 
then arises: is a program properly constructed so that
its operations and operands are compatible?  The 
activity of answering this question is usually called
type checking.  This paper attempts to isolate 
the notion of type checking and presents a partial
solution to the type checking problem based on the 
notions of abstraction and application of functions. 
In particular, a program is mapped into an expression 
within a decidable subset <B>of the</B> Lambda calculus, which
characterizes the type relations within the program 
and eliminates all other information.  The determination
of the type-wise correctness or incorrectness 
of the program is resolved by reducing its corresponding
Lambda calculus expression to one of two normal 
forms, the constant "correct" for a type-wise correct
program or the constant "error".  An application 
to type checking in Algol 60 is made, and the attendant
problems faced for any notion of type checking 
are discussed.

CACM November, 1972

Ledgard, H. F.

type checking, types, Lambda calculus, models for
programming languages, syntax, semantics, compiler 
writing, language implementation, formal definition

4.12 4.22 5.2 5.21 5.23

CA721104 JB January 27, 1978  2:30 PM

2265	5	2265
2265	5	2265
2265	5	2265


************************



A Model for Type Checking

Most current programming languages treat computation
over different classes of objects (e.g. 
numbers, strings, labels and functions).  For correct
compilation and execution, the following question 
then arises: is a program properly constructed so that
its operations and operands are compatible?  The 
activity <B>of a</B>nswering this question is usually called
type checking.  This paper attempts to isolate 
the notion of type checking and presents a partial
solution to the type checking problem based on the 
notions of abstraction and application of functions. 
In particular, a program is mapped into an expression 
within a decidable subset of the Lambda calculus, which
characterizes the type relations within the program 
and eliminates all other information.  The determination
of the type-wise correctness or incorrectness 
of the program is resolved by reducing its corresponding
Lambda calculus expression to one of two normal 
forms, the constant "correct" for a type-wise correct
program or the constant "error".  An application 
to type checking in Algol 60 is made, and the attendant
problems faced for any notion of type checking 
are discussed.

CACM November, 1972

Ledgard, H. F.

type checking, types, Lambda calculus, models for
programming languages, syntax, semantics, compiler 
writing, language implementation, formal definition

4.12 4.22 5.2 5.21 5.23

CA721104 JB January 27, 1978  2:30 PM

2265	5	2265
2265	5	2265
2265	5	2265


************************



A Model for Type Checking

Most current programming languages treat computation
over different classes of objects (e.g. 
numbers, strings, labels and functions).  For correct
compilation and execution, the following question 
then arises: <B>is a</B> program properly constructed so that
its operations and operands are compatible?  The 
activity of answering this question is usually called
type checking.  This paper attempts to isolate 
the notion of type checking and presents a partial
solution to the type checking problem based on the 
notions of abstraction and application of functions. 
In particular, a program is mapped into an expression 
within a decidable subset of the Lambda calculus, which
characterizes the type relations within the program 
and eliminates all other information.  The determination
of the type-wise correctness or incorrectness 
of the program is resolved by reducing its corresponding
Lambda calculus expression to one of two normal 
forms, the constant "correct" for a type-wise correct
program or the constant "error".  An application 
to type checking in Algol 60 is made, and the attendant
problems faced for any notion of type checking 
are discussed.

CACM November, 1972

Ledgard, H. F.

type checking, types, Lambda calculus, models for
programming languages, syntax, semantics, compiler 
writing, language implementation, formal definition

4.12 4.22 5.2 5.21 5.23

CA721104 JB January 27, 1978  2:30 PM

2265	5	2265
2265	5	2265
2265	5	2265


************************



A Model for Type Checking

Most current programming languages treat computation
over different classes of objects (e.g. 
numbers, strings, labels and functions).  For correct
compilation and execution, the following question 
then arises: is a program properly constructed so that
its operations and operands are compatible?  The 
activity of answering this question is usually called
type checking.  This paper attempts to isolate 
the notion of type checking and presents a partial
solution to the type checking problem based on the 
notions of abstraction and application of functions. 
In particular, a program is mapped into an expression 
within a decidable subset of the Lambda calculus, which
characterizes the type relations within the program 
and eliminates all other information.  The determination
of the type-wise correctness or incorrectness 
of the program is resolved by reducing its corresponding
Lambda calculus expression to one of two normal 
forms, the constant "correct" for a type-wise correct
program or the constant "error".  An application 
to type checking in Algol 60 is made, <B>and the</B> attendant
problems faced for any notion of type checking 
are discussed.

CACM November, 1972

Ledgard, H. F.

type checking, types, Lambda calculus, models for
programming languages, syntax, semantics, compiler 
writing, language implementation, formal definition

4.12 4.22 5.2 5.21 5.23

CA721104 JB January 27, 1978  2:30 PM

2265	5	2265
2265	5	2265
2265	5	2265


************************



A Model for Type Checking

Most current programming languages treat computation
over different classes of objects (e.g. 
numbers, strings, labels and functions).  For correct
compilation and execution, the following question 
then arises: is a program properly constructed so that
its operations and operands are compatible?  The 
activity of answering this question is usually called
type checking.  This paper attempts to isolate 
the notion of type checking and presents a partial
solution to the type checking problem based on the 
notions of abstraction and application of functions. 
In particular, a program is mapped into an expression 
within a decidable subset of the Lambda calculus, which
characterizes the type relations within the program 
and eliminates all other information.  The determination
of the type-wise correctness or incorrectness 
of the program is resolved by reducing its corresponding
Lambda calculus expression to one of two normal 
forms, the constant "correct" for a type-wise correct
program or the constant "error".  An application 
to type checking in Algol 60 is made, and the attendant
problems faced for <B>any notion</B> of type checking 
are discussed.

CACM November, 1972

Ledgard, H. F.

type checking, types, Lambda calculus, models for
programming languages, syntax, semantics, compiler 
writing, language implementation, formal definition

4.12 4.22 5.2 5.21 5.23

CA721104 JB January 27, 1978  2:30 PM

2265	5	2265
2265	5	2265
2265	5	2265


************************



A Model for Type Checking

Most current programming languages treat computation
over different classes of objects (e.g. 
numbers, strings, labels and functions).  For correct
compilation and execution, the following question 
then arises: is a program properly constructed so that
its operations and operands are compatible?  The 
activity of answering this question is usually called
type checking.  This paper attempts to isolate 
the notion of type checking and presents a partial
solution to <B>the type</B> checking problem based on the 
notions of abstraction and application of functions. 
In particular, a program is mapped into an expression 
within a decidable subset of the Lambda calculus, which
characterizes the type relations within the program 
and eliminates all other information.  The determination
of the type-wise correctness or incorrectness 
of the program is resolved by reducing its corresponding
Lambda calculus expression to one of two normal 
forms, the constant "correct" for a type-wise correct
program or the constant "error".  An application 
to type checking in Algol 60 is made, and the attendant
problems faced for any notion of type checking 
are discussed.

CACM November, 1972

Ledgard, H. F.

type checking, types, Lambda calculus, models for
programming languages, syntax, semantics, compiler 
writing, language implementation, formal definition

4.12 4.22 5.2 5.21 5.23

CA721104 JB January 27, 1978  2:30 PM

2265	5	2265
2265	5	2265
2265	5	2265


************************



A Model for Type Checking

Most current programming languages treat computation
over different classes of objects (e.g. 
numbers, strings, labels and functions).  For correct
compilation and execution, the following question 
then arises: is a program properly constructed so that
its operations and operands are compatible?  The 
activity of answering this question is usually called
type checking.  This paper attempts to isolate 
the notion of type checking and presents a partial
solution to the type checking problem based on the 
notions of abstraction and application of functions. 
In particular, a program is mapped into an expression 
with<B>in a</B> decidable subset of the Lambda calculus, which
characterizes the type relations within the program 
and eliminates all other information.  The determination
of the type-wise correctness or incorrectness 
of the program is resolved by reducing its corresponding
Lambda calculus expression to one of two normal 
forms, the constant "correct" for a type-wise correct
program or the constant "error".  An application 
to type checking in Algol 60 is made, and the attendant
problems faced for any notion of type checking 
are discussed.

CACM November, 1972

Ledgard, H. F.

type checking, types, Lambda calculus, models for
programming languages, syntax, semantics, compiler 
writing, language implementation, formal definition

4.12 4.22 5.2 5.21 5.23

CA721104 JB January 27, 1978  2:30 PM

2265	5	2265
2265	5	2265
2265	5	2265


************************

************************
Document:  CACM-2914.html
************************


Use <B>of the</B> LRU Stack Depth Distribution
for Simulation of Paging Behavior

Two families of probability distributions were
needed for use by a virtual memory simulation 
model: headway between page fault distributions, and
working set size distributions.  All members of 
both families can be derived from the LRU stack depth distribution.
 Simple expressions for the computation 
of both kinds of distributions are given.  Finally, examples
are given of both families of distributions 
as computed from a published stack depth distribution.

CACM November, 1977

Turner, R.
Strecker, B.

virtual memory, paging, LRU stack, working set, headway
between page faults, computer system simulation

4.35 4.6 8.1

CA771102 JB December 27, 1977  8:04 AM

2914	5	2914
2914	5	2914
2914	5	2914


************************

************************
Document:  CACM-2794.html
************************


State-Space, Problem-Reduction, and Theorem Proving-Some Relationships

This paper suggests a bidirectional relationship
between state-space and problem-reduction 
representations. It presents a formalism based on multiple-input
and multiple-output operators which 
provides a basis for viewing the two types of representations
in this manner.  A representation of the 
language recognition problem which is based on the Cocke
parsing algorithm is used as an illustration. 
 A method for representing problems in first-order logic
in such a way <B>that the</B> inference system employed 
by a resolution-based theorem prover determines whether
the set of clauses is interpreted in the state-spacer 
mode or in the problem-reduction mode is presented.
 The analogous concepts in problem-reduction and 
theorem proving, and the terminology used to refer to them,
are noted.  The relationship between problem-reduction, 
input resolution, and linear resolution is discussed.

CACM February, 1975

VanderBrug, G. J.
Minker, J.

artificial intelligence, state-space representation,
problem-reduction representation, theorem 
proving, language recognition

3.64

CA750205 JB January 12, 1978  8:27 AM

2794	5	2794
2794	5	2794
2794	5	2794


************************



State-Space, Problem-Reduction, and Theorem Proving-Some Relationships

This paper suggests a bidirectional relationship
between state-space and problem-reduction 
representations. It presents a formalism based on multiple-input
and multiple-output operators which 
provides a basis for viewing the two types of representations
in this manner.  A representation of the 
language recognition problem which is based on the Cocke
parsing algorithm is used as an illustration. 
 A method for representing problems in first-order logic
in such a way that the inference system employed 
by a resolution-based theorem prover determines whether
the set of clauses is interpreted in the state-spacer 
mode or in the problem-reduction mode is presented.
 The analogous concepts in problem-reduction and 
theorem proving, <B>and the</B> terminology used to refer to them,
are noted.  The relationship between problem-reduction, 
input resolution, and linear resolution is discussed.

CACM February, 1975

VanderBrug, G. J.
Minker, J.

artificial intelligence, state-space representation,
problem-reduction representation, theorem 
proving, language recognition

3.64

CA750205 JB January 12, 1978  8:27 AM

2794	5	2794
2794	5	2794
2794	5	2794


************************



State-Space, Problem-Reduction, and Theorem Proving-Some Relationships

This paper suggests a bidirectional relationship
between state-space and problem-reduction 
representations. It presents a formalism based on multiple-input
and multiple-output operators which 
provides a basis for viewing the two types of representations
in this manner.  A representation <B>of the</B> 
language recognition problem which is based on the Cocke
parsing algorithm is used as an illustration. 
 A method for representing problems in first-order logic
in such a way that the inference system employed 
by a resolution-based theorem prover determines whether
the set of clauses is interpreted in the state-spacer 
mode or in the problem-reduction mode is presented.
 The analogous concepts in problem-reduction and 
theorem proving, and the terminology used to refer to them,
are noted.  The relationship between problem-reduction, 
input resolution, and linear resolution is discussed.

CACM February, 1975

VanderBrug, G. J.
Minker, J.

artificial intelligence, state-space representation,
problem-reduction representation, theorem 
proving, language recognition

3.64

CA750205 JB January 12, 1978  8:27 AM

2794	5	2794
2794	5	2794
2794	5	2794


************************



State-Space, Problem-Reduction, and Theorem Proving-Some Relationships

This paper suggests a bidirectional relationship
between state-space and problem-reduction 
representations. It presents a formalism based on multiple-input
and multiple-output operators which 
provides a basis for viewing the two types of representations
in this manner.  A representation of the 
language recognition problem which is based on the Cocke
parsing algorithm is used as an illustration. 
 A method for representing problems in first-order logic
in such a way that the inference system employed 
by a resolution-based theorem prover determines whether
the set of clauses is interpreted in the state-spacer 
mode or in the problem-reduction mode is presented.
 The analogous concepts in problem-reduction and 
theorem proving, and the terminology used to refer to them,
are noted.  The <B>relationship between</B> problem-reduction, 
input resolution, and linear resolution is discussed.

CACM February, 1975

VanderBrug, G. J.
Minker, J.

artificial intelligence, state-space representation,
problem-reduction representation, theorem 
proving, language recognition

3.64

CA750205 JB January 12, 1978  8:27 AM

2794	5	2794
2794	5	2794
2794	5	2794


************************



State-Space, Problem-Reduction, and Theorem Proving-Some Relationships

This paper suggests a bidirectional relationship
between state-space and problem-reduction 
representations. It presents a formalism based on multiple-input
and multiple-output operators which 
provides a basis for viewing the two <B>types of</B> representations
in this manner.  A representation of the 
language recognition problem which is based on the Cocke
parsing algorithm is used as an illustration. 
 A method for representing problems in first-order logic
in such a way that the inference system employed 
by a resolution-based theorem prover determines whether
the set of clauses is interpreted in the state-spacer 
mode or in the problem-reduction mode is presented.
 The analogous concepts in problem-reduction and 
theorem proving, and the terminology used to refer to them,
are noted.  The relationship between problem-reduction, 
input resolution, and linear resolution is discussed.

CACM February, 1975

VanderBrug, G. J.
Minker, J.

artificial intelligence, state-space representation,
problem-reduction representation, theorem 
proving, language recognition

3.64

CA750205 JB January 12, 1978  8:27 AM

2794	5	2794
2794	5	2794
2794	5	2794


************************

************************
Document:  CACM-3002.html
************************


A Record and File Partitioning Model

One of the main objectives in the design of
a file system is the reduction of storage and data 
transfer costs.  This paper presents a model in which
several  requests access the file system, and each 
request requires information from one or more variable
length data-items.  The probabilities of access 
<B>and the</B> distribution of each data-item's length are assumed
to be known, and to be mutually independent. 
The file system uses one or more storage devices, and
each record may be partitioned into subrecords 
that are stored on different devices.  One of the subrecords
is designated as the primary record; when 
a request for a record is made, the primary record is
first accessed, and other subrecords are accessed 
only if the pertinent information is not stored in the
primary record.  The model that is presented in 
this paper, both as a nonlinear programming model and
a mixed integer programming model, is a very general 
one; several types of file systems may be derived from
it by an appropriate selection of its parameters. 
 This model has already been used in the optimization of
library routines' storage at a large scale operating 
system.

CACM January, 1977

Babad, J. M.

file system, file design, file partitioning, record partitioning

3.73

CA770103 JB January 3, 1978  12:28 AM

3002	5	3002
3002	5	3002
3002	5	3002
3168	5	3002
2965	6	3002
3002	6	3002


************************



A Record and File Partitioning Model

One <B>of the</B> main objectives in the design of
a file system is the reduction of storage and data 
transfer costs.  This paper presents a model in which
several  requests access the file system, and each 
request requires information from one or more variable
length data-items.  The probabilities of access 
and the distribution of each data-item's length are assumed
to be known, and to be mutually independent. 
The file system uses one or more storage devices, and
each record may be partitioned into subrecords 
that are stored on different devices.  One of the subrecords
is designated as the primary record; when 
a request for a record is made, the primary record is
first accessed, and other subrecords are accessed 
only if the pertinent information is not stored in the
primary record.  The model that is presented in 
this paper, both as a nonlinear programming model and
a mixed integer programming model, is a very general 
one; several types of file systems may be derived from
it by an appropriate selection of its parameters. 
 This model has already been used in the optimization of
library routines' storage at a large scale operating 
system.

CACM January, 1977

Babad, J. M.

file system, file design, file partitioning, record partitioning

3.73

CA770103 JB January 3, 1978  12:28 AM

3002	5	3002
3002	5	3002
3002	5	3002
3168	5	3002
2965	6	3002
3002	6	3002


************************



A Record and File Partitioning Model

One of the main objectives in the design of
a file <B>system is</B> the reduction of storage and data 
transfer costs.  This paper presents a model in which
several  requests access the file system, and each 
request requires information from one or more variable
length data-items.  The probabilities of access 
and the distribution of each data-item's length are assumed
to be known, and to be mutually independent. 
The file system uses one or more storage devices, and
each record may be partitioned into subrecords 
that are stored on different devices.  One of the subrecords
is designated as the primary record; when 
a request for a record is made, the primary record is
first accessed, and other subrecords are accessed 
only if the pertinent information is not stored in the
primary record.  The model that is presented in 
this paper, both as a nonlinear programming model and
a mixed integer programming model, is a very general 
one; several types of file systems may be derived from
it by an appropriate selection of its parameters. 
 This model has already been used in the optimization of
library routines' storage at a large scale operating 
system.

CACM January, 1977

Babad, J. M.

file system, file design, file partitioning, record partitioning

3.73

CA770103 JB January 3, 1978  12:28 AM

3002	5	3002
3002	5	3002
3002	5	3002
3168	5	3002
2965	6	3002
3002	6	3002


************************



A Record and File Partitioning Model

One of the main objectives in the design of
a file system is the reduction of storage and data 
transfer costs.  This paper presents a model in which
several  requests access the file system, and each 
request requires information from one or more variable
length data-items.  The probabilities of access 
and the distribution of each data-item's length are assumed
to be known, and to be mutually independent. 
The file system uses one or more storage devices, and
each record may be partitioned into subrecords 
that are stored on different devices.  One of the subrecords
is designated as the primary record; when 
a request for a record is made, the primary record is
first accessed, and other subrecords are accessed 
only if the pertinent information is not stored in the
primary record.  The model that is presented in 
this paper, both as a nonlinear programming model and
a mixed integer programming model, <B>is a</B> very general 
one; several types of file systems may be derived from
it by an appropriate selection of its parameters. 
 This model has already been used in the optimization of
library routines' storage at a large scale operating 
system.

CACM January, 1977

Babad, J. M.

file system, file design, file partitioning, record partitioning

3.73

CA770103 JB January 3, 1978  12:28 AM

3002	5	3002
3002	5	3002
3002	5	3002
3168	5	3002
2965	6	3002
3002	6	3002


************************



A Record and File Partitioning Model

One of the main objectives in the design of
a file system <B>is the</B> reduction of storage and data 
transfer costs.  This paper presents a model in which
several  requests access the file system, and each 
request requires information from one or more variable
length data-items.  The probabilities of access 
and the distribution of each data-item's length are assumed
to be known, and to be mutually independent. 
The file system uses one or more storage devices, and
each record may be partitioned into subrecords 
that are stored on different devices.  One of the subrecords
is designated as the primary record; when 
a request for a record is made, the primary record is
first accessed, and other subrecords are accessed 
only if the pertinent information is not stored in the
primary record.  The model that is presented in 
this paper, both as a nonlinear programming model and
a mixed integer programming model, is a very general 
one; several types of file systems may be derived from
it by an appropriate selection of its parameters. 
 This model has already been used in the optimization of
library routines' storage at a large scale operating 
system.

CACM January, 1977

Babad, J. M.

file system, file design, file partitioning, record partitioning

3.73

CA770103 JB January 3, 1978  12:28 AM

3002	5	3002
3002	5	3002
3002	5	3002
3168	5	3002
2965	6	3002
3002	6	3002


************************



A Record and File Partitioning Model

One of the main objectives in the design of
a file system is the reduction of storage and data 
transfer costs.  This paper presents a model in which
several  requests access the file system, and each 
request requires information from one or more variable
length data-items.  The probabilities <B>of a</B>ccess 
and the distribution of each data-item's length are assumed
to be known, and to be mutually independent. 
The file system uses one or more storage devices, and
each record may be partitioned into subrecords 
that are stored on different devices.  One of the subrecords
is designated as the primary record; when 
a request for a record is made, the primary record is
first accessed, and other subrecords are accessed 
only if the pertinent information is not stored in the
primary record.  The model that is presented in 
this paper, both as a nonlinear programming model and
a mixed integer programming model, is a very general 
one; several types of file systems may be derived from
it by an appropriate selection of its parameters. 
 This model has already been used in the optimization of
library routines' storage at a large scale operating 
system.

CACM January, 1977

Babad, J. M.

file system, file design, file partitioning, record partitioning

3.73

CA770103 JB January 3, 1978  12:28 AM

3002	5	3002
3002	5	3002
3002	5	3002
3168	5	3002
2965	6	3002
3002	6	3002


************************



A Record and File Partitioning Model

One of the main objectives in the design of
a file system is the reduction of storage and data 
transfer costs.  This paper presents a model in which
several  requests access the file system, and each 
request requires information from one or more variable
length data-items.  The probabilities of access 
and the distribution of each data-item's length are assumed
to be known, and to be mutually independent. 
The file system uses one or more storage devices, and
each record may be partitioned into subrecords 
that are stored on different devices.  One of the subrecords
is designated as the primary record; when 
a request for a record is made, the primary record is
first accessed, and other subrecords are accessed 
only if the pertinent information is not stored in the
primary record.  The model that is presented in 
this paper, both as a nonlinear programming model and
a mixed integer programming model, is a very general 
one; several <B>types of</B> file systems may be derived from
it by an appropriate selection of its parameters. 
 This model has already been used in the optimization of
library routines' storage at a large scale operating 
system.

CACM January, 1977

Babad, J. M.

file system, file design, file partitioning, record partitioning

3.73

CA770103 JB January 3, 1978  12:28 AM

3002	5	3002
3002	5	3002
3002	5	3002
3168	5	3002
2965	6	3002
3002	6	3002


************************

************************
Document:  CACM-0243.html
************************


N-Dimensional Codes for Detecting and Correcting Multiple Errors

The paper introduces a new family of codes
for detecting and correcting multiple errors in 
a binary-coded message.  The message itself is arranged
(conceptually) into a multidimensional rectangular 
array.  The processes of encoding and error detection
are based upon parity evaluations along prescribed 
dimensions <B>of the</B> array.  Effectiveness of the codes
is increased by introducing a "system check bit", 
which is essentially a parity check on the other parity
bits.  Only three-dimensional codes are discussed 
in this paper with parity evaluations along the horizontal,
the vertical, and one main diagonal.  However, 
the family of codes is not restricted to three dimensions,
as evidenced by the discussion by Minnick 
and Ashenhurst on a similar multidimensional single-bit
selection plan used for another purpose [6]. 
 A four-dimensional code, correcting three and detecting
four errors, has been developed; the extension 
to higher-dimensional codes with greater correction power is straightforward.

CACM December, 1961

Rubinoff, M.

CA611207 JB March 15, 1978  10:23 PM

243	5	243
243	5	243
243	5	243


************************



N-Dimensional Codes for Detecting and Correcting Multiple Errors

The paper introduces a new family of codes
for detecting and correcting multiple errors in 
a binary-coded message.  The message itself <B>is a</B>rranged
(conceptually) into a multidimensional rectangular 
array.  The processes of encoding and error detection
are based upon parity evaluations along prescribed 
dimensions of the array.  Effectiveness of the codes
is increased by introducing a "system check bit", 
which is essentially a parity check on the other parity
bits.  Only three-dimensional codes are discussed 
in this paper with parity evaluations along the horizontal,
the vertical, and one main diagonal.  However, 
the family of codes is not restricted to three dimensions,
as evidenced by the discussion by Minnick 
and Ashenhurst on a similar multidimensional single-bit
selection plan used for another purpose [6]. 
 A four-dimensional code, correcting three and detecting
four errors, has been developed; the extension 
to higher-dimensional codes with greater correction power is straightforward.

CACM December, 1961

Rubinoff, M.

CA611207 JB March 15, 1978  10:23 PM

243	5	243
243	5	243
243	5	243


************************

************************
Document:  CACM-2439.html
************************


Multiple Terminals Under User Program
Control in a Time-Sharing Environment

User-written programs on the Dartmouth Time-Sharing
system can communicate with many remote 
terminals simultaneously and can control the interactions
between these terminals.  Such programs can 
be written using standard input and output instructions
in any language available on the system.  This 
paper describes how this multiple-terminal facility
was implemented without requiring any changes in 
the system executive or in any <B>of the</B> system's compilers or interpreters.

CACM October, 1973

McGeachie, J. S.

DTSS, multiple terminals, remote terminals, remote
consoles, time-sharing, on-line interaction, 
on-line games

3.81 4.32

CA731001 JB January 23, 1978  8:33 AM

2439	5	2439
2439	5	2439
2439	5	2439


************************



Multiple Terminals Under User Program
Control <B>in a</B> Time-Sharing Environment

User-written programs on the Dartmouth Time-Sharing
system can communicate with many remote 
terminals simultaneously and can control the interactions
between these terminals.  Such programs can 
be written using standard input and output instructions
in any language available on the system.  This 
paper describes how this multiple-terminal facility
was implemented without requiring any changes in 
the system executive or in any of the system's compilers or interpreters.

CACM October, 1973

McGeachie, J. S.

DTSS, multiple terminals, remote terminals, remote
consoles, time-sharing, on-line interaction, 
on-line games

3.81 4.32

CA731001 JB January 23, 1978  8:33 AM

2439	5	2439
2439	5	2439
2439	5	2439


************************

************************
Document:  CACM-2958.html
************************


Abstract Data Types and the Development of Data Structures

Abstract <B>data types</B> can play a significant role
in the development of software that is reliable, 
efficient, and flexible.  This paper presents and discusses
the application of an algebraic technique 
for the specification of abstract data types.  Among
the examples presented is a top-down development 
of a symbol table for a block structured language; a discussion
of the proof of its correctness is given. 
 The paper also contains a brief discussion of the problems
involved in constructing algebraic specifications 
that are both consistent and complete.

CACM June, 1977

Guttag, J.

abstract data type, correctness proof, data type,
data structure, specification, software specification

4.34 5.24

CA770605 JB December 29, 1977  1:17 AM

2704	4	2958
2738	4	2958
2866	4	2958
2869	4	2958
2941	4	2958
2958	4	2958
3004	4	2958
3030	4	2958
2356	5	2958
2958	5	2958
2958	5	2958
2958	5	2958
3030	5	2958
3031	5	2958
3049	5	2958
2247	6	2958
2356	6	2958
2457	6	2958
2651	6	2958
2939	6	2958
2956	6	2958
2958	6	2958
2958	6	2958
2958	6	2958
2957	6	2958
2960	6	2958
2972	6	2958


************************



Abstract Data Types <B>and the</B> Development of Data Structures

Abstract data types can play a significant role
in the development of software that is reliable, 
efficient, and flexible.  This paper presents and discusses
the application of an algebraic technique 
for the specification of abstract data types.  Among
the examples presented is a top-down development 
of a symbol table for a block structured language; a discussion
of the proof of its correctness is given. 
 The paper also contains a brief discussion of the problems
involved in constructing algebraic specifications 
that are both consistent and complete.

CACM June, 1977

Guttag, J.

abstract data type, correctness proof, data type,
data structure, specification, software specification

4.34 5.24

CA770605 JB December 29, 1977  1:17 AM

2704	4	2958
2738	4	2958
2866	4	2958
2869	4	2958
2941	4	2958
2958	4	2958
3004	4	2958
3030	4	2958
2356	5	2958
2958	5	2958
2958	5	2958
2958	5	2958
3030	5	2958
3031	5	2958
3049	5	2958
2247	6	2958
2356	6	2958
2457	6	2958
2651	6	2958
2939	6	2958
2956	6	2958
2958	6	2958
2958	6	2958
2958	6	2958
2957	6	2958
2960	6	2958
2972	6	2958


************************



Abstract Data Types and the Development of Data Structures

Abstract data types can play a significant role
in the development of software that is reliable, 
efficient, and flexible.  This paper presents and discusses
the application of an algebraic technique 
for the specification of abstract data types.  Among
the examples presented <B>is a</B> top-down development 
of a symbol table for a block structured language; a discussion
of the proof of its correctness is given. 
 The paper also contains a brief discussion of the problems
involved in constructing algebraic specifications 
that are both consistent and complete.

CACM June, 1977

Guttag, J.

abstract data type, correctness proof, data type,
data structure, specification, software specification

4.34 5.24

CA770605 JB December 29, 1977  1:17 AM

2704	4	2958
2738	4	2958
2866	4	2958
2869	4	2958
2941	4	2958
2958	4	2958
3004	4	2958
3030	4	2958
2356	5	2958
2958	5	2958
2958	5	2958
2958	5	2958
3030	5	2958
3031	5	2958
3049	5	2958
2247	6	2958
2356	6	2958
2457	6	2958
2651	6	2958
2939	6	2958
2956	6	2958
2958	6	2958
2958	6	2958
2958	6	2958
2957	6	2958
2960	6	2958
2972	6	2958


************************



Abstract Data Types and the Development of Data Structures

Abstract data types can play a significant role
in the development of software that is reliable, 
efficient, and flexible.  This paper presents and discusses
the application of an algebraic technique 
for the specification of abstract data types.  Among
the examples presented is a top-down development 
of a symbol table for a block structured language; a discussion
<B>of the</B> proof of its correctness is given. 
 The paper also contains a brief discussion of the problems
involved in constructing algebraic specifications 
that are both consistent and complete.

CACM June, 1977

Guttag, J.

abstract data type, correctness proof, data type,
data structure, specification, software specification

4.34 5.24

CA770605 JB December 29, 1977  1:17 AM

2704	4	2958
2738	4	2958
2866	4	2958
2869	4	2958
2941	4	2958
2958	4	2958
3004	4	2958
3030	4	2958
2356	5	2958
2958	5	2958
2958	5	2958
2958	5	2958
3030	5	2958
3031	5	2958
3049	5	2958
2247	6	2958
2356	6	2958
2457	6	2958
2651	6	2958
2939	6	2958
2956	6	2958
2958	6	2958
2958	6	2958
2958	6	2958
2957	6	2958
2960	6	2958
2972	6	2958


************************



Abstract Data Types and the Development of Data Structures

Abstract data types can play a significant role
in the development of software that is reliable, 
efficient, and flexible.  This paper presents and discusses
the application of an algebraic technique 
for the specification of abstract data types.  Among
the examples presented is a top-down development 
of a symbol table for a block structured language; a discussion
of the proof of its correctness is given. 
 The paper also contains a brief discussion of the problems
involved in constructing algebraic specifications 
that <B>are both</B> consistent and complete.

CACM June, 1977

Guttag, J.

abstract data type, correctness proof, data type,
data structure, specification, software specification

4.34 5.24

CA770605 JB December 29, 1977  1:17 AM

2704	4	2958
2738	4	2958
2866	4	2958
2869	4	2958
2941	4	2958
2958	4	2958
3004	4	2958
3030	4	2958
2356	5	2958
2958	5	2958
2958	5	2958
2958	5	2958
3030	5	2958
3031	5	2958
3049	5	2958
2247	6	2958
2356	6	2958
2457	6	2958
2651	6	2958
2939	6	2958
2956	6	2958
2958	6	2958
2958	6	2958
2958	6	2958
2957	6	2958
2960	6	2958
2972	6	2958


************************



Abstract Data Types and the Development of Data Structures

Abstract data types can play a significant role
in the development of software that is reliable, 
efficient, and flexible.  This paper presents and discusses
the application <B>of a</B>n algebraic technique 
for the specification of abstract data types.  Among
the examples presented is a top-down development 
of a symbol table for a block structured language; a discussion
of the proof of its correctness is given. 
 The paper also contains a brief discussion of the problems
involved in constructing algebraic specifications 
that are both consistent and complete.

CACM June, 1977

Guttag, J.

abstract data type, correctness proof, data type,
data structure, specification, software specification

4.34 5.24

CA770605 JB December 29, 1977  1:17 AM

2704	4	2958
2738	4	2958
2866	4	2958
2869	4	2958
2941	4	2958
2958	4	2958
3004	4	2958
3030	4	2958
2356	5	2958
2958	5	2958
2958	5	2958
2958	5	2958
3030	5	2958
3031	5	2958
3049	5	2958
2247	6	2958
2356	6	2958
2457	6	2958
2651	6	2958
2939	6	2958
2956	6	2958
2958	6	2958
2958	6	2958
2958	6	2958
2957	6	2958
2960	6	2958
2972	6	2958


************************

************************
Document:  CACM-1474.html
************************


Tests of Probabilistic Models for Propagation of Roundoff Errors

In any prolonged computation it is generally
assumed <B>that the</B> accumulated effect of roundoff 
errors is in some sense statistical.  The purpose of this
paper is to give precise descriptions of certain 
probabilistic models for roundoff error, and then to
describe a series of experiments for testing the 
validity of these models.  It is concluded that the models
are in general very good.  Discrepancies are 
both rare and mild.  The test techniques can also be
used to experiment with various types of special 
arithmetic.

CACM February, 1966

Hull, T. E.
Swenson, J. R.

CA660210 JB March 3, 1978  2:37 PM

1474	5	1474
1474	5	1474
1474	5	1474
2525	5	1474
1474	6	1474


************************



Tests of Probabilistic Models for Propagation of Roundoff Errors

In any prolonged computation it is generally
assumed that the accumulated effect of roundoff 
errors is in some sense statistical.  The purpose of this
paper is to give precise descriptions of certain 
probabilistic models for roundoff error, <B>and the</B>n to
describe a series of experiments for testing the 
validity of these models.  It is concluded that the models
are in general very good.  Discrepancies are 
both rare and mild.  The test techniques can also be
used to experiment with various types of special 
arithmetic.

CACM February, 1966

Hull, T. E.
Swenson, J. R.

CA660210 JB March 3, 1978  2:37 PM

1474	5	1474
1474	5	1474
1474	5	1474
2525	5	1474
1474	6	1474


************************



Tests of Probabilistic Models for Propagation of Roundoff Errors

In any prolonged computation it is generally
assumed that the accumulated effect of roundoff 
errors is in some sense statistical.  The purpose of this
paper is to give precise descriptions of certain 
probabilistic models for roundoff error, and then to
describe a series of experiments for testing the 
validity <B>of the</B>se models.  It is concluded that the models
are in general very good.  Discrepancies are 
both rare and mild.  The test techniques can also be
used to experiment with various types of special 
arithmetic.

CACM February, 1966

Hull, T. E.
Swenson, J. R.

CA660210 JB March 3, 1978  2:37 PM

1474	5	1474
1474	5	1474
1474	5	1474
2525	5	1474
1474	6	1474


************************



Tests of Probabilistic Models for Propagation of Roundoff Errors

In any prolonged computation it is generally
assumed that the accumulated effect of roundoff 
errors is in some sense statistical.  The purpose of this
paper is to give precise descriptions of certain 
probabilistic models for roundoff error, and then to
describe a series of experiments for testing the 
validity of these models.  It is concluded that the models
are in general very good.  Discrepancies are 
both rare and mild.  The test techniques can also be
used to experiment with various <B>types of</B> special 
arithmetic.

CACM February, 1966

Hull, T. E.
Swenson, J. R.

CA660210 JB March 3, 1978  2:37 PM

1474	5	1474
1474	5	1474
1474	5	1474
2525	5	1474
1474	6	1474


************************

************************
Document:  CACM-3177.html
************************


How to Share a Secret

In this paper we show how to divide data D into
n pieces in such a way that D is easily reconstructable from any
k pieces, but even complete knowledge of k - 1 pieces reveals
olutely no information about D.  This technique enables the construction
of robust key management schemes for cryptographic systems
that can function securely and reliably even when misfortunes destroy
half the pieces and security breaches expose all but one <B>of the</B>
remaining pieces.

CACM November, 1979

Shamir, A.

Cryptography, key management, interpolation

5.39 5.6

CA791105 DB January 23, 1980  11:48 AM

3038	4	3177
3111	4	3177
3177	4	3177
3021	5	3177
3177	5	3177
3177	5	3177
3177	5	3177


************************

************************
Document:  CACM-2815.html
************************


High-Level Binding with Low-Level Linkers

An easy to implement scheme is described by
which a compiler can enforce agreement between 
complex <B>data types</B> in separately compiled modules.
 The scheme is designed to work with any existing 
link editor or linking loader, no matter how deficient.
 Obscure run-time errors caused by inconsistent 
usages are forestalled by static errors detected at linking time.

CACM November, 1976

Hamlet, R. G.

separate compilation, binding, linking, strong typing

4.10 4.22

CA761108 JB January 3, 1978  2:44 PM

2815	5	2815
2815	5	2815
2815	5	2815


************************

************************
Document:  CACM-2957.html
************************


Database Abstractions: Aggregation

Aggregation is in troduced as an abstraction
which is important in conceptualizing the real 
world.  Aggregation transforms a relationship between
objects into a higher-level object.  A new data 
type, called aggregation, is developed which, under
certain criteria of "well-definedness," specifies 
aggregation abstractions.  Relational databases defined
as collections <B>of a</B>ggregates are structured as 
a hierarchy on n-ary relations.  To main tain well-definedness,
update operations on such databases must 
preserve two invariants.  Well-defined relations are
distinct from relations in third normal form.  It 
is shown that these notions are complementary and both are
important in database design.  A top-down 
methodology for database design is described which separates
decisions concerning aggregate structure 
from decisions concerning key identification.  It is
suggested that aggregate types, and other types 
which support real-world abstractions without in troducing
implementation detail, should be incorporated 
into programming languages.

CACM June, 1977

Smith, J. M.
Smith, D. C. P.

data abstraction, relational database, data type,
aggregation, database design, data structure, 
knowledge representation, data definition language

3.65 3.69 3.79 4.29 4.33 4.34

CA770606 JB December 29, 1977  12:33 AM

2155	4	2957
2406	4	2957
2710	4	2957
2715	4	2957
2716	4	2957
2717	4	2957
2718	4	2957
2765	4	2957
2817	4	2957
2888	4	2957
2901	4	2957
2957	4	2957
2959	4	2957
2965	4	2957
3087	4	2957
3154	4	2957
2046	5	2957
2957	5	2957
2957	5	2957
2957	5	2957
3049	5	2957
2956	6	2957
2958	6	2957
2957	6	2957
2960	6	2957


************************



Database Abstractions: Aggregation

Aggregation is in troduced as an abstraction
which is important in conceptualizing the real 
world.  Aggregation transforms a relationship between
objects into a higher-level object.  A new data 
type, called aggregation, is developed which, under
certain criteria of "well-definedness," specifies 
aggregation abstractions.  Relational databases defined
as collections of aggregates are structured as 
a hierarchy on n-ary relations.  To main tain well-definedness,
update operations on such databases must 
preserve two invariants.  Well-defined relations are
distinct from relations in third normal form.  It 
is shown <B>that the</B>se notions are complementary and both are
important in database design.  A top-down 
methodology for database design is described which separates
decisions concerning aggregate structure 
from decisions concerning key identification.  It is
suggested that aggregate types, and other types 
which support real-world abstractions without in troducing
implementation detail, should be incorporated 
into programming languages.

CACM June, 1977

Smith, J. M.
Smith, D. C. P.

data abstraction, relational database, data type,
aggregation, database design, data structure, 
knowledge representation, data definition language

3.65 3.69 3.79 4.29 4.33 4.34

CA770606 JB December 29, 1977  12:33 AM

2155	4	2957
2406	4	2957
2710	4	2957
2715	4	2957
2716	4	2957
2717	4	2957
2718	4	2957
2765	4	2957
2817	4	2957
2888	4	2957
2901	4	2957
2957	4	2957
2959	4	2957
2965	4	2957
3087	4	2957
3154	4	2957
2046	5	2957
2957	5	2957
2957	5	2957
2957	5	2957
3049	5	2957
2956	6	2957
2958	6	2957
2957	6	2957
2960	6	2957


************************



Database Abstractions: Aggregation

Aggregation is in troduced as an abstraction
which is important in conceptualizing the real 
world.  Aggregation transforms a <B>relationship between</B>
objects into a higher-level object.  A new data 
type, called aggregation, is developed which, under
certain criteria of "well-definedness," specifies 
aggregation abstractions.  Relational databases defined
as collections of aggregates are structured as 
a hierarchy on n-ary relations.  To main tain well-definedness,
update operations on such databases must 
preserve two invariants.  Well-defined relations are
distinct from relations in third normal form.  It 
is shown that these notions are complementary and both are
important in database design.  A top-down 
methodology for database design is described which separates
decisions concerning aggregate structure 
from decisions concerning key identification.  It is
suggested that aggregate types, and other types 
which support real-world abstractions without in troducing
implementation detail, should be incorporated 
into programming languages.

CACM June, 1977

Smith, J. M.
Smith, D. C. P.

data abstraction, relational database, data type,
aggregation, database design, data structure, 
knowledge representation, data definition language

3.65 3.69 3.79 4.29 4.33 4.34

CA770606 JB December 29, 1977  12:33 AM

2155	4	2957
2406	4	2957
2710	4	2957
2715	4	2957
2716	4	2957
2717	4	2957
2718	4	2957
2765	4	2957
2817	4	2957
2888	4	2957
2901	4	2957
2957	4	2957
2959	4	2957
2965	4	2957
3087	4	2957
3154	4	2957
2046	5	2957
2957	5	2957
2957	5	2957
2957	5	2957
3049	5	2957
2956	6	2957
2958	6	2957
2957	6	2957
2960	6	2957


************************

************************
Document:  CACM-1482.html
************************


BUGSYS: A Programming System for Picture Processing-Not for Debugging

BUGSYS is a picture processing and measuring
system that depends upon a pictorial input to 
the computer's memory.  BUGSYS can be used for many
types of applications.  In particular, the authors 
have used the system for the analysis of linear graphs.
 The main concept <B>of the</B> system is the use of 
a collection of programmable pointers, which
are visualized as a family of "bugs."

CACM February, 1966

Ledley, R. S.
Jacobsen, J.
Belson, M.

CA660205 JB March 3, 1978  3:16 PM

1482	5	1482
1482	5	1482
1482	5	1482


************************



BUGSYS: A Programming System for Picture Processing-Not for Debugging

BUGSYS is a picture processing and measuring
system that depends upon a pictorial input to 
the computer's memory.  BUGSYS can be used for many
<B>types of</B> applications.  In particular, the authors 
have used the system for the analysis of linear graphs.
 The main concept of the system is the use of 
a collection of programmable pointers, which
are visualized as a family of "bugs."

CACM February, 1966

Ledley, R. S.
Jacobsen, J.
Belson, M.

CA660205 JB March 3, 1978  3:16 PM

1482	5	1482
1482	5	1482
1482	5	1482


************************



BUGSYS: A Programming System for Picture Processing-Not for Debugging

BUGSYS is a picture processing and measuring
system that depends upon a pictorial input to 
the computer's memory.  BUGSYS can be used for many
types of applications.  In particular, the authors 
have used the system for the analysis of linear graphs.
 The main concept of the system <B>is the</B> use of 
a collection of programmable pointers, which
are visualized as a family of "bugs."

CACM February, 1966

Ledley, R. S.
Jacobsen, J.
Belson, M.

CA660205 JB March 3, 1978  3:16 PM

1482	5	1482
1482	5	1482
1482	5	1482


************************



BUGSYS: A Programming System for Picture Processing-Not for Debugging

BUGSYS is a picture processing and measuring
system that depends upon a pictorial input to 
the computer's memory.  BUGSYS can be used for many
types of applications.  In particular, the authors 
have used the system for the analysis of linear graphs.
 The main concept of the <B>system is</B> the use of 
a collection of programmable pointers, which
are visualized as a family of "bugs."

CACM February, 1966

Ledley, R. S.
Jacobsen, J.
Belson, M.

CA660205 JB March 3, 1978  3:16 PM

1482	5	1482
1482	5	1482
1482	5	1482


************************



BUGSYS: A Programming System for Picture Processing-Not for Debugging

BUGSYS <B>is a</B> picture processing and measuring
system that depends upon a pictorial input to 
the computer's memory.  BUGSYS can be used for many
types of applications.  In particular, the authors 
have used the system for the analysis of linear graphs.
 The main concept of the system is the use of 
a collection of programmable pointers, which
are visualized as a family of "bugs."

CACM February, 1966

Ledley, R. S.
Jacobsen, J.
Belson, M.

CA660205 JB March 3, 1978  3:16 PM

1482	5	1482
1482	5	1482
1482	5	1482


************************



BUGSYS: A Programming System for Picture Processing-Not for Debugging

BUGSYS is a picture processing and measuring
system that depends upon a pictorial input to 
the computer's memory.  BUGSYS can be used for many
types <B>of a</B>pplications.  In particular, the authors 
have used the system for the analysis of linear graphs.
 The main concept of the system is the use of 
a collection of programmable pointers, which
are visualized as a family of "bugs."

CACM February, 1966

Ledley, R. S.
Jacobsen, J.
Belson, M.

CA660205 JB March 3, 1978  3:16 PM

1482	5	1482
1482	5	1482
1482	5	1482


************************

************************
Document:  CACM-1625.html
************************


On the Automatic Simplification of Source-Language Programs

Methods of simplification that can be applied
automatically to programs written in an ALGOL-like 
language are discussed.  The simplifications are based
on the form of the program <B>and the</B> knowledge obtained 
by a processor, without any understanding of what the
program is supposed to do.  These methods have 
been implemented in a processor called SURE that accepts
a program written in JOVIAL and outputs an equivalent 
JOVIAL program that may be shorter and may be executed
faster than the original.  SURE is described, 
some of the problems encountered in automatic improvement
at the source-language level are discussed, 
and further types of automatic program improvement are suggested.

CACM March, 1967

Clark, E. R.

CA670304 JB February 28, 1978  1:33 PM

1084	4	1625
1379	4	1625
1625	4	1625
1625	4	1625
1807	4	1625
1945	4	1625
1947	4	1625
1248	5	1625
1625	5	1625
1625	5	1625
1625	5	1625
669	5	1625


************************



On the Automatic Simplification of Source-Language Programs

Methods of simplification that can be applied
automatically to programs written in an ALGOL-like 
language are discussed.  The simplifications are based
on the form of the program and the knowledge obtained 
by a processor, without any understanding of what the
program is supposed to do.  These methods have 
been implemented in a processor called SURE that accepts
a program written in JOVIAL and outputs an equivalent 
JOVIAL program that may be shorter and may be executed
faster than the original.  SURE is described, 
some of the problems encountered in automatic improvement
at the source-language level are discussed, 
and further types <B>of a</B>utomatic program improvement are suggested.

CACM March, 1967

Clark, E. R.

CA670304 JB February 28, 1978  1:33 PM

1084	4	1625
1379	4	1625
1625	4	1625
1625	4	1625
1807	4	1625
1945	4	1625
1947	4	1625
1248	5	1625
1625	5	1625
1625	5	1625
1625	5	1625
669	5	1625


************************



On the Automatic Simplification of Source-Language Programs

Methods of simplification that can be applied
automatically to programs written <B>in a</B>n ALGOL-like 
language are discussed.  The simplifications are based
on the form of the program and the knowledge obtained 
by a processor, without any understanding of what the
program is supposed to do.  These methods have 
been implemented in a processor called SURE that accepts
a program written in JOVIAL and outputs an equivalent 
JOVIAL program that may be shorter and may be executed
faster than the original.  SURE is described, 
some of the problems encountered in automatic improvement
at the source-language level are discussed, 
and further types of automatic program improvement are suggested.

CACM March, 1967

Clark, E. R.

CA670304 JB February 28, 1978  1:33 PM

1084	4	1625
1379	4	1625
1625	4	1625
1625	4	1625
1807	4	1625
1945	4	1625
1947	4	1625
1248	5	1625
1625	5	1625
1625	5	1625
1625	5	1625
669	5	1625


************************



On the Automatic Simplification of Source-Language Programs

Methods of simplification that can be applied
automatically to programs written in an ALGOL-like 
language are discussed.  The simplifications are based
on the form of the program and the knowledge obtained 
by a processor, without any understanding of what the
program is supposed to do.  These methods have 
been implemented in a processor called SURE that accepts
a program written in JOVIAL and outputs an equivalent 
JOVIAL program that may be shorter and may be executed
faster than the original.  SURE is described, 
some of the problems encountered in automatic improvement
at the source-language level are discussed, 
and further <B>types of</B> automatic program improvement are suggested.

CACM March, 1967

Clark, E. R.

CA670304 JB February 28, 1978  1:33 PM

1084	4	1625
1379	4	1625
1625	4	1625
1625	4	1625
1807	4	1625
1945	4	1625
1947	4	1625
1248	5	1625
1625	5	1625
1625	5	1625
1625	5	1625
669	5	1625


************************



On the Automatic Simplification of Source-Language Programs

Methods of simplification that can be applied
automatically to programs written in an ALGOL-like 
language are discussed.  The simplifications are based
on the form <B>of the</B> program and the knowledge obtained 
by a processor, without any understanding of what the
program is supposed to do.  These methods have 
been implemented in a processor called SURE that accepts
a program written in JOVIAL and outputs an equivalent 
JOVIAL program that may be shorter and may be executed
faster than the original.  SURE is described, 
some of the problems encountered in automatic improvement
at the source-language level are discussed, 
and further types of automatic program improvement are suggested.

CACM March, 1967

Clark, E. R.

CA670304 JB February 28, 1978  1:33 PM

1084	4	1625
1379	4	1625
1625	4	1625
1625	4	1625
1807	4	1625
1945	4	1625
1947	4	1625
1248	5	1625
1625	5	1625
1625	5	1625
1625	5	1625
669	5	1625


************************

************************
Document:  CACM-3132.html
************************


Experiments with Some Algorithms that Find
Central Solutions for Pattern Classification

In two-class pattern recognition, it is a standard
technique to have an algorithm finding hyperplanes
which separates the two classes in a linearly separable training
set.  The traditional methods find a hyperplane which separates all
points in the other, but such a hyperplane is not necessarily centered
in the empty space between the two classes.  Since a central
hyperplane does not favor one class or the other, it should have
a lower error rate in classifying new points and <B>is the</B>refore better
than a noncentral hyperplane.  Six algorithms for finding central
hyperplanes are tested on three data sets.  Although frequently
used practice, the modified relaxation algorithm is very poor. 
Three algorithms which are defined in the paper are found to be
quite good.

CACM March, 1979

Slagle, J.

Pattern recognition, pattern classification, linear discriminants, central
hyperplanes, centering, centrality criteria, dead zone, hyperplane,
linearly separable, relaxation algorithm, accelerated relaxation

3.62 3.63

CA790303 DH April 12, 1979  3:20 PM

3132	4	3132
2215	5	3132
3132	5	3132
3132	5	3132
3132	5	3132


************************



Experiments with Some Algorithms that Find
Central Solutions for Pattern Classification

In two-class pattern recognition, it is a standard
technique to have an algorithm finding hyperplanes
which separates the two classes <B>in a</B> linearly separable training
set.  The traditional methods find a hyperplane which separates all
points in the other, but such a hyperplane is not necessarily centered
in the empty space between the two classes.  Since a central
hyperplane does not favor one class or the other, it should have
a lower error rate in classifying new points and is therefore better
than a noncentral hyperplane.  Six algorithms for finding central
hyperplanes are tested on three data sets.  Although frequently
used practice, the modified relaxation algorithm is very poor. 
Three algorithms which are defined in the paper are found to be
quite good.

CACM March, 1979

Slagle, J.

Pattern recognition, pattern classification, linear discriminants, central
hyperplanes, centering, centrality criteria, dead zone, hyperplane,
linearly separable, relaxation algorithm, accelerated relaxation

3.62 3.63

CA790303 DH April 12, 1979  3:20 PM

3132	4	3132
2215	5	3132
3132	5	3132
3132	5	3132
3132	5	3132


************************



Experiments with Some Algorithms that Find
Central Solutions for Pattern Classification

In two-class pattern recognition, it is a standard
technique to have an algorithm finding hyperplanes
which separates the two classes in a linearly separable training
set.  The traditional methods find a hyperplane which separates all
points in the other, but such a hyperplane is not necessarily centered
in the empty space between the two classes.  Since a central
hyperplane does not favor one class or the other, it should have
a lower error rate in classifying new points and <B>is there</B>fore better
than a noncentral hyperplane.  Six algorithms for finding central
hyperplanes are tested on three data sets.  Although frequently
used practice, the modified relaxation algorithm is very poor. 
Three algorithms which are defined in the paper are found to be
quite good.

CACM March, 1979

Slagle, J.

Pattern recognition, pattern classification, linear discriminants, central
hyperplanes, centering, centrality criteria, dead zone, hyperplane,
linearly separable, relaxation algorithm, accelerated relaxation

3.62 3.63

CA790303 DH April 12, 1979  3:20 PM

3132	4	3132
2215	5	3132
3132	5	3132
3132	5	3132
3132	5	3132


************************



Experiments with Some Algorithms that Find
Central Solutions for Pattern Classification

In two-class pattern recognition, it <B>is a</B> standard
technique to have an algorithm finding hyperplanes
which separates the two classes in a linearly separable training
set.  The traditional methods find a hyperplane which separates all
points in the other, but such a hyperplane is not necessarily centered
in the empty space between the two classes.  Since a central
hyperplane does not favor one class or the other, it should have
a lower error rate in classifying new points and is therefore better
than a noncentral hyperplane.  Six algorithms for finding central
hyperplanes are tested on three data sets.  Although frequently
used practice, the modified relaxation algorithm is very poor. 
Three algorithms which are defined in the paper are found to be
quite good.

CACM March, 1979

Slagle, J.

Pattern recognition, pattern classification, linear discriminants, central
hyperplanes, centering, centrality criteria, dead zone, hyperplane,
linearly separable, relaxation algorithm, accelerated relaxation

3.62 3.63

CA790303 DH April 12, 1979  3:20 PM

3132	4	3132
2215	5	3132
3132	5	3132
3132	5	3132
3132	5	3132


************************

************************
Document:  CACM-1034.html
************************


Autosate

An automated data system analysis technique is
described. The technique is designed to alleviate 
some of the principal problems that beset current analysis-large
data workloads, long span of time between 
project inception and system operational date, the lack
of explicit directions for conducting data system 
analysis and using the results, and the lack <B>of a</B> technique
to control data system changes throughout 
its lifetime. The analysis is geared to determining workload,
relationships and storage characteristics 
of documents in the information network automatically.

CACM July, 1964

Gatto, O. T.

CA640713 JB March 9, 19788:07 PM

1034	5	1034
1034	5	1034
1034	5	1034


************************



Autosate

An automated data system analysis technique is
described. The technique is designed to alleviate 
some of the principal problems that beset current analysis-large
data workloads, long span of time between 
project inception and system operational date, the lack
of explicit directions for conducting data system 
analysis and using the results, <B>and the</B> lack of a technique
to control data system changes throughout 
its lifetime. The analysis is geared to determining workload,
relationships and storage characteristics 
of documents in the information network automatically.

CACM July, 1964

Gatto, O. T.

CA640713 JB March 9, 19788:07 PM

1034	5	1034
1034	5	1034
1034	5	1034


************************



Autosate

An automated data system analysis technique is
described. The technique is designed to alleviate 
some of the principal problems that beset current analysis-large
data workloads, long span of time between 
project inception and system operational date, the lack
of explicit directions for conducting data system 
analys<B>is a</B>nd using the results, and the lack of a technique
to control data system changes throughout 
its lifetime. The analysis is geared to determining workload,
relationships and storage characteristics 
of documents in the information network automatically.

CACM July, 1964

Gatto, O. T.

CA640713 JB March 9, 19788:07 PM

1034	5	1034
1034	5	1034
1034	5	1034


************************



Autosate

An automated data system analysis technique is
described. The technique is designed to alleviate 
some <B>of the</B> principal problems that beset current analysis-large
data workloads, long span of time between 
project inception and system operational date, the lack
of explicit directions for conducting data system 
analysis and using the results, and the lack of a technique
to control data system changes throughout 
its lifetime. The analysis is geared to determining workload,
relationships and storage characteristics 
of documents in the information network automatically.

CACM July, 1964

Gatto, O. T.

CA640713 JB March 9, 19788:07 PM

1034	5	1034
1034	5	1034
1034	5	1034


************************

************************
Document:  CACM-1719.html
************************


A Methodology for Calculating and
Optimizing Real-Time System Performance

The continually increasing size, complexity,
number of types, and cost of data processing systems 
are causing serious re-examination within government
and industry <B>of the</B> criteria for and methods of 
calculating and optimizing data processing system cost
and performance.  Real-time data processing systems 
as typified by the automated airline reservation system
are discussed in this paper.  Criteria for evaluating 
performance are described; a methodology for calculating
and optimizing is outlined; and the method is 
illustrated by carrying out a portion of the performance
calculation and the optimization of a drum-oriented 
message switching system.

CACM July, 1968

Stimler, S.
Brons, K. A.

real-time system analysis, real-time system design,
real-time system performance criteria, real-time 
system cost performance ratio

3.27 3.80 3.81 3.89 6.9

CA680710 JB February 22, 1978  11:40 AM

1719	5	1719
1719	5	1719
1719	5	1719
2319	5	1719
1408	6	1719
1719	6	1719
1749	6	1719
1751	6	1719
2016	6	1719
2017	6	1719
2080	6	1719
2188	6	1719
2203	6	1719
2204	6	1719


************************



A Methodology for Calculating and
Optimizing Real-Time System Performance

The continually increasing size, complexity,
number of types, and cost of data processing systems 
are causing serious re-examination within government
and industry of the criteria for and methods of 
calculating and optimizing data processing system cost
and performance.  Real-time data processing systems 
as typified by the automated airline reservation system
are discussed in this paper.  Criteria for evaluating 
performance are described; a methodology for calculating
and optimizing is outlined; and the method is 
illustrated by carrying out a portion of the performance
calculation and the optimization <B>of a</B> drum-oriented 
message switching system.

CACM July, 1968

Stimler, S.
Brons, K. A.

real-time system analysis, real-time system design,
real-time system performance criteria, real-time 
system cost performance ratio

3.27 3.80 3.81 3.89 6.9

CA680710 JB February 22, 1978  11:40 AM

1719	5	1719
1719	5	1719
1719	5	1719
2319	5	1719
1408	6	1719
1719	6	1719
1749	6	1719
1751	6	1719
2016	6	1719
2017	6	1719
2080	6	1719
2188	6	1719
2203	6	1719
2204	6	1719


************************



A Methodology for Calculating and
Optimizing Real-Time System Performance

The continually increasing size, complexity,
number of types, and cost of data processing systems 
are causing serious re-examination within government
and industry of the criteria for and methods of 
calculating and optimizing data processing system cost
and performance.  Real-time data processing systems 
as typified by the automated airline reservation system
are discussed in this paper.  Criteria for evaluating 
performance are described; a methodology for calculating
and optimizing is outlined; <B>and the</B> method is 
illustrated by carrying out a portion of the performance
calculation and the optimization of a drum-oriented 
message switching system.

CACM July, 1968

Stimler, S.
Brons, K. A.

real-time system analysis, real-time system design,
real-time system performance criteria, real-time 
system cost performance ratio

3.27 3.80 3.81 3.89 6.9

CA680710 JB February 22, 1978  11:40 AM

1719	5	1719
1719	5	1719
1719	5	1719
2319	5	1719
1408	6	1719
1719	6	1719
1749	6	1719
1751	6	1719
2016	6	1719
2017	6	1719
2080	6	1719
2188	6	1719
2203	6	1719
2204	6	1719


************************

************************
Document:  CACM-0867.html
************************


Least Squares Fitting of Planes to Surfaces Using Dynamic Programming

Dynamic programming has recently been used
by Stone, by Bellman and by Gluss to determine the 
closet fit of broken line segments to a curve in an
interval under the constraint that the number of 
segments is fixed.  In the present paper successive
models are developed to extend the method to the 
fitting of broken plane segments to surfaces z=g(x,y) defined
over certain types of subareas <B>of the</B> (x,y)-space. 
 The first model considers a rectangular area, with
the constraint that the plane segments are defined 
over a grid in the (x,y)-space.  It is then shown how
this model may be incorporated into an algorithm 
that provides successive approximations to optimal fits
for any type of closed area.  Finally, applications 
are briefly described.

CACM April, 1963

Gluss, B.

CA630424 JB March 14, 1978  11:43 AM

497	4	867
867	4	867
867	4	867
317	5	867
497	5	867
867	5	867
867	5	867
867	5	867


************************



Least Squares Fitting of Planes to Surfaces Using Dynamic Programming

Dynamic programming has recently been used
by Stone, by Bellman and by Gluss to determine the 
closet fit of broken line segments to a curve <B>in a</B>n
interval under the constraint that the number of 
segments is fixed.  In the present paper successive
models are developed to extend the method to the 
fitting of broken plane segments to surfaces z=g(x,y) defined
over certain types of subareas of the (x,y)-space. 
 The first model considers a rectangular area, with
the constraint that the plane segments are defined 
over a grid in the (x,y)-space.  It is then shown how
this model may be incorporated into an algorithm 
that provides successive approximations to optimal fits
for any type of closed area.  Finally, applications 
are briefly described.

CACM April, 1963

Gluss, B.

CA630424 JB March 14, 1978  11:43 AM

497	4	867
867	4	867
867	4	867
317	5	867
497	5	867
867	5	867
867	5	867
867	5	867


************************



Least Squares Fitting of Planes to Surfaces Using Dynamic Programming

Dynamic programming has recently been used
by Stone, by Bellman and by Gluss to determine the 
closet fit of broken line segments to a curve in an
interval under the constraint <B>that the</B> number of 
segments is fixed.  In the present paper successive
models are developed to extend the method to the 
fitting of broken plane segments to surfaces z=g(x,y) defined
over certain types of subareas of the (x,y)-space. 
 The first model considers a rectangular area, with
the constraint that the plane segments are defined 
over a grid in the (x,y)-space.  It is then shown how
this model may be incorporated into an algorithm 
that provides successive approximations to optimal fits
for any type of closed area.  Finally, applications 
are briefly described.

CACM April, 1963

Gluss, B.

CA630424 JB March 14, 1978  11:43 AM

497	4	867
867	4	867
867	4	867
317	5	867
497	5	867
867	5	867
867	5	867
867	5	867


************************



Least Squares Fitting of Planes to Surfaces Using Dynamic Programming

Dynamic programming has recently been used
by Stone, by Bellman and by Gluss to determine the 
closet fit of broken line segments to a curve in an
interval under the constraint that the number of 
segments is fixed.  In the present paper successive
models are developed to extend the method to the 
fitting of broken plane segments to surfaces z=g(x,y) defined
over certain types of subareas of the (x,y)-space. 
 The first model considers a rectangular area, with
the constraint that the plane segments are defined 
over a grid in the (x,y)-space.  It <B>is the</B>n shown how
this model may be incorporated into an algorithm 
that provides successive approximations to optimal fits
for any type of closed area.  Finally, applications 
are briefly described.

CACM April, 1963

Gluss, B.

CA630424 JB March 14, 1978  11:43 AM

497	4	867
867	4	867
867	4	867
317	5	867
497	5	867
867	5	867
867	5	867
867	5	867


************************



Least Squares Fitting of Planes to Surfaces Using Dynamic Programming

Dynamic programming has recently been used
by Stone, by Bellman and by Gluss to determine the 
closet fit of broken line segments to a curve in an
interval under the constraint that the number of 
segments is fixed.  In the present paper successive
models are developed to extend the method to the 
fitting of broken plane segments to surfaces z=g(x,y) defined
over certain types of subareas of the (x,y)-space. 
 The first model considers a rectangular area, with
the constraint that the plane segments are defined 
over a grid in the (x,y)-space.  It is then shown how
this model may be incorporated into an algorithm 
that provides successive approximations to optimal fits
for any <B>type of</B> closed area.  Finally, applications 
are briefly described.

CACM April, 1963

Gluss, B.

CA630424 JB March 14, 1978  11:43 AM

497	4	867
867	4	867
867	4	867
317	5	867
497	5	867
867	5	867
867	5	867
867	5	867


************************



Least Squares Fitting of Planes to Surfaces Using Dynamic Programming

Dynamic programming has recently been used
by Stone, by Bellman and by Gluss to determine the 
closet fit of broken line segments to a curve in an
interval under the constraint that the number of 
segments is fixed.  In the present paper successive
models are developed to extend the method to the 
fitting of broken plane segments to surfaces z=g(x,y) defined
over certain <B>types of</B> subareas of the (x,y)-space. 
 The first model considers a rectangular area, with
the constraint that the plane segments are defined 
over a grid in the (x,y)-space.  It is then shown how
this model may be incorporated into an algorithm 
that provides successive approximations to optimal fits
for any type of closed area.  Finally, applications 
are briefly described.

CACM April, 1963

Gluss, B.

CA630424 JB March 14, 1978  11:43 AM

497	4	867
867	4	867
867	4	867
317	5	867
497	5	867
867	5	867
867	5	867
867	5	867


************************

************************
Document:  CACM-2888.html
************************


Information Reference Coding

Items in business systems have to be identified
by reference codes, which can later be used 
as data codes and file keys in an associated data processing
system.  In business systems associated 
with large collections of integrated files (database)
it is vital to assign codes in a methodical way 
so as to control future extension and changes while maintaining
correct program action. The principles 
of methodical coding are discussed, <B>and the</B> way in
which logical connections between data items must 
be reflected in the reference code framework is shown
through a set-theoretic information model.

CACM January, 1976

Florentin, J. J.

data, file, reference code, systems
analysis, information modeling, database

3.50

CA760105 JB January 5, 1978  10:11 AM

1135	4	2888
1136	4	2888
2155	4	2888
2406	4	2888
493	4	2888
2710	4	2888
2710	4	2888
2715	4	2888
2716	4	2888
2717	4	2888
2718	4	2888
2765	4	2888
2765	4	2888
2817	4	2888
2888	4	2888
2888	4	2888
2901	4	2888
2906	4	2888
2957	4	2888
2959	4	2888
2965	4	2888
3087	4	2888
3154	4	2888
729	4	2888
2046	5	2888
2888	5	2888
2888	5	2888
2888	5	2888
616	5	2888


************************



Information Reference Coding

Items in business systems have to be identified
by reference codes, which can later be used 
as data codes and file keys <B>in a</B>n associated data processing
system.  In business systems associated 
with large collections of integrated files (database)
it is vital to assign codes in a methodical way 
so as to control future extension and changes while maintaining
correct program action. The principles 
of methodical coding are discussed, and the way in
which logical connections between data items must 
be reflected in the reference code framework is shown
through a set-theoretic information model.

CACM January, 1976

Florentin, J. J.

data, file, reference code, systems
analysis, information modeling, database

3.50

CA760105 JB January 5, 1978  10:11 AM

1135	4	2888
1136	4	2888
2155	4	2888
2406	4	2888
493	4	2888
2710	4	2888
2710	4	2888
2715	4	2888
2716	4	2888
2717	4	2888
2718	4	2888
2765	4	2888
2765	4	2888
2817	4	2888
2888	4	2888
2888	4	2888
2901	4	2888
2906	4	2888
2957	4	2888
2959	4	2888
2965	4	2888
3087	4	2888
3154	4	2888
729	4	2888
2046	5	2888
2888	5	2888
2888	5	2888
2888	5	2888
616	5	2888


************************



Information Reference Coding

Items in business systems have to be identified
by reference codes, which can later be used 
as data codes and file keys in an associated data processing
system.  In business systems associated 
with large collections of integrated files (database)
it is vital to assign codes in a methodical way 
so as to control future extension and changes while maintaining
correct program action. The principles 
of methodical coding are discussed, and the way in
which logical connections <B>between data</B> items must 
be reflected in the reference code framework is shown
through a set-theoretic information model.

CACM January, 1976

Florentin, J. J.

data, file, reference code, systems
analysis, information modeling, database

3.50

CA760105 JB January 5, 1978  10:11 AM

1135	4	2888
1136	4	2888
2155	4	2888
2406	4	2888
493	4	2888
2710	4	2888
2710	4	2888
2715	4	2888
2716	4	2888
2717	4	2888
2718	4	2888
2765	4	2888
2765	4	2888
2817	4	2888
2888	4	2888
2888	4	2888
2901	4	2888
2906	4	2888
2957	4	2888
2959	4	2888
2965	4	2888
3087	4	2888
3154	4	2888
729	4	2888
2046	5	2888
2888	5	2888
2888	5	2888
2888	5	2888
616	5	2888


************************

************************
Document:  CACM-3116.html
************************


Interference Detection Among Solids and Surfaces

In many industrial environments it is necessary to determine whether
r there is interference among components.  There are many potential
interference problems in products made up of assemblies of components 
and in product manufacturing and testing.  Typically, drawings
are used <B>in a</B>n attempt to detect such unwanted interferences,
but the two-dimensional, static drafting medium does not always show
interferences among three-dimensional, moving parts.  This paper
 presents a computer representation for solids and surfaces and algorithms
which carry out interference checking among objects so represented.  
Objects are represented as polyhedra or as piecewise planar
surfaces.  Two types of interference checking are discussed:
detection of intersections among objects in fixed positions and detection
of collisions among objects moving along specified trajectories.

CACM January, 1979

Boyse, J.

Interference checking, intersection detection, collision detection, solid
representation, polyhedral representation, graphics, polygons, surfaces

3.2 8.2

CA790101 DH April 10, 1979  10:50 AM

2827	4	3116
3116	4	3116
2771	5	3116
3116	5	3116
3116	5	3116
3116	5	3116
3172	5	3116
3116	6	3116


************************



Interference Detection Among Solids and Surfaces

In many industrial environments it is necessary to determine whether
r there is interference among components.  There are many potential
interference problems in products made up <B>of a</B>ssemblies of components 
and in product manufacturing and testing.  Typically, drawings
are used in an attempt to detect such unwanted interferences,
but the two-dimensional, static drafting medium does not always show
interferences among three-dimensional, moving parts.  This paper
 presents a computer representation for solids and surfaces and algorithms
which carry out interference checking among objects so represented.  
Objects are represented as polyhedra or as piecewise planar
surfaces.  Two types of interference checking are discussed:
detection of intersections among objects in fixed positions and detection
of collisions among objects moving along specified trajectories.

CACM January, 1979

Boyse, J.

Interference checking, intersection detection, collision detection, solid
representation, polyhedral representation, graphics, polygons, surfaces

3.2 8.2

CA790101 DH April 10, 1979  10:50 AM

2827	4	3116
3116	4	3116
2771	5	3116
3116	5	3116
3116	5	3116
3116	5	3116
3172	5	3116
3116	6	3116


************************



Interference Detection Among Solids and Surfaces

In many industrial environments it is necessary to determine whether
r there is interference among components.  There are many potential
interference problems in products made up of assemblies of components 
and in product manufacturing and testing.  Typically, drawings
are used in an attempt to detect such unwanted interferences,
but the two-dimensional, static drafting medium does not always show
interferences among three-dimensional, moving parts.  This paper
 presents a computer representation for solids and surfaces and algorithms
which carry out interference checking among objects so represented.  
Objects are represented as polyhedra or as piecewise planar
surfaces.  Two <B>types of</B> interference checking are discussed:
detection of intersections among objects in fixed positions and detection
of collisions among objects moving along specified trajectories.

CACM January, 1979

Boyse, J.

Interference checking, intersection detection, collision detection, solid
representation, polyhedral representation, graphics, polygons, surfaces

3.2 8.2

CA790101 DH April 10, 1979  10:50 AM

2827	4	3116
3116	4	3116
2771	5	3116
3116	5	3116
3116	5	3116
3116	5	3116
3172	5	3116
3116	6	3116


************************

************************
Document:  CACM-2631.html
************************


An Information-Theoretic Approach to
Text Searching in Direct Access Systems

Using direct access computer files of bibliographic
information, an attempt is made to overcome 
one of the problems often associated with information
retrieval, namely, the maintenance and use of large 
dictionaries, the greater part of which is used only
infrequently.  A novel method is presented, which 
maps the hyperbolic frequency distribution.  This is
more suited to implementation on storage devices. 
 This method treats text as a string of characters rather
than words bounded by spaces, and chooses subsets 
of strings such that their frequencies of occurrence are
more even than those of word types.  The members 
of this subset are then used as index keys for retrieval.
The rectangular distribution of key frequencies 
results <B>in a</B> much simplified file organization
and promises considerable cost advantages.

CACM June, 1974

Barton, I. J.
Creasey, S. E.
Lynch, M. F.
Snell, M. J.

text searching, information theory, file organization,
direct access, information retrieval, character 
string, bit vector

3.42 3.70 3.73 3.74 5.6

CA740615 JB January 17, 1978  2:07 PM

2532	4	2631
2631	4	2631
2631	4	2631
2746	4	2631
3001	4	2631
2139	5	2631
2532	5	2631
2631	5	2631
2631	5	2631
2631	5	2631


************************



An Information-Theoretic Approach to
Text Searching in Direct Access Systems

Using direct access computer files of bibliographic
information, an attempt is made to overcome 
one of the problems often associated with information
retrieval, namely, the maintenance and use of large 
dictionaries, the greater part of which is used only
infrequently.  A novel method is presented, which 
maps the hyperbolic frequency distribution.  This is
more suited to implementation on storage devices. 
 This method treats text as a string of characters rather
than words bounded by spaces, and chooses subsets 
of strings such <B>that the</B>ir frequencies of occurrence are
more even than those of word types.  The members 
of this subset are then used as index keys for retrieval.
The rectangular distribution of key frequencies 
results in a much simplified file organization
and promises considerable cost advantages.

CACM June, 1974

Barton, I. J.
Creasey, S. E.
Lynch, M. F.
Snell, M. J.

text searching, information theory, file organization,
direct access, information retrieval, character 
string, bit vector

3.42 3.70 3.73 3.74 5.6

CA740615 JB January 17, 1978  2:07 PM

2532	4	2631
2631	4	2631
2631	4	2631
2746	4	2631
3001	4	2631
2139	5	2631
2532	5	2631
2631	5	2631
2631	5	2631
2631	5	2631


************************



An Information-Theoretic Approach to
Text Searching in Direct Access Systems

Using direct access computer files of bibliographic
information, an attempt is made to overcome 
one <B>of the</B> problems often associated with information
retrieval, namely, the maintenance and use of large 
dictionaries, the greater part of which is used only
infrequently.  A novel method is presented, which 
maps the hyperbolic frequency distribution.  This is
more suited to implementation on storage devices. 
 This method treats text as a string of characters rather
than words bounded by spaces, and chooses subsets 
of strings such that their frequencies of occurrence are
more even than those of word types.  The members 
of this subset are then used as index keys for retrieval.
The rectangular distribution of key frequencies 
results in a much simplified file organization
and promises considerable cost advantages.

CACM June, 1974

Barton, I. J.
Creasey, S. E.
Lynch, M. F.
Snell, M. J.

text searching, information theory, file organization,
direct access, information retrieval, character 
string, bit vector

3.42 3.70 3.73 3.74 5.6

CA740615 JB January 17, 1978  2:07 PM

2532	4	2631
2631	4	2631
2631	4	2631
2746	4	2631
3001	4	2631
2139	5	2631
2532	5	2631
2631	5	2631
2631	5	2631
2631	5	2631


************************

************************
Document:  CACM-1908.html
************************


Time-Sharing and Batch-Processing:  An Experimental
Comparison of Their Values in a Problem - 
Solving Situation

An experimental comparison of problem-solving
using time-sharing and batch-processing computer 
systems conducted at MIT is described in this paper.
 This study <B>is the</B> first known attempt to evaluate 
two such systems for what may well be the predominant user
population within the next decade-the professionals 
who, as nonprogrammers, are using the computer as an
aid in decision-making and problem-solving rather 
than as a programming end in itself.  Statistically
and logically significant results indicate equal 
cost for usage of the two computer systems; however,
a much higher level of performance is attained by 
time-sharing users.  There are indications that significantly
lower costs would have resulted if the 
time-sharing users had stopped work when they reached
a performance level equal to that of the batch 
users.  The users' speed of problem-solving and their
attitudes made time-sharing the more favorable 
system.

CACM May, 1969

Gold, M. M.

time-sharing vs batch-processing, user performance,
man/machine communications, cost effectiveness, 
on-line vs off-line performance, decision-making performance,
user/programmer behavior, programming experimental 
empirical studies, problem-solving, research in man/machine
communications, man/machine symbiosis

2.11 2.40 3.36 3.51 3.80

CA690501 JB February 17, 1978  4:10 PM

1792	4	1908
1908	4	1908
1908	4	1908
1550	5	1908
1605	5	1908
1908	5	1908
1908	5	1908
1908	5	1908
2705	5	1908
2984	5	1908
1908	6	1908
1908	6	1908
3185	6	1908


************************



Time-Sharing and Batch-Processing:  An Experimental
Comparison of Their Values <B>in a</B> Problem - 
Solving Situation

An experimental comparison of problem-solving
using time-sharing and batch-processing computer 
systems conducted at MIT is described in this paper.
 This study is the first known attempt to evaluate 
two such systems for what may well be the predominant user
population within the next decade-the professionals 
who, as nonprogrammers, are using the computer as an
aid in decision-making and problem-solving rather 
than as a programming end in itself.  Statistically
and logically significant results indicate equal 
cost for usage of the two computer systems; however,
a much higher level of performance is attained by 
time-sharing users.  There are indications that significantly
lower costs would have resulted if the 
time-sharing users had stopped work when they reached
a performance level equal to that of the batch 
users.  The users' speed of problem-solving and their
attitudes made time-sharing the more favorable 
system.

CACM May, 1969

Gold, M. M.

time-sharing vs batch-processing, user performance,
man/machine communications, cost effectiveness, 
on-line vs off-line performance, decision-making performance,
user/programmer behavior, programming experimental 
empirical studies, problem-solving, research in man/machine
communications, man/machine symbiosis

2.11 2.40 3.36 3.51 3.80

CA690501 JB February 17, 1978  4:10 PM

1792	4	1908
1908	4	1908
1908	4	1908
1550	5	1908
1605	5	1908
1908	5	1908
1908	5	1908
1908	5	1908
2705	5	1908
2984	5	1908
1908	6	1908
1908	6	1908
3185	6	1908


************************



Time-Sharing and Batch-Processing:  An Experimental
Comparison of Their Values in a Problem - 
Solving Situation

An experimental comparison of problem-solving
using time-sharing and batch-processing computer 
systems conducted at MIT is described in this paper.
 This study is the first known attempt to evaluate 
two such systems for what may well be the predominant user
population within the next decade-the professionals 
who, as nonprogrammers, are using the computer as an
aid in decision-making and problem-solving rather 
than as a programming end in itself.  Statistically
and logically significant results indicate equal 
cost for usage of the two computer systems; however,
a much higher level of performance <B>is a</B>ttained by 
time-sharing users.  There are indications that significantly
lower costs would have resulted if the 
time-sharing users had stopped work when they reached
a performance level equal to that of the batch 
users.  The users' speed of problem-solving and their
attitudes made time-sharing the more favorable 
system.

CACM May, 1969

Gold, M. M.

time-sharing vs batch-processing, user performance,
man/machine communications, cost effectiveness, 
on-line vs off-line performance, decision-making performance,
user/programmer behavior, programming experimental 
empirical studies, problem-solving, research in man/machine
communications, man/machine symbiosis

2.11 2.40 3.36 3.51 3.80

CA690501 JB February 17, 1978  4:10 PM

1792	4	1908
1908	4	1908
1908	4	1908
1550	5	1908
1605	5	1908
1908	5	1908
1908	5	1908
1908	5	1908
2705	5	1908
2984	5	1908
1908	6	1908
1908	6	1908
3185	6	1908


************************



Time-Sharing and Batch-Processing:  An Experimental
Comparison of Their Values in a Problem - 
Solving Situation

An experimental comparison of problem-solving
using time-sharing and batch-processing computer 
systems conducted at MIT is described in this paper.
 This study is the first known attempt to evaluate 
two such systems for what may well be the predominant user
population within the next decade-the professionals 
who, as nonprogrammers, are using the computer as an
aid in decision-making and problem-solving rather 
than as a programming end in itself.  Statistically
and logically significant results indicate equal 
cost for usage <B>of the</B> two computer systems; however,
a much higher level of performance is attained by 
time-sharing users.  There are indications that significantly
lower costs would have resulted if the 
time-sharing users had stopped work when they reached
a performance level equal to that of the batch 
users.  The users' speed of problem-solving and their
attitudes made time-sharing the more favorable 
system.

CACM May, 1969

Gold, M. M.

time-sharing vs batch-processing, user performance,
man/machine communications, cost effectiveness, 
on-line vs off-line performance, decision-making performance,
user/programmer behavior, programming experimental 
empirical studies, problem-solving, research in man/machine
communications, man/machine symbiosis

2.11 2.40 3.36 3.51 3.80

CA690501 JB February 17, 1978  4:10 PM

1792	4	1908
1908	4	1908
1908	4	1908
1550	5	1908
1605	5	1908
1908	5	1908
1908	5	1908
1908	5	1908
2705	5	1908
2984	5	1908
1908	6	1908
1908	6	1908
3185	6	1908


************************



Time-Sharing and Batch-Processing:  An Experimental
Comparison of Their Values in a Problem - 
Solving Situation

An experimental comparison of problem-solving
using time-sharing and batch-processing computer 
systems conducted at MIT is described in this paper.
 This study is the first known attempt to evaluate 
two such systems for what may well be the predominant user
population within the next decade-the professionals 
who, as nonprogrammers, are using the computer as an
aid in decision-making and problem-solving rather 
than as a programming end in itself.  Statistically
and logically significant results indicate equal 
cost for usage of the two computer systems; however,
a much higher level of performance is attained by 
time-sharing users.  There are indications that significantly
lower costs would have resulted if the 
time-sharing users had stopped work when they reached
a performance level equal to that of the batch 
users.  The users' speed of problem-solving <B>and the</B>ir
attitudes made time-sharing the more favorable 
system.

CACM May, 1969

Gold, M. M.

time-sharing vs batch-processing, user performance,
man/machine communications, cost effectiveness, 
on-line vs off-line performance, decision-making performance,
user/programmer behavior, programming experimental 
empirical studies, problem-solving, research in man/machine
communications, man/machine symbiosis

2.11 2.40 3.36 3.51 3.80

CA690501 JB February 17, 1978  4:10 PM

1792	4	1908
1908	4	1908
1908	4	1908
1550	5	1908
1605	5	1908
1908	5	1908
1908	5	1908
1908	5	1908
2705	5	1908
2984	5	1908
1908	6	1908
1908	6	1908
3185	6	1908


************************

************************
Document:  CACM-2376.html
************************


Synchronization of Communicating Processes

Formalization of a well-defined synchronization
mechanism can be used to prove that concurrently 
running processes of a system communicate correctly.
 This is demonstrated for a system consisting of 
many sending processes which deposit messages in a buffer
and many receiving processes which remove messages 
from that buffer.  The formal description <B>of the</B> synchronization
mechanism makes it very easy to prove 
that the buffer will neither overflow nor underflow,
that senders and receivers will never operate on 
the same message frame in the buffer nor will they run into a deadlock. 

CACM March, 1972

Habermann, A. N.

parallel programming, multiprogramming, program correctness,
process communication, process scheduling

4.30 4.32 4.39 4.9

CA720305 JB January 31, 1978  2:44 PM

1781	4	2376
1828	4	2376
1854	4	2376
1877	4	2376
1960	4	2376
2150	4	2376
2150	4	2376
2228	4	2376
2256	4	2376
2317	4	2376
2317	4	2376
2319	4	2376
2377	4	2376
2342	4	2376
2342	4	2376
2376	4	2376
2376	4	2376
2376	4	2376
2379	4	2376
2424	4	2376
2482	4	2376
2618	4	2376
2618	4	2376
2632	4	2376
2704	4	2376
2723	4	2376
2738	4	2376
2740	4	2376
2741	4	2376
2867	4	2376
3184	4	2376
3184	4	2376
1198	5	2376
1749	5	2376
1960	5	2376
2376	5	2376
2376	5	2376
2376	5	2376
2700	5	2376
3128	5	2376
2150	6	2376
2376	6	2376
2376	6	2376
2436	6	2376
2597	6	2376
2865	6	2376
2866	6	2376
2870	6	2376
2912	6	2376
3082	6	2376


************************



Synchronization of Communicating Processes

Formalization of a well-defined synchronization
mechanism can be used to prove that concurrently 
running processes of a system communicate correctly.
 This is demonstrated for a system consisting of 
many sending processes which deposit messages <B>in a</B> buffer
and many receiving processes which remove messages 
from that buffer.  The formal description of the synchronization
mechanism makes it very easy to prove 
that the buffer will neither overflow nor underflow,
that senders and receivers will never operate on 
the same message frame in the buffer nor will they run into a deadlock. 

CACM March, 1972

Habermann, A. N.

parallel programming, multiprogramming, program correctness,
process communication, process scheduling

4.30 4.32 4.39 4.9

CA720305 JB January 31, 1978  2:44 PM

1781	4	2376
1828	4	2376
1854	4	2376
1877	4	2376
1960	4	2376
2150	4	2376
2150	4	2376
2228	4	2376
2256	4	2376
2317	4	2376
2317	4	2376
2319	4	2376
2377	4	2376
2342	4	2376
2342	4	2376
2376	4	2376
2376	4	2376
2376	4	2376
2379	4	2376
2424	4	2376
2482	4	2376
2618	4	2376
2618	4	2376
2632	4	2376
2704	4	2376
2723	4	2376
2738	4	2376
2740	4	2376
2741	4	2376
2867	4	2376
3184	4	2376
3184	4	2376
1198	5	2376
1749	5	2376
1960	5	2376
2376	5	2376
2376	5	2376
2376	5	2376
2700	5	2376
3128	5	2376
2150	6	2376
2376	6	2376
2376	6	2376
2436	6	2376
2597	6	2376
2865	6	2376
2866	6	2376
2870	6	2376
2912	6	2376
3082	6	2376


************************



Synchronization of Communicating Processes

Formalization of a well-defined synchronization
mechanism can be used to prove that concurrently 
running processes of a system communicate correctly.
 This is demonstrated for a system consisting of 
many sending processes which deposit messages in a buffer
and many receiving processes which remove messages 
from that buffer.  The formal description of the synchronization
mechanism makes it very easy to prove 
<B>that the</B> buffer will neither overflow nor underflow,
that senders and receivers will never operate on 
the same message frame in the buffer nor will they run into a deadlock. 

CACM March, 1972

Habermann, A. N.

parallel programming, multiprogramming, program correctness,
process communication, process scheduling

4.30 4.32 4.39 4.9

CA720305 JB January 31, 1978  2:44 PM

1781	4	2376
1828	4	2376
1854	4	2376
1877	4	2376
1960	4	2376
2150	4	2376
2150	4	2376
2228	4	2376
2256	4	2376
2317	4	2376
2317	4	2376
2319	4	2376
2377	4	2376
2342	4	2376
2342	4	2376
2376	4	2376
2376	4	2376
2376	4	2376
2379	4	2376
2424	4	2376
2482	4	2376
2618	4	2376
2618	4	2376
2632	4	2376
2704	4	2376
2723	4	2376
2738	4	2376
2740	4	2376
2741	4	2376
2867	4	2376
3184	4	2376
3184	4	2376
1198	5	2376
1749	5	2376
1960	5	2376
2376	5	2376
2376	5	2376
2376	5	2376
2700	5	2376
3128	5	2376
2150	6	2376
2376	6	2376
2376	6	2376
2436	6	2376
2597	6	2376
2865	6	2376
2866	6	2376
2870	6	2376
2912	6	2376
3082	6	2376


************************



Synchronization of Communicating Processes

Formalization <B>of a</B> well-defined synchronization
mechanism can be used to prove that concurrently 
running processes of a system communicate correctly.
 This is demonstrated for a system consisting of 
many sending processes which deposit messages in a buffer
and many receiving processes which remove messages 
from that buffer.  The formal description of the synchronization
mechanism makes it very easy to prove 
that the buffer will neither overflow nor underflow,
that senders and receivers will never operate on 
the same message frame in the buffer nor will they run into a deadlock. 

CACM March, 1972

Habermann, A. N.

parallel programming, multiprogramming, program correctness,
process communication, process scheduling

4.30 4.32 4.39 4.9

CA720305 JB January 31, 1978  2:44 PM

1781	4	2376
1828	4	2376
1854	4	2376
1877	4	2376
1960	4	2376
2150	4	2376
2150	4	2376
2228	4	2376
2256	4	2376
2317	4	2376
2317	4	2376
2319	4	2376
2377	4	2376
2342	4	2376
2342	4	2376
2376	4	2376
2376	4	2376
2376	4	2376
2379	4	2376
2424	4	2376
2482	4	2376
2618	4	2376
2618	4	2376
2632	4	2376
2704	4	2376
2723	4	2376
2738	4	2376
2740	4	2376
2741	4	2376
2867	4	2376
3184	4	2376
3184	4	2376
1198	5	2376
1749	5	2376
1960	5	2376
2376	5	2376
2376	5	2376
2376	5	2376
2700	5	2376
3128	5	2376
2150	6	2376
2376	6	2376
2376	6	2376
2436	6	2376
2597	6	2376
2865	6	2376
2866	6	2376
2870	6	2376
2912	6	2376
3082	6	2376


************************

************************
Document:  CACM-2229.html
************************


Construction of Rational and Negative Powers of a Formal Series

Some methods are described for the generation
of fractional and negative powers of any formal 
series, such as Poisson series or Chebyshev series.  It
is shown that, with the use of the three elementary 
operations of addition, subtraction, and multiplication,
all rational (positive and negative) powers 
of a series can be constructed.  There are basically two
approaches: the binomial theorem and the iteration 
methods.  Both methods are described here, and <B>the relationship</B>
between them is pointed out.  Some well-known 
classical formulas are obtained as particular cases,
and it is shown how the convergence properties of 
these formulas can be improved with very little additional
computations.  Finally, at the end of the 
article, some numerical experiments are described
with Chebyshev series and with Fourier series.

CACM January, 1971

Brucke, R. A.

series expansion, series inversion, root extraction,
binomial theorem, Newton iterations, Chebyshev 
series, Poisson series, Fourier series

3.11 3.15 3.21 5.0

CA710105 JB February 8, 1978  10:57 AM

1396	4	2229
2229	4	2229
1365	5	2229
2229	5	2229
2229	5	2229
2229	5	2229


************************



Construction of Rational and Negative Powers of a Formal Series

Some methods are described for the generation
of fractional and negative powers of any formal 
series, such as Poisson series or Chebyshev series.  It
is shown that, with the use <B>of the</B> three elementary 
operations of addition, subtraction, and multiplication,
all rational (positive and negative) powers 
of a series can be constructed.  There are basically two
approaches: the binomial theorem and the iteration 
methods.  Both methods are described here, and the relationship
between them is pointed out.  Some well-known 
classical formulas are obtained as particular cases,
and it is shown how the convergence properties of 
these formulas can be improved with very little additional
computations.  Finally, at the end of the 
article, some numerical experiments are described
with Chebyshev series and with Fourier series.

CACM January, 1971

Brucke, R. A.

series expansion, series inversion, root extraction,
binomial theorem, Newton iterations, Chebyshev 
series, Poisson series, Fourier series

3.11 3.15 3.21 5.0

CA710105 JB February 8, 1978  10:57 AM

1396	4	2229
2229	4	2229
1365	5	2229
2229	5	2229
2229	5	2229
2229	5	2229


************************



Construction of Rational and Negative Powers of a Formal Series

Some methods are described for the generation
of fractional and negative powers of any formal 
series, such as Poisson series or Chebyshev series.  It
is shown that, with the use of the three elementary 
operations of addition, subtraction, and multiplication,
all rational (positive and negative) powers 
of a series can be constructed.  There are basically two
approaches: the binomial theorem <B>and the</B> iteration 
methods.  Both methods are described here, and the relationship
between them is pointed out.  Some well-known 
classical formulas are obtained as particular cases,
and it is shown how the convergence properties of 
these formulas can be improved with very little additional
computations.  Finally, at the end of the 
article, some numerical experiments are described
with Chebyshev series and with Fourier series.

CACM January, 1971

Brucke, R. A.

series expansion, series inversion, root extraction,
binomial theorem, Newton iterations, Chebyshev 
series, Poisson series, Fourier series

3.11 3.15 3.21 5.0

CA710105 JB February 8, 1978  10:57 AM

1396	4	2229
2229	4	2229
1365	5	2229
2229	5	2229
2229	5	2229
2229	5	2229


************************



Construction of Rational and Negative Powers <B>of a</B> Formal Series

Some methods are described for the generation
of fractional and negative powers of any formal 
series, such as Poisson series or Chebyshev series.  It
is shown that, with the use of the three elementary 
operations of addition, subtraction, and multiplication,
all rational (positive and negative) powers 
of a series can be constructed.  There are basically two
approaches: the binomial theorem and the iteration 
methods.  Both methods are described here, and the relationship
between them is pointed out.  Some well-known 
classical formulas are obtained as particular cases,
and it is shown how the convergence properties of 
these formulas can be improved with very little additional
computations.  Finally, at the end of the 
article, some numerical experiments are described
with Chebyshev series and with Fourier series.

CACM January, 1971

Brucke, R. A.

series expansion, series inversion, root extraction,
binomial theorem, Newton iterations, Chebyshev 
series, Poisson series, Fourier series

3.11 3.15 3.21 5.0

CA710105 JB February 8, 1978  10:57 AM

1396	4	2229
2229	4	2229
1365	5	2229
2229	5	2229
2229	5	2229
2229	5	2229


************************

************************
Document:  CACM-1488.html
************************


Programming Decision Tables in FORTRAN, COBOL or ALGOL

A simple broad-based approach for programming
decision tables in FORTRAN or COBOL is developed 
and presented.  With inputs in standard form, as defined
in the paper, the programming of any decision 
table can be done with one or two FORTRAN statements,
or with two COBOL statements, if the COMPUTE verb 
is available in the COBOL processor.  It is  shown
<B>that the</B> method is applicable even when there are 
more than two mutually exclusive states of one, two or
more table conditions.  It is further shown that 
multi-state conditions in decision tables can often
simplify the programming.  The method outlined has 
the further advantage that all possible combinations
of conditions are considered.  It is shown that 
the suggested procedure is easily implemented in ALGOL.

CACM January, 1966

Veinott, C. G.

CA660107 JB March 3, 1978  4:08 PM

1354	4	1488
1354	4	1488
1488	4	1488
1488	4	1488
1994	4	1488
2053	4	1488
2053	4	1488
2220	4	1488
2220	4	1488
2273	4	1488
2273	4	1488
2726	4	1488
2856	4	1488
1237	5	1488
1327	5	1488
1488	5	1488
1488	5	1488
1488	5	1488
1548	5	1488
2726	5	1488
1172	6	1488
1327	6	1488
1354	6	1488
1488	6	1488
1488	6	1488
1489	6	1488
1489	6	1488
1548	6	1488
2220	6	1488
2221	6	1488
2263	6	1488


************************



Programming Decision Tables in FORTRAN, COBOL or ALGOL

A simple broad-based approach for programming
decision tables in FORTRAN or COBOL is developed 
and presented.  With inputs in standard form, as defined
in the paper, the programming of any decision 
table can be done with one or two FORTRAN statements,
or with two COBOL statements, if the COMPUTE verb 
<B>is a</B>vailable in the COBOL processor.  It is  shown
that the method is applicable even when there are 
more than two mutually exclusive states of one, two or
more table conditions.  It is further shown that 
multi-state conditions in decision tables can often
simplify the programming.  The method outlined has 
the further advantage that all possible combinations
of conditions are considered.  It is shown that 
the suggested procedure is easily implemented in ALGOL.

CACM January, 1966

Veinott, C. G.

CA660107 JB March 3, 1978  4:08 PM

1354	4	1488
1354	4	1488
1488	4	1488
1488	4	1488
1994	4	1488
2053	4	1488
2053	4	1488
2220	4	1488
2220	4	1488
2273	4	1488
2273	4	1488
2726	4	1488
2856	4	1488
1237	5	1488
1327	5	1488
1488	5	1488
1488	5	1488
1488	5	1488
1548	5	1488
2726	5	1488
1172	6	1488
1327	6	1488
1354	6	1488
1488	6	1488
1488	6	1488
1489	6	1488
1489	6	1488
1548	6	1488
2220	6	1488
2221	6	1488
2263	6	1488


************************



Programming Decision Tables in FORTRAN, COBOL or ALGOL

A simple broad-based approach for programming
decision tables in FORTRAN or COBOL is developed 
and presented.  With inputs in standard form, as defined
in the paper, the programming <B>of a</B>ny decision 
table can be done with one or two FORTRAN statements,
or with two COBOL statements, if the COMPUTE verb 
is available in the COBOL processor.  It is  shown
that the method is applicable even when there are 
more than two mutually exclusive states of one, two or
more table conditions.  It is further shown that 
multi-state conditions in decision tables can often
simplify the programming.  The method outlined has 
the further advantage that all possible combinations
of conditions are considered.  It is shown that 
the suggested procedure is easily implemented in ALGOL.

CACM January, 1966

Veinott, C. G.

CA660107 JB March 3, 1978  4:08 PM

1354	4	1488
1354	4	1488
1488	4	1488
1488	4	1488
1994	4	1488
2053	4	1488
2053	4	1488
2220	4	1488
2220	4	1488
2273	4	1488
2273	4	1488
2726	4	1488
2856	4	1488
1237	5	1488
1327	5	1488
1488	5	1488
1488	5	1488
1488	5	1488
1548	5	1488
2726	5	1488
1172	6	1488
1327	6	1488
1354	6	1488
1488	6	1488
1488	6	1488
1489	6	1488
1489	6	1488
1548	6	1488
2220	6	1488
2221	6	1488
2263	6	1488


************************

************************
Document:  CACM-1162.html
************************


An Assembly Language for Reprogramming

Complete reprogramming of compiler language programs
is seldom necessary.  It is assembly language 
programs which present the greatest difficulty.  Assembly
languages generally provide a one-for-one translation 
from a symbolic to a numeric version of a program, that
is, from assembly language to machine language. 
 The meta-language presented here can be used to specify
the mapping of any language which conforms to 
a canonical list form into an arbitrary stream of bits.
 This <B>bit stream</B> may be treated as a machine 
language program, a character stream, or whatever else
the user might desire.  Thus, this meta-language 
can be used to map from one assembly language into another
or from the assembly language for one machine 
into the machine language of another.

CACM December, 1965

Graham, M. L.
Ingerman, P. Z.

CA651207 JB March 6, 1978  4:01 PM

1162	5	1162
1162	5	1162
1162	5	1162
1565	5	1162
1162	6	1162
1358	6	1162
1455	6	1162
205	6	1162


************************



An Assembly Language for Reprogramming

Complete reprogramming of compiler language programs
is seldom necessary.  It is assembly language 
programs which present the greatest difficulty.  Assembly
languages generally provide a one-for-one translation 
from a symbolic to a numeric version <B>of a</B> program, that
is, from assembly language to machine language. 
 The meta-language presented here can be used to specify
the mapping of any language which conforms to 
a canonical list form into an arbitrary stream of bits.
 This bit stream may be treated as a machine 
language program, a character stream, or whatever else
the user might desire.  Thus, this meta-language 
can be used to map from one assembly language into another
or from the assembly language for one machine 
into the machine language of another.

CACM December, 1965

Graham, M. L.
Ingerman, P. Z.

CA651207 JB March 6, 1978  4:01 PM

1162	5	1162
1162	5	1162
1162	5	1162
1565	5	1162
1162	6	1162
1358	6	1162
1455	6	1162
205	6	1162


************************



An Assembly Language for Reprogramming

Complete reprogramming of compiler language programs
is seldom necessary.  It <B>is a</B>ssembly language 
programs which present the greatest difficulty.  Assembly
languages generally provide a one-for-one translation 
from a symbolic to a numeric version of a program, that
is, from assembly language to machine language. 
 The meta-language presented here can be used to specify
the mapping of any language which conforms to 
a canonical list form into an arbitrary stream of bits.
 This bit stream may be treated as a machine 
language program, a character stream, or whatever else
the user might desire.  Thus, this meta-language 
can be used to map from one assembly language into another
or from the assembly language for one machine 
into the machine language of another.

CACM December, 1965

Graham, M. L.
Ingerman, P. Z.

CA651207 JB March 6, 1978  4:01 PM

1162	5	1162
1162	5	1162
1162	5	1162
1565	5	1162
1162	6	1162
1358	6	1162
1455	6	1162
205	6	1162


************************

************************
Document:  CACM-0695.html
************************


Use of the Disk File on Stretch

The paper begins by briefly describing the
Stretch (IBM 7030) computer with special emphasis 
given to the organization and operation of its input-output
equipment.  Physical characteristics of the 
two-disk system (4,194,304 72-bit words, 8 usec-per-word
transmission rate, etc.) are noted.  Timing 
limitations due to arm motion and disk rotation are discussed.
 Applications of disk usage are discussed 
separately for problem programs and for systems programs
such as compilers <B>and the</B> supervisory program. 
Approximately 260,000 words of disk storage are reserved
for the storage of systems programs and the 
subroutine library.  Problem programs, however, are not
currently filed on the disk.  Certain programming 
techniques are discussed for transmitting words between
disk and core storage with minimum delaying and 
interruption of the arithmetic unit.  Dumps on disk are
considered for both recovery from computer malfunction 
and for mathematical or physical developments during
the calculation.  Some comments are made regarding 
the reliability, economics, utility and weaknesses or
limitations of the disk system.  Several possible 
future applications are noted which appear to have disk connotations.

CACM October, 1963

Carlson, B. G.
Voorhes, E. A.

CA631030 JB March 13, 1978  4:28 PM

695	5	695
695	5	695
695	5	695


************************



Use of the Disk File on Stretch

The paper begins by briefly <B>describing the</B>
Stretch (IBM 7030) computer with special emphasis 
given to the organization and operation of its input-output
equipment.  Physical characteristics of the 
two-disk system (4,194,304 72-bit words, 8 usec-per-word
transmission rate, etc.) are noted.  Timing 
limitations due to arm motion and disk rotation are discussed.
 Applications of disk usage are discussed 
separately for problem programs and for systems programs
such as compilers and the supervisory program. 
Approximately 260,000 words of disk storage are reserved
for the storage of systems programs and the 
subroutine library.  Problem programs, however, are not
currently filed on the disk.  Certain programming 
techniques are discussed for transmitting words between
disk and core storage with minimum delaying and 
interruption of the arithmetic unit.  Dumps on disk are
considered for both recovery from computer malfunction 
and for mathematical or physical developments during
the calculation.  Some comments are made regarding 
the reliability, economics, utility and weaknesses or
limitations of the disk system.  Several possible 
future applications are noted which appear to have disk connotations.

CACM October, 1963

Carlson, B. G.
Voorhes, E. A.

CA631030 JB March 13, 1978  4:28 PM

695	5	695
695	5	695
695	5	695


************************



Use <B>of the</B> Disk File on Stretch

The paper begins by briefly describing the
Stretch (IBM 7030) computer with special emphasis 
given to the organization and operation of its input-output
equipment.  Physical characteristics of the 
two-disk system (4,194,304 72-bit words, 8 usec-per-word
transmission rate, etc.) are noted.  Timing 
limitations due to arm motion and disk rotation are discussed.
 Applications of disk usage are discussed 
separately for problem programs and for systems programs
such as compilers and the supervisory program. 
Approximately 260,000 words of disk storage are reserved
for the storage of systems programs and the 
subroutine library.  Problem programs, however, are not
currently filed on the disk.  Certain programming 
techniques are discussed for transmitting words between
disk and core storage with minimum delaying and 
interruption of the arithmetic unit.  Dumps on disk are
considered for both recovery from computer malfunction 
and for mathematical or physical developments during
the calculation.  Some comments are made regarding 
the reliability, economics, utility and weaknesses or
limitations of the disk system.  Several possible 
future applications are noted which appear to have disk connotations.

CACM October, 1963

Carlson, B. G.
Voorhes, E. A.

CA631030 JB March 13, 1978  4:28 PM

695	5	695
695	5	695
695	5	695


************************

************************
Document:  CACM-0040.html
************************


Fingers or Fists? (The Choice of Decimal or Binary Representation)

The binary number system offers many advantages
over a decimal representation for a high-performance, 
general-purpose computer.  The greater simplicity of
a binary arithmetic unit <B>and the</B> greater compactness 
of binary numbers both contribute directly to arithmetic
speed.  Less obvious and perhaps more important 
is the way binary addressing and instruction formats can
increase the overall performance.  Binary addresses 
are also essential to certain powerful operations which
are not practical with decimal instruction formats. 
 On the other hand, decimal numbers are essential for
communicating between man and the computer.  In 
applications requiring the processing of a large volume
of inherently decimal input and output data, 
the time for decimal-binary conversion needed by a purely
binary computer may be significant.  A slower 
decimal adder may take less time than a fast binary adder
doing an addition and two conversions.  A careful 
review of the significance of decimal and binary addressing
and both binary and decimal data arithmetic, 
supplemented by efficient conversion instructions.

CACM December, 1959

Buchholz, W.

CA591202 JB March 22, 1978  3:47 PM

40	5	40
40	5	40
40	5	40


************************



Fingers or Fists? (The Choice of Decimal or Binary Representation)

The binary number system offers many advantages
over a decimal representation for a high-performance, 
general-purpose computer.  The greater simplicity of
a binary arithmetic unit and the greater compactness 
of binary numbers both contribute directly to arithmetic
speed.  Less obvious and perhaps more important 
<B>is the</B> way binary addressing and instruction formats can
increase the overall performance.  Binary addresses 
are also essential to certain powerful operations which
are not practical with decimal instruction formats. 
 On the other hand, decimal numbers are essential for
communicating between man and the computer.  In 
applications requiring the processing of a large volume
of inherently decimal input and output data, 
the time for decimal-binary conversion needed by a purely
binary computer may be significant.  A slower 
decimal adder may take less time than a fast binary adder
doing an addition and two conversions.  A careful 
review of the significance of decimal and binary addressing
and both binary and decimal data arithmetic, 
supplemented by efficient conversion instructions.

CACM December, 1959

Buchholz, W.

CA591202 JB March 22, 1978  3:47 PM

40	5	40
40	5	40
40	5	40


************************



Fingers or Fists? (The Choice of Decimal or Binary Representation)

The binary number system offers many advantages
over a decimal representation for a high-performance, 
general-purpose computer.  The greater simplicity of
a binary arithmetic unit and the greater compactness 
of binary numbers both contribute directly to arithmetic
speed.  Less obvious and perhaps more important 
is the way binary addressing and instruction formats can
increase the overall performance.  Binary addresses 
are also essential to certain powerful operations which
are not practical with decimal instruction formats. 
 On the other hand, decimal numbers are essential for
communicating between man and the computer.  In 
applications requiring the processing <B>of a</B> large volume
of inherently decimal input and output data, 
the time for decimal-binary conversion needed by a purely
binary computer may be significant.  A slower 
decimal adder may take less time than a fast binary adder
doing an addition and two conversions.  A careful 
review of the significance of decimal and binary addressing
and both binary and decimal data arithmetic, 
supplemented by efficient conversion instructions.

CACM December, 1959

Buchholz, W.

CA591202 JB March 22, 1978  3:47 PM

40	5	40
40	5	40
40	5	40


************************



Fingers or Fists? (The Choice of Decimal or Binary Representation)

The binary number system offers many advantages
over a decimal representation for a high-performance, 
general-purpose computer.  The greater simplicity of
a binary arithmetic unit and the greater compactness 
of binary numbers both contribute directly to arithmetic
speed.  Less obvious and perhaps more important 
is the way binary addressing and instruction formats can
increase the overall performance.  Binary addresses 
are also essential to certain powerful operations which
are not practical with decimal instruction formats. 
 On the other hand, decimal numbers are essential for
communicating between man and the computer.  In 
applications requiring the processing of a large volume
of inherently decimal input and output data, 
the time for decimal-binary conversion needed by a purely
binary computer may be significant.  A slower 
decimal adder may take less time than a fast binary adder
doing an addition and two conversions.  A careful 
review <B>of the</B> significance of decimal and binary addressing
and both binary and decimal data arithmetic, 
supplemented by efficient conversion instructions.

CACM December, 1959

Buchholz, W.

CA591202 JB March 22, 1978  3:47 PM

40	5	40
40	5	40
40	5	40


************************

************************
Document:  CACM-2371.html
************************


A System for Interprocess Communication
<B>in a</B> Resource Sharing Computer Network

A system of communication between processes in a
time-sharing system is described and the communication 
system is extended so that it may be used between processes
distributed throughout a computer network. 
 The hypothetical application of the system to an existing network is discussed.

CACM April, 1972

Walden, D. C.

interprocess communication, time-sharing,
computer networks, resource sharing

3.81 4.39 4.82 4.9

CA720402 JB January 31, 1978  1:51 PM

2371	5	2371
2371	5	2371
2371	5	2371
2849	5	2371
2371	6	2371


************************



A System for Interprocess Communication
in a Resource Sharing Computer Network

A system of communication between processes in a
time-sharing <B>system is</B> described and the communication 
system is extended so that it may be used between processes
distributed throughout a computer network. 
 The hypothetical application of the system to an existing network is discussed.

CACM April, 1972

Walden, D. C.

interprocess communication, time-sharing,
computer networks, resource sharing

3.81 4.39 4.82 4.9

CA720402 JB January 31, 1978  1:51 PM

2371	5	2371
2371	5	2371
2371	5	2371
2849	5	2371
2371	6	2371


************************



A System for Interprocess Communication
in a Resource Sharing Computer Network

A system of communication between processes in a
time-sharing system is described and the communication 
system is extended so that it may be used between processes
distributed throughout a computer network. 
 The hypothetical application <B>of the</B> system to an existing network is discussed.

CACM April, 1972

Walden, D. C.

interprocess communication, time-sharing,
computer networks, resource sharing

3.81 4.39 4.82 4.9

CA720402 JB January 31, 1978  1:51 PM

2371	5	2371
2371	5	2371
2371	5	2371
2849	5	2371
2371	6	2371


************************



A System for Interprocess Communication
in a Resource Sharing Computer Network

A system of communication between processes in a
time-sharing system is described <B>and the</B> communication 
system is extended so that it may be used between processes
distributed throughout a computer network. 
 The hypothetical application of the system to an existing network is discussed.

CACM April, 1972

Walden, D. C.

interprocess communication, time-sharing,
computer networks, resource sharing

3.81 4.39 4.82 4.9

CA720402 JB January 31, 1978  1:51 PM

2371	5	2371
2371	5	2371
2371	5	2371
2849	5	2371
2371	6	2371


************************

************************
Document:  CACM-2912.html
************************


Concurrent Reading and Writing

The problem of sharing data among asynchronous
process is considered.  It <B>is a</B>ssumed that only 
one process at a time can modify the data, but concurrent
reading and writing is permitted.  Two general 
theorems are proved, and some algorithms are presented
to illustrate their use.  These include a solution 
to the general problem in which a read is repeated if
it might have obtained an incorrect result, and 
two techniques for transmitting messages between processes.
 These solutions do not assume any synchronizing 
mechanism other than data which can be written
by one process and read by other processes.

CACM November, 1977

Lamport, L.

asynchronous multiprocessing, multiprocess synchronization,
readers/writers problem, shared data

4.32 5.24

CA771104 JB December 27, 1977  7:47 AM

2320	4	2912
2597	4	2912
2777	4	2912
2851	4	2912
2895	4	2912
2912	4	2912
2946	4	2912
3128	4	2912
2150	5	2912
2912	5	2912
2912	5	2912
2912	5	2912
3128	5	2912
2150	6	2912
2376	6	2912
2436	6	2912
2597	6	2912
2865	6	2912
2866	6	2912
2870	6	2912
2912	6	2912
3082	6	2912


************************

************************
Document:  CACM-3153.html
************************


The Control of Response Times in Multi-Class
Systems by Memory Allocations 

The possibility of giving different quality of service to jobs of different
classes by regulating their memory allocation is examined in
the context of a paged computer system.  Two parameterized algorithms
which partition the main memory between two classes of jobs are
considered.  Initially, a closed system consisting of a process
or and paging and file devices, with fixed numbers of jobs, is studied
to determine optimal degrees of multiprogramming <B>and the</B> proportion
of processor time devoted to each class.  Applying a decomposition
approach and treating the closed system as a single server,
the response times in an open system with external arrivals are
studied.  The object is to investigate the effect of the memory
alocation parameters on the expected response times under the two algorithms.
Numerical solutions and economical lower bounds for the
expected response times as functions of the control parameters
are obtained.  A way of applying the results to systems with more
than two job classes is indicated.

CACM July, 1979

Hine, J.
Mitrani, I.
Tsur, S.

Queueing networks, paging, virtual memory, performance control

4.32 8.1

CA790704 DH August 22, 1979  3:32 PM

3016	4	3153
3070	4	3153
3153	4	3153
3153	4	3153
2741	5	3153
2891	5	3153
3153	5	3153
3153	5	3153
3153	5	3153


************************



The Control of Response Times in Multi-Class
Systems by Memory Allocations 

The possibility of giving different quality of service to jobs of different
classes by regulating their memory allocation is examined in
the context of a paged computer system.  Two parameterized algorithms
which partition the main memory between two classes of jobs are
considered.  Initially, a closed system consisting of a process
or and paging and file devices, with fixed numbers of jobs, is studied
to determine optimal degrees of multiprogramming and the proportion
of processor time devoted to each class.  Applying a decomposition
approach and treating the closed system as a single server,
the response times in an open system with external arrivals are
studied.  The object is to investigate the effect <B>of the</B> memory
alocation parameters on the expected response times under the two algorithms.
Numerical solutions and economical lower bounds for the
expected response times as functions of the control parameters
are obtained.  A way of applying the results to systems with more
than two job classes is indicated.

CACM July, 1979

Hine, J.
Mitrani, I.
Tsur, S.

Queueing networks, paging, virtual memory, performance control

4.32 8.1

CA790704 DH August 22, 1979  3:32 PM

3016	4	3153
3070	4	3153
3153	4	3153
3153	4	3153
2741	5	3153
2891	5	3153
3153	5	3153
3153	5	3153
3153	5	3153


************************



The Control of Response Times in Multi-Class
Systems by Memory Allocations 

The possibility of giving different quality of service to jobs of different
classes by regulating their memory allocation is examined in
the context <B>of a</B> paged computer system.  Two parameterized algorithms
which partition the main memory between two classes of jobs are
considered.  Initially, a closed system consisting of a process
or and paging and file devices, with fixed numbers of jobs, is studied
to determine optimal degrees of multiprogramming and the proportion
of processor time devoted to each class.  Applying a decomposition
approach and treating the closed system as a single server,
the response times in an open system with external arrivals are
studied.  The object is to investigate the effect of the memory
alocation parameters on the expected response times under the two algorithms.
Numerical solutions and economical lower bounds for the
expected response times as functions of the control parameters
are obtained.  A way of applying the results to systems with more
than two job classes is indicated.

CACM July, 1979

Hine, J.
Mitrani, I.
Tsur, S.

Queueing networks, paging, virtual memory, performance control

4.32 8.1

CA790704 DH August 22, 1979  3:32 PM

3016	4	3153
3070	4	3153
3153	4	3153
3153	4	3153
2741	5	3153
2891	5	3153
3153	5	3153
3153	5	3153
3153	5	3153


************************



The Control of Response Times in Multi-Class
Systems by Memory Allocations 

The possibility of giving different quality of service to jobs of different
classes by regulating their memory allocation is examined in
the context of a paged computer system.  Two parameterized algorithms
which partition the main memory <B>between two</B> classes of jobs are
considered.  Initially, a closed system consisting of a process
or and paging and file devices, with fixed numbers of jobs, is studied
to determine optimal degrees of multiprogramming and the proportion
of processor time devoted to each class.  Applying a decomposition
approach and treating the closed system as a single server,
the response times in an open system with external arrivals are
studied.  The object is to investigate the effect of the memory
alocation parameters on the expected response times under the two algorithms.
Numerical solutions and economical lower bounds for the
expected response times as functions of the control parameters
are obtained.  A way of applying the results to systems with more
than two job classes is indicated.

CACM July, 1979

Hine, J.
Mitrani, I.
Tsur, S.

Queueing networks, paging, virtual memory, performance control

4.32 8.1

CA790704 DH August 22, 1979  3:32 PM

3016	4	3153
3070	4	3153
3153	4	3153
3153	4	3153
2741	5	3153
2891	5	3153
3153	5	3153
3153	5	3153
3153	5	3153


************************



The Control of Response Times in Multi-Class
Systems by Memory Allocations 

The possibility of giving different quality of service to jobs of different
classes by regulating their memory allocation is examined in
the context of a paged computer system.  Two parameterized algorithms
which partition the main memory between two classes of jobs are
considered.  Initially, a closed system consisting of a process
or and paging and file devices, with fixed numbers of jobs, is studied
to determine optimal degrees of multiprogramming and the proportion
of processor time devoted to each class.  Applying a decomposition
approach and <B>treating the</B> closed system as a single server,
the response times in an open system with external arrivals are
studied.  The object is to investigate the effect of the memory
alocation parameters on the expected response times under the two algorithms.
Numerical solutions and economical lower bounds for the
expected response times as functions of the control parameters
are obtained.  A way of applying the results to systems with more
than two job classes is indicated.

CACM July, 1979

Hine, J.
Mitrani, I.
Tsur, S.

Queueing networks, paging, virtual memory, performance control

4.32 8.1

CA790704 DH August 22, 1979  3:32 PM

3016	4	3153
3070	4	3153
3153	4	3153
3153	4	3153
2741	5	3153
2891	5	3153
3153	5	3153
3153	5	3153
3153	5	3153


************************



The Control of Response Times in Multi-Class
Systems by Memory Allocations 

The possibility of giving different quality of service to jobs of different
classes by regulating their memory allocation is examined in
the context of a paged computer system.  Two parameterized algorithms
which partition the main memory between two classes of jobs are
considered.  Initially, a closed system consisting of a process
or and paging and file devices, with fixed numbers of jobs, is studied
to determine optimal degrees of multiprogramming and the proportion
of processor time devoted to each class.  Applying a decomposition
approach and treating the closed system as a single server,
the response times <B>in a</B>n open system with external arrivals are
studied.  The object is to investigate the effect of the memory
alocation parameters on the expected response times under the two algorithms.
Numerical solutions and economical lower bounds for the
expected response times as functions of the control parameters
are obtained.  A way of applying the results to systems with more
than two job classes is indicated.

CACM July, 1979

Hine, J.
Mitrani, I.
Tsur, S.

Queueing networks, paging, virtual memory, performance control

4.32 8.1

CA790704 DH August 22, 1979  3:32 PM

3016	4	3153
3070	4	3153
3153	4	3153
3153	4	3153
2741	5	3153
2891	5	3153
3153	5	3153
3153	5	3153
3153	5	3153


************************

************************
Document:  CACM-1870.html
************************


Some Techniques for Using Pseudorandom Numbers in Computer Simulation

An algorithm is described by which uniform pseudorandom
integers may be used to construct binary 
"numbers" in which the probability that each bit in the
word <B>is a</B> 1-bit and can assume any desired parameter 
value.  Techniques for making use of such "numbers"
in simulation programming are described.

CACM July, 1969

Donnelly, T.

random numbers,  simulation, Boolean algebra, bit manipulation

5.19 5.39

CA690710 JB February 17, 1978  8:54 AM

1794	4	1870
1870	4	1870
2122	4	1870
1674	5	1870
1870	5	1870
1870	5	1870
1870	5	1870


************************

************************
Document:  CACM-1828.html
************************


Synchronization in a Parallel-Accessed Data Base

The following problem is considered:  Given
a data base which can be manipulated simultaneously 
by more than one process, what are the rules for synchronization
which will maximize the amount of parallel 
activity allowed.  It is assumed that the data base
can be represented as a graph.  An example of such 
a data base is a hierarchy of directories for an on-line
file system.  Methods for synchronization of 
processes are examined; their validity is
discussed <B>and the</B>ir performance compared.

CACM November, 1969

Shoshani, A.
Bernstein, A. J.

parallel accessing, parallel search, file search,
data base, synchronization, locking, deadlock

3.73 3.74 4.32

CA691102 JB February 15, 1978  1:13 PM

1805	4	1828
1828	4	1828
1828	4	1828
1854	4	1828
1854	4	1828
1877	4	1828
1960	4	1828
2150	4	1828
2187	4	1828
2317	4	1828
2319	4	1828
2377	4	1828
2342	4	1828
2376	4	1828
2379	4	1828
2424	4	1828
2482	4	1828
2618	4	1828
2632	4	1828
2704	4	1828
2723	4	1828
2738	4	1828
2740	4	1828
2741	4	1828
2867	4	1828
3184	4	1828
1748	5	1828
1749	5	1828
1828	5	1828
1828	5	1828
1828	5	1828


************************



Synchronization <B>in a</B> Parallel-Accessed Data Base

The following problem is considered:  Given
a data base which can be manipulated simultaneously 
by more than one process, what are the rules for synchronization
which will maximize the amount of parallel 
activity allowed.  It is assumed that the data base
can be represented as a graph.  An example of such 
a data base is a hierarchy of directories for an on-line
file system.  Methods for synchronization of 
processes are examined; their validity is
discussed and their performance compared.

CACM November, 1969

Shoshani, A.
Bernstein, A. J.

parallel accessing, parallel search, file search,
data base, synchronization, locking, deadlock

3.73 3.74 4.32

CA691102 JB February 15, 1978  1:13 PM

1805	4	1828
1828	4	1828
1828	4	1828
1854	4	1828
1854	4	1828
1877	4	1828
1960	4	1828
2150	4	1828
2187	4	1828
2317	4	1828
2319	4	1828
2377	4	1828
2342	4	1828
2376	4	1828
2379	4	1828
2424	4	1828
2482	4	1828
2618	4	1828
2632	4	1828
2704	4	1828
2723	4	1828
2738	4	1828
2740	4	1828
2741	4	1828
2867	4	1828
3184	4	1828
1748	5	1828
1749	5	1828
1828	5	1828
1828	5	1828
1828	5	1828


************************



Synchronization in a Parallel-Accessed Data Base

The following problem is considered:  Given
a data base which can be manipulated simultaneously 
by more than one process, what are the rules for synchronization
which will maximize the amount of parallel 
activity allowed.  It <B>is a</B>ssumed that the data base
can be represented as a graph.  An example of such 
a data base is a hierarchy of directories for an on-line
file system.  Methods for synchronization of 
processes are examined; their validity is
discussed and their performance compared.

CACM November, 1969

Shoshani, A.
Bernstein, A. J.

parallel accessing, parallel search, file search,
data base, synchronization, locking, deadlock

3.73 3.74 4.32

CA691102 JB February 15, 1978  1:13 PM

1805	4	1828
1828	4	1828
1828	4	1828
1854	4	1828
1854	4	1828
1877	4	1828
1960	4	1828
2150	4	1828
2187	4	1828
2317	4	1828
2319	4	1828
2377	4	1828
2342	4	1828
2376	4	1828
2379	4	1828
2424	4	1828
2482	4	1828
2618	4	1828
2632	4	1828
2704	4	1828
2723	4	1828
2738	4	1828
2740	4	1828
2741	4	1828
2867	4	1828
3184	4	1828
1748	5	1828
1749	5	1828
1828	5	1828
1828	5	1828
1828	5	1828


************************



Synchronization in a Parallel-Accessed Data Base

The following problem is considered:  Given
a data base which can be manipulated simultaneously 
by more than one process, what are the rules for synchronization
which will maximize the amount of parallel 
activity allowed.  It is assumed <B>that the</B> data base
can be represented as a graph.  An example of such 
a data base is a hierarchy of directories for an on-line
file system.  Methods for synchronization of 
processes are examined; their validity is
discussed and their performance compared.

CACM November, 1969

Shoshani, A.
Bernstein, A. J.

parallel accessing, parallel search, file search,
data base, synchronization, locking, deadlock

3.73 3.74 4.32

CA691102 JB February 15, 1978  1:13 PM

1805	4	1828
1828	4	1828
1828	4	1828
1854	4	1828
1854	4	1828
1877	4	1828
1960	4	1828
2150	4	1828
2187	4	1828
2317	4	1828
2319	4	1828
2377	4	1828
2342	4	1828
2376	4	1828
2379	4	1828
2424	4	1828
2482	4	1828
2618	4	1828
2632	4	1828
2704	4	1828
2723	4	1828
2738	4	1828
2740	4	1828
2741	4	1828
2867	4	1828
3184	4	1828
1748	5	1828
1749	5	1828
1828	5	1828
1828	5	1828
1828	5	1828


************************

************************
Document:  CACM-2002.html
************************


AMESPLOT-A Higher Level Data Plotting Software System

AMESPLOT is an extensible software system designed to make the display of 
data as simple, painless, and neat as possible.  The system described is 
hardware-independent and has been implemented on a variety of installations,
of different manufacturers, having diverse configurations.  The elements 
common to all types of data plots are outlined and the way in which these 
elements may be combined into a system based on simple modules is demonstrated.
These modules are specified independently and are independent of the axis
systems or other attributes of the plot.  This enables plots <B>of a</B>ny
complexity to be constructed by adding or replacing modules.  The
basic syntax of AMESPLOT is outlined, and a brief description is given
of its current utility software, consisting of "macros" to produce
self-scaled plots, formal tablets of text-interspersed with subplots,
map coastlines, and 3-D plots.  The system was formulate
d in a way such that the user could supply the minimum of information,
and it should be fully integrable with user's program written
in most conventional higher languages.  The functions of positioning,
locating, and scaling (in the layout of multiple subplots) of
axes, labels, and all other elements of the plot are handled automatically
by the software system unless the user specifies otherwise.  The structuring 
of plots from multiple, independent, self-contained subplots is described.
Transformation, projection, scaling, rotation, or shifting of entire plots or 
subplots by the action of one or more simple modules is possible.  The user 
may interact freely with AMESPLOT at three levels, enabling him to construct 
his own data markers, alphabetic characters, and transformations, and
to produce a variety of artistic and other effects.

CACM September, 1970

Hirschsoln, I.

computer graphics, data potting, data display
syntax, hardware independent software,
display device independent software, plot elements, self-scaled plots,
user interaction, tablet organization, map display, projection

4.13 4.29 4.49 4.9

CA700903 JB February 10, 1978 2:08 PM

2003	4	2002
2002	4	2002
2002	4	2002
2152	4	2002
1767	5	2002
1937	5	2002
2002	5	2002
2002	5	2002
2002	5	2002


************************



AMESPLOT-A Higher Level Data Plotting Software System

AMESPLOT is an extensible software system designed to make the display of 
data as simple, painless, and neat as possible.  The system described is 
hardware-independent and has been implemented on a variety of installations,
of different manufacturers, having diverse configurations.  The elements 
common to all types of data plots are outlined and the way in which these 
elements may be combined into a system based on simple modules is demonstrated.
These modules are specified independently and are independent of the axis
systems or other attributes of the plot.  This enables plots of any
complexity to be constructed by adding or replacing modules.  The
basic syntax of AMESPLOT is outlined, and a brief description is given
of its current utility software, consisting of "macros" to produce
self-scaled plots, formal tablets of text-interspersed with subplots,
map coastlines, and 3-D plots.  The system was formulate
d in a way such <B>that the</B> user could supply the minimum of information,
and it should be fully integrable with user's program written
in most conventional higher languages.  The functions of positioning,
locating, and scaling (in the layout of multiple subplots) of
axes, labels, and all other elements of the plot are handled automatically
by the software system unless the user specifies otherwise.  The structuring 
of plots from multiple, independent, self-contained subplots is described.
Transformation, projection, scaling, rotation, or shifting of entire plots or 
subplots by the action of one or more simple modules is possible.  The user 
may interact freely with AMESPLOT at three levels, enabling him to construct 
his own data markers, alphabetic characters, and transformations, and
to produce a variety of artistic and other effects.

CACM September, 1970

Hirschsoln, I.

computer graphics, data potting, data display
syntax, hardware independent software,
display device independent software, plot elements, self-scaled plots,
user interaction, tablet organization, map display, projection

4.13 4.29 4.49 4.9

CA700903 JB February 10, 1978 2:08 PM

2003	4	2002
2002	4	2002
2002	4	2002
2152	4	2002
1767	5	2002
1937	5	2002
2002	5	2002
2002	5	2002
2002	5	2002


************************



AMESPLOT-A Higher Level Data Plotting Software System

AMESPLOT is an extensible software system designed to make the display of 
data as simple, painless, and neat as possible.  The system described is 
hardware-independent and has been implemented on a variety of installations,
of different manufacturers, having diverse configurations.  The elements 
common to all types of data plots are outlined and the way in which these 
elements may be combined into a system based on simple modules is demonstrated.
These modules are specified independently and are independent <B>of the</B> axis
systems or other attributes of the plot.  This enables plots of any
complexity to be constructed by adding or replacing modules.  The
basic syntax of AMESPLOT is outlined, and a brief description is given
of its current utility software, consisting of "macros" to produce
self-scaled plots, formal tablets of text-interspersed with subplots,
map coastlines, and 3-D plots.  The system was formulate
d in a way such that the user could supply the minimum of information,
and it should be fully integrable with user's program written
in most conventional higher languages.  The functions of positioning,
locating, and scaling (in the layout of multiple subplots) of
axes, labels, and all other elements of the plot are handled automatically
by the software system unless the user specifies otherwise.  The structuring 
of plots from multiple, independent, self-contained subplots is described.
Transformation, projection, scaling, rotation, or shifting of entire plots or 
subplots by the action of one or more simple modules is possible.  The user 
may interact freely with AMESPLOT at three levels, enabling him to construct 
his own data markers, alphabetic characters, and transformations, and
to produce a variety of artistic and other effects.

CACM September, 1970

Hirschsoln, I.

computer graphics, data potting, data display
syntax, hardware independent software,
display device independent software, plot elements, self-scaled plots,
user interaction, tablet organization, map display, projection

4.13 4.29 4.49 4.9

CA700903 JB February 10, 1978 2:08 PM

2003	4	2002
2002	4	2002
2002	4	2002
2152	4	2002
1767	5	2002
1937	5	2002
2002	5	2002
2002	5	2002
2002	5	2002


************************



AMESPLOT-A Higher Level Data Plotting Software System

AMESPLOT is an extensible software system designed to make the display of 
data as simple, painless, and neat as possible.  The system described is 
hardware-independent and has been implemented on a variety of installations,
of different manufacturers, having diverse configurations.  The elements 
common to all types of data plots are outlined and the way in which these 
elements may be combined into a system based on simple modules is demonstrated.
These modules are specified independently and are independent of the axis
systems or other attributes of the plot.  This enables plots of any
complexity to be constructed by adding or replacing modules.  The
basic syntax of AMESPLOT is outlined, and a brief description is given
of its current utility software, consisting of "macros" to produce
self-scaled plots, formal tablets of text-interspersed with subplots,
map coastlines, and 3-D plots.  The system was formulate
d <B>in a</B> way such that the user could supply the minimum of information,
and it should be fully integrable with user's program written
in most conventional higher languages.  The functions of positioning,
locating, and scaling (in the layout of multiple subplots) of
axes, labels, and all other elements of the plot are handled automatically
by the software system unless the user specifies otherwise.  The structuring 
of plots from multiple, independent, self-contained subplots is described.
Transformation, projection, scaling, rotation, or shifting of entire plots or 
subplots by the action of one or more simple modules is possible.  The user 
may interact freely with AMESPLOT at three levels, enabling him to construct 
his own data markers, alphabetic characters, and transformations, and
to produce a variety of artistic and other effects.

CACM September, 1970

Hirschsoln, I.

computer graphics, data potting, data display
syntax, hardware independent software,
display device independent software, plot elements, self-scaled plots,
user interaction, tablet organization, map display, projection

4.13 4.29 4.49 4.9

CA700903 JB February 10, 1978 2:08 PM

2003	4	2002
2002	4	2002
2002	4	2002
2152	4	2002
1767	5	2002
1937	5	2002
2002	5	2002
2002	5	2002
2002	5	2002


************************



AMESPLOT-A Higher Level Data Plotting Software System

AMESPLOT <B>is a</B>n extensible software system designed to make the display of 
data as simple, painless, and neat as possible.  The system described is 
hardware-independent and has been implemented on a variety of installations,
of different manufacturers, having diverse configurations.  The elements 
common to all types of data plots are outlined and the way in which these 
elements may be combined into a system based on simple modules is demonstrated.
These modules are specified independently and are independent of the axis
systems or other attributes of the plot.  This enables plots of any
complexity to be constructed by adding or replacing modules.  The
basic syntax of AMESPLOT is outlined, and a brief description is given
of its current utility software, consisting of "macros" to produce
self-scaled plots, formal tablets of text-interspersed with subplots,
map coastlines, and 3-D plots.  The system was formulate
d in a way such that the user could supply the minimum of information,
and it should be fully integrable with user's program written
in most conventional higher languages.  The functions of positioning,
locating, and scaling (in the layout of multiple subplots) of
axes, labels, and all other elements of the plot are handled automatically
by the software system unless the user specifies otherwise.  The structuring 
of plots from multiple, independent, self-contained subplots is described.
Transformation, projection, scaling, rotation, or shifting of entire plots or 
subplots by the action of one or more simple modules is possible.  The user 
may interact freely with AMESPLOT at three levels, enabling him to construct 
his own data markers, alphabetic characters, and transformations, and
to produce a variety of artistic and other effects.

CACM September, 1970

Hirschsoln, I.

computer graphics, data potting, data display
syntax, hardware independent software,
display device independent software, plot elements, self-scaled plots,
user interaction, tablet organization, map display, projection

4.13 4.29 4.49 4.9

CA700903 JB February 10, 1978 2:08 PM

2003	4	2002
2002	4	2002
2002	4	2002
2152	4	2002
1767	5	2002
1937	5	2002
2002	5	2002
2002	5	2002
2002	5	2002


************************



AMESPLOT-A Higher Level Data Plotting Software System

AMESPLOT is an extensible software system designed to make the display of 
data as simple, painless, and neat as possible.  The system described is 
hardware-independent and has been implemented on a variety of installations,
of different manufacturers, having diverse configurations.  The elements 
common to all types of data plots are outlined <B>and the</B> way in which these 
elements may be combined into a system based on simple modules is demonstrated.
These modules are specified independently and are independent of the axis
systems or other attributes of the plot.  This enables plots of any
complexity to be constructed by adding or replacing modules.  The
basic syntax of AMESPLOT is outlined, and a brief description is given
of its current utility software, consisting of "macros" to produce
self-scaled plots, formal tablets of text-interspersed with subplots,
map coastlines, and 3-D plots.  The system was formulate
d in a way such that the user could supply the minimum of information,
and it should be fully integrable with user's program written
in most conventional higher languages.  The functions of positioning,
locating, and scaling (in the layout of multiple subplots) of
axes, labels, and all other elements of the plot are handled automatically
by the software system unless the user specifies otherwise.  The structuring 
of plots from multiple, independent, self-contained subplots is described.
Transformation, projection, scaling, rotation, or shifting of entire plots or 
subplots by the action of one or more simple modules is possible.  The user 
may interact freely with AMESPLOT at three levels, enabling him to construct 
his own data markers, alphabetic characters, and transformations, and
to produce a variety of artistic and other effects.

CACM September, 1970

Hirschsoln, I.

computer graphics, data potting, data display
syntax, hardware independent software,
display device independent software, plot elements, self-scaled plots,
user interaction, tablet organization, map display, projection

4.13 4.29 4.49 4.9

CA700903 JB February 10, 1978 2:08 PM

2003	4	2002
2002	4	2002
2002	4	2002
2152	4	2002
1767	5	2002
1937	5	2002
2002	5	2002
2002	5	2002
2002	5	2002


************************



AMESPLOT-A Higher Level Data Plotting Software System

AMESPLOT is an extensible software system designed to make the display of 
data as simple, painless, and neat as possible.  The system described is 
hardware-independent and has been implemented on a variety of installations,
of different manufacturers, having diverse configurations.  The elements 
common to all <B>types of</B> data plots are outlined and the way in which these 
elements may be combined into a system based on simple modules is demonstrated.
These modules are specified independently and are independent of the axis
systems or other attributes of the plot.  This enables plots of any
complexity to be constructed by adding or replacing modules.  The
basic syntax of AMESPLOT is outlined, and a brief description is given
of its current utility software, consisting of "macros" to produce
self-scaled plots, formal tablets of text-interspersed with subplots,
map coastlines, and 3-D plots.  The system was formulate
d in a way such that the user could supply the minimum of information,
and it should be fully integrable with user's program written
in most conventional higher languages.  The functions of positioning,
locating, and scaling (in the layout of multiple subplots) of
axes, labels, and all other elements of the plot are handled automatically
by the software system unless the user specifies otherwise.  The structuring 
of plots from multiple, independent, self-contained subplots is described.
Transformation, projection, scaling, rotation, or shifting of entire plots or 
subplots by the action of one or more simple modules is possible.  The user 
may interact freely with AMESPLOT at three levels, enabling him to construct 
his own data markers, alphabetic characters, and transformations, and
to produce a variety of artistic and other effects.

CACM September, 1970

Hirschsoln, I.

computer graphics, data potting, data display
syntax, hardware independent software,
display device independent software, plot elements, self-scaled plots,
user interaction, tablet organization, map display, projection

4.13 4.29 4.49 4.9

CA700903 JB February 10, 1978 2:08 PM

2003	4	2002
2002	4	2002
2002	4	2002
2152	4	2002
1767	5	2002
1937	5	2002
2002	5	2002
2002	5	2002
2002	5	2002


************************

************************
Document:  CACM-3103.html
************************


Automatic Data Structure Selection: An Example and Overview

The use of several levels of abstraction has
proved to be very helpful in constructing and 
maintaining programs.  When programs are designed with abstract
<B>data types</B> such as sets and lists, programmer 
time can be saved by automating the process of filling
in low-level implementation details.  In the past, 
programming systems have provided only a single general
purpose implementation for an abstract type. 
 Thus the programs produced using abstract types were
then inefficient in space or time.  In this paper 
a system for automatically choosing efficient implementations
for abstract types from a library of implementations 
is discussed.  This process is discussed in detail for
an example program.  General issues in data structure 
selection are also reviewed. 

CACM May, 1978

Low, J.

Abstract data types, automatic programming, data
structures, optimizing compilers, sets, lists

4.12 4.22 4.6

CA780504 DH February 26, 1979  1:51 PM

1957	4	3103
2151	4	3103
3103	4	3103
3103	4	3103
3148	4	3103
1860	5	3103
2877	5	3103
3103	5	3103
3103	5	3103
3103	5	3103


************************



Automatic Data Structure Selection: An Example and Overview

The use of several levels <B>of a</B>bstraction has
proved to be very helpful in constructing and 
maintaining programs.  When programs are designed with abstract
data types such as sets and lists, programmer 
time can be saved by automating the process of filling
in low-level implementation details.  In the past, 
programming systems have provided only a single general
purpose implementation for an abstract type. 
 Thus the programs produced using abstract types were
then inefficient in space or time.  In this paper 
a system for automatically choosing efficient implementations
for abstract types from a library of implementations 
is discussed.  This process is discussed in detail for
an example program.  General issues in data structure 
selection are also reviewed. 

CACM May, 1978

Low, J.

Abstract data types, automatic programming, data
structures, optimizing compilers, sets, lists

4.12 4.22 4.6

CA780504 DH February 26, 1979  1:51 PM

1957	4	3103
2151	4	3103
3103	4	3103
3103	4	3103
3148	4	3103
1860	5	3103
2877	5	3103
3103	5	3103
3103	5	3103
3103	5	3103


************************

************************
Document:  CACM-2705.html
************************


Programming Languages, Natural Languages, and Mathematics

Some social aspects of programming are illuminated
through analogies with similar aspects of 
mathematics and natural languages.  The split between
pure and applied mathematics is found similarly 
in programming. The development of natural languages toward
flexion less, word-order based language types 
speaks for programming language design based on general,
abstract constructs.  By analogy with incidents 
<B>of the</B> history of artificial, auxiliary languages it
is suggested that Fortran and Cobol will remain 
dominant for a long time to come.  The most promising
avenues for further work of wide influence are 
seen to be high quality program literature (i.e. programs)
of general utility and studies of questions 
related to program style.

CACM December, 1975

Naur, P.

analogies related to social aspects,pure and applied
mathematics, language quality, language development, 
artificial auxiliary languages, literature, style,
descriptive and prescriptive attitudes

4.20

CA751202 JB January 6, 1978  8:30 AM

2705	4	2705
2705	4	2705
2984	4	2705
3101	4	2705
1908	5	2705
2705	5	2705
2705	5	2705
2705	5	2705
3185	5	2705


************************



Programming Languages, Natural Languages, and Mathematics

Some social aspects of programming are illuminated
through analogies with similar aspects of 
mathematics and natural languages.  The split between
pure and applied mathematics is found similarly 
in programming. The development of natural languages toward
flexion less, word-order based language types 
speaks for programming language design based on general,
abstract constructs.  By analogy with incidents 
of the history <B>of a</B>rtificial, auxiliary languages it
is suggested that Fortran and Cobol will remain 
dominant for a long time to come.  The most promising
avenues for further work of wide influence are 
seen to be high quality program literature (i.e. programs)
of general utility and studies of questions 
related to program style.

CACM December, 1975

Naur, P.

analogies related to social aspects,pure and applied
mathematics, language quality, language development, 
artificial auxiliary languages, literature, style,
descriptive and prescriptive attitudes

4.20

CA751202 JB January 6, 1978  8:30 AM

2705	4	2705
2705	4	2705
2984	4	2705
3101	4	2705
1908	5	2705
2705	5	2705
2705	5	2705
2705	5	2705
3185	5	2705


************************

************************
Document:  CACM-0906.html
************************


Combination <B>in a</B>ny Order (Algorithm 155)

CACM March, 1963

Mifsud, C. J.

CA630314 JB March 14, 1978  1:33 PM

906	5	906
906	5	906
906	5	906


************************

************************
Document:  CACM-2060.html
************************


GEDANKEN-A Simple Typeless Language Based on the
Principle of Completeness and the Reference Concept

GEDANKEN <B>is a</B>n experimental programming language with the following 
characteristics.  (1) Any value which is permitted in some context of the 
language is permissible in any other meaningful context.  In particular,
functions and labels are permissible  results of functions and values
of variables.  (2) Assignment and indirect addressing are formalized
by introducing values, called reference, which in turn possess
other values.  The assignment operation always affects the relation
between some reference and its value,  (3) All compound data
structures are treated as functions.  (4) Type declarations are
not permitted.  The functional approach to data structures and the
use of references insure that any process which accepts some data
structure will accept any logically equivalent structure, regardless
of its internal representation.  More generally, any data structure
may be implicit; i.e. it may be specified by giving an arbitrary
algorithm for computing or accessing its components.  The existence of 
label variables permits the construction of coroutines,
quasi-parallel processes, and other unorthodox control mechanisms.
A variety of programming examples illustrates the generality of the language.
Limitations and possible extensions are discussed briefly.

CACM May, 1970

Reynolds, J. C.

programming language, data structure, reference, assignment, coroutine,
quasi-parallel process, typeless language, applicative language,
lambda calculus, list processing, nondeterministic algorithm

4.20 4.22 5.23 5.24

CA700506 JB February 13, 1978  1:43 PM

1024	4	2060
1051	4	2060
1102	4	2060
1132	4	2060
1379	4	2060
1380	4	2060
1390	4	2060
1486	4	2060
1541	4	2060
1542	4	2060
1549	4	2060
1552	4	2060
1683	4	2060
1693	4	2060
1693	4	2060
1693	4	2060
1706	4	2060
1781	4	2060
1781	4	2060
1781	4	2060
1787	4	2060
1826	4	2060
1836	4	2060
1836	4	2060
1846	4	2060
1854	4	2060
1860	4	2060
1878	4	2060
1945	4	2060
1945	4	2060
1989	4	2060
378	4	2060
2015	4	2060
2060	4	2060
2060	4	2060
2060	4	2060
2060	4	2060
2060	4	2060
2060	4	2060
2060	4	2060
2060	4	2060
2061	4	2060
2061	4	2060
2082	4	2060
2091	4	2060
2091	4	2060
2155	4	2060
2152	4	2060
2168	4	2060
2179	4	2060
2179	4	2060
2179	4	2060
2218	4	2060
2294	4	2060
2340	4	2060
2356	4	2060
2470	4	2060
2546	4	2060
2546	4	2060
2603	4	2060
2698	4	2060
2698	4	2060
2698	4	2060
2708	4	2060
2708	4	2060
2719	4	2060
2723	4	2060
2770	4	2060
2824	4	2060
2838	4	2060
2842	4	2060
2855	4	2060
2879	4	2060
2921	4	2060
2982	4	2060
2986	4	2060
557	4	2060
3045	4	2060
3045	4	2060
3077	4	2060
3080	4	2060
3093	4	2060
3106	4	2060
3112	4	2060
3124	4	2060
3154	4	2060
627	4	2060
106	4	2060
210	5	2060
1380	5	2060
1421	5	2060
1469	5	2060
1477	5	2060
1491	5	2060
1869	5	2060
2060	5	2060
2060	5	2060
2060	5	2060
2110	5	2060
2155	5	2060
2294	5	2060
2558	5	2060
2842	5	2060
3077	5	2060
3150	5	2060
1389	6	2060
1469	6	2060
1471	6	2060
210	6	2060
210	6	2060
210	6	2060
1834	6	2060
378	6	2060
2046	6	2060
2060	6	2060
2060	6	2060
2060	6	2060
2060	6	2060
2060	6	2060
2060	6	2060
2148	6	2060
2192	6	2060
2457	6	2060
2704	6	2060
2842	6	2060
2939	6	2060
2940	6	2060
2941	6	2060
2943	6	2060
3073	6	2060
3148	6	2060
3184	6	2060


************************



GEDANKEN-A Simple Typeless Language Based on the
Principle of Completeness and the Reference Concept

GEDANKEN is an experimental programming language with the following 
characteristics.  (1) Any value which is permitted in some context <B>of the</B> 
language is permissible in any other meaningful context.  In particular,
functions and labels are permissible  results of functions and values
of variables.  (2) Assignment and indirect addressing are formalized
by introducing values, called reference, which in turn possess
other values.  The assignment operation always affects the relation
between some reference and its value,  (3) All compound data
structures are treated as functions.  (4) Type declarations are
not permitted.  The functional approach to data structures and the
use of references insure that any process which accepts some data
structure will accept any logically equivalent structure, regardless
of its internal representation.  More generally, any data structure
may be implicit; i.e. it may be specified by giving an arbitrary
algorithm for computing or accessing its components.  The existence of 
label variables permits the construction of coroutines,
quasi-parallel processes, and other unorthodox control mechanisms.
A variety of programming examples illustrates the generality of the language.
Limitations and possible extensions are discussed briefly.

CACM May, 1970

Reynolds, J. C.

programming language, data structure, reference, assignment, coroutine,
quasi-parallel process, typeless language, applicative language,
lambda calculus, list processing, nondeterministic algorithm

4.20 4.22 5.23 5.24

CA700506 JB February 13, 1978  1:43 PM

1024	4	2060
1051	4	2060
1102	4	2060
1132	4	2060
1379	4	2060
1380	4	2060
1390	4	2060
1486	4	2060
1541	4	2060
1542	4	2060
1549	4	2060
1552	4	2060
1683	4	2060
1693	4	2060
1693	4	2060
1693	4	2060
1706	4	2060
1781	4	2060
1781	4	2060
1781	4	2060
1787	4	2060
1826	4	2060
1836	4	2060
1836	4	2060
1846	4	2060
1854	4	2060
1860	4	2060
1878	4	2060
1945	4	2060
1945	4	2060
1989	4	2060
378	4	2060
2015	4	2060
2060	4	2060
2060	4	2060
2060	4	2060
2060	4	2060
2060	4	2060
2060	4	2060
2060	4	2060
2060	4	2060
2061	4	2060
2061	4	2060
2082	4	2060
2091	4	2060
2091	4	2060
2155	4	2060
2152	4	2060
2168	4	2060
2179	4	2060
2179	4	2060
2179	4	2060
2218	4	2060
2294	4	2060
2340	4	2060
2356	4	2060
2470	4	2060
2546	4	2060
2546	4	2060
2603	4	2060
2698	4	2060
2698	4	2060
2698	4	2060
2708	4	2060
2708	4	2060
2719	4	2060
2723	4	2060
2770	4	2060
2824	4	2060
2838	4	2060
2842	4	2060
2855	4	2060
2879	4	2060
2921	4	2060
2982	4	2060
2986	4	2060
557	4	2060
3045	4	2060
3045	4	2060
3077	4	2060
3080	4	2060
3093	4	2060
3106	4	2060
3112	4	2060
3124	4	2060
3154	4	2060
627	4	2060
106	4	2060
210	5	2060
1380	5	2060
1421	5	2060
1469	5	2060
1477	5	2060
1491	5	2060
1869	5	2060
2060	5	2060
2060	5	2060
2060	5	2060
2110	5	2060
2155	5	2060
2294	5	2060
2558	5	2060
2842	5	2060
3077	5	2060
3150	5	2060
1389	6	2060
1469	6	2060
1471	6	2060
210	6	2060
210	6	2060
210	6	2060
1834	6	2060
378	6	2060
2046	6	2060
2060	6	2060
2060	6	2060
2060	6	2060
2060	6	2060
2060	6	2060
2060	6	2060
2148	6	2060
2192	6	2060
2457	6	2060
2704	6	2060
2842	6	2060
2939	6	2060
2940	6	2060
2941	6	2060
2943	6	2060
3073	6	2060
3148	6	2060
3184	6	2060


************************



GEDANKEN-A Simple Typeless Language Based on the
Principle of Completeness and the Reference Concept

GEDANKEN is an experimental programming language with the following 
characteristics.  (1) Any value which is permitted in some context of the 
language is permissible <B>in a</B>ny other meaningful context.  In particular,
functions and labels are permissible  results of functions and values
of variables.  (2) Assignment and indirect addressing are formalized
by introducing values, called reference, which in turn possess
other values.  The assignment operation always affects the relation
between some reference and its value,  (3) All compound data
structures are treated as functions.  (4) Type declarations are
not permitted.  The functional approach to data structures and the
use of references insure that any process which accepts some data
structure will accept any logically equivalent structure, regardless
of its internal representation.  More generally, any data structure
may be implicit; i.e. it may be specified by giving an arbitrary
algorithm for computing or accessing its components.  The existence of 
label variables permits the construction of coroutines,
quasi-parallel processes, and other unorthodox control mechanisms.
A variety of programming examples illustrates the generality of the language.
Limitations and possible extensions are discussed briefly.

CACM May, 1970

Reynolds, J. C.

programming language, data structure, reference, assignment, coroutine,
quasi-parallel process, typeless language, applicative language,
lambda calculus, list processing, nondeterministic algorithm

4.20 4.22 5.23 5.24

CA700506 JB February 13, 1978  1:43 PM

1024	4	2060
1051	4	2060
1102	4	2060
1132	4	2060
1379	4	2060
1380	4	2060
1390	4	2060
1486	4	2060
1541	4	2060
1542	4	2060
1549	4	2060
1552	4	2060
1683	4	2060
1693	4	2060
1693	4	2060
1693	4	2060
1706	4	2060
1781	4	2060
1781	4	2060
1781	4	2060
1787	4	2060
1826	4	2060
1836	4	2060
1836	4	2060
1846	4	2060
1854	4	2060
1860	4	2060
1878	4	2060
1945	4	2060
1945	4	2060
1989	4	2060
378	4	2060
2015	4	2060
2060	4	2060
2060	4	2060
2060	4	2060
2060	4	2060
2060	4	2060
2060	4	2060
2060	4	2060
2060	4	2060
2061	4	2060
2061	4	2060
2082	4	2060
2091	4	2060
2091	4	2060
2155	4	2060
2152	4	2060
2168	4	2060
2179	4	2060
2179	4	2060
2179	4	2060
2218	4	2060
2294	4	2060
2340	4	2060
2356	4	2060
2470	4	2060
2546	4	2060
2546	4	2060
2603	4	2060
2698	4	2060
2698	4	2060
2698	4	2060
2708	4	2060
2708	4	2060
2719	4	2060
2723	4	2060
2770	4	2060
2824	4	2060
2838	4	2060
2842	4	2060
2855	4	2060
2879	4	2060
2921	4	2060
2982	4	2060
2986	4	2060
557	4	2060
3045	4	2060
3045	4	2060
3077	4	2060
3080	4	2060
3093	4	2060
3106	4	2060
3112	4	2060
3124	4	2060
3154	4	2060
627	4	2060
106	4	2060
210	5	2060
1380	5	2060
1421	5	2060
1469	5	2060
1477	5	2060
1491	5	2060
1869	5	2060
2060	5	2060
2060	5	2060
2060	5	2060
2110	5	2060
2155	5	2060
2294	5	2060
2558	5	2060
2842	5	2060
3077	5	2060
3150	5	2060
1389	6	2060
1469	6	2060
1471	6	2060
210	6	2060
210	6	2060
210	6	2060
1834	6	2060
378	6	2060
2046	6	2060
2060	6	2060
2060	6	2060
2060	6	2060
2060	6	2060
2060	6	2060
2060	6	2060
2148	6	2060
2192	6	2060
2457	6	2060
2704	6	2060
2842	6	2060
2939	6	2060
2940	6	2060
2941	6	2060
2943	6	2060
3073	6	2060
3148	6	2060
3184	6	2060


************************



GEDANKEN-A Simple Typeless Language Based on the
Principle of Completeness <B>and the</B> Reference Concept

GEDANKEN is an experimental programming language with the following 
characteristics.  (1) Any value which is permitted in some context of the 
language is permissible in any other meaningful context.  In particular,
functions and labels are permissible  results of functions and values
of variables.  (2) Assignment and indirect addressing are formalized
by introducing values, called reference, which in turn possess
other values.  The assignment operation always affects the relation
between some reference and its value,  (3) All compound data
structures are treated as functions.  (4) Type declarations are
not permitted.  The functional approach to data structures and the
use of references insure that any process which accepts some data
structure will accept any logically equivalent structure, regardless
of its internal representation.  More generally, any data structure
may be implicit; i.e. it may be specified by giving an arbitrary
algorithm for computing or accessing its components.  The existence of 
label variables permits the construction of coroutines,
quasi-parallel processes, and other unorthodox control mechanisms.
A variety of programming examples illustrates the generality of the language.
Limitations and possible extensions are discussed briefly.

CACM May, 1970

Reynolds, J. C.

programming language, data structure, reference, assignment, coroutine,
quasi-parallel process, typeless language, applicative language,
lambda calculus, list processing, nondeterministic algorithm

4.20 4.22 5.23 5.24

CA700506 JB February 13, 1978  1:43 PM

1024	4	2060
1051	4	2060
1102	4	2060
1132	4	2060
1379	4	2060
1380	4	2060
1390	4	2060
1486	4	2060
1541	4	2060
1542	4	2060
1549	4	2060
1552	4	2060
1683	4	2060
1693	4	2060
1693	4	2060
1693	4	2060
1706	4	2060
1781	4	2060
1781	4	2060
1781	4	2060
1787	4	2060
1826	4	2060
1836	4	2060
1836	4	2060
1846	4	2060
1854	4	2060
1860	4	2060
1878	4	2060
1945	4	2060
1945	4	2060
1989	4	2060
378	4	2060
2015	4	2060
2060	4	2060
2060	4	2060
2060	4	2060
2060	4	2060
2060	4	2060
2060	4	2060
2060	4	2060
2060	4	2060
2061	4	2060
2061	4	2060
2082	4	2060
2091	4	2060
2091	4	2060
2155	4	2060
2152	4	2060
2168	4	2060
2179	4	2060
2179	4	2060
2179	4	2060
2218	4	2060
2294	4	2060
2340	4	2060
2356	4	2060
2470	4	2060
2546	4	2060
2546	4	2060
2603	4	2060
2698	4	2060
2698	4	2060
2698	4	2060
2708	4	2060
2708	4	2060
2719	4	2060
2723	4	2060
2770	4	2060
2824	4	2060
2838	4	2060
2842	4	2060
2855	4	2060
2879	4	2060
2921	4	2060
2982	4	2060
2986	4	2060
557	4	2060
3045	4	2060
3045	4	2060
3077	4	2060
3080	4	2060
3093	4	2060
3106	4	2060
3112	4	2060
3124	4	2060
3154	4	2060
627	4	2060
106	4	2060
210	5	2060
1380	5	2060
1421	5	2060
1469	5	2060
1477	5	2060
1491	5	2060
1869	5	2060
2060	5	2060
2060	5	2060
2060	5	2060
2110	5	2060
2155	5	2060
2294	5	2060
2558	5	2060
2842	5	2060
3077	5	2060
3150	5	2060
1389	6	2060
1469	6	2060
1471	6	2060
210	6	2060
210	6	2060
210	6	2060
1834	6	2060
378	6	2060
2046	6	2060
2060	6	2060
2060	6	2060
2060	6	2060
2060	6	2060
2060	6	2060
2060	6	2060
2148	6	2060
2192	6	2060
2457	6	2060
2704	6	2060
2842	6	2060
2939	6	2060
2940	6	2060
2941	6	2060
2943	6	2060
3073	6	2060
3148	6	2060
3184	6	2060


************************

************************
Document:  CACM-0618.html
************************


Computers- The Key to Total Systems Control: An Industrial Viewpoint

Man-Man-machine processes are characterized in five
main types, <B>and the</B> markets for each type are 
shown for 1950 and 1960 and estimated for 1970.

CACM March, 1962

Carlson, W. M.

CA620314 JB March 20, 1978  2:53 PM

618	5	618
618	5	618
618	5	618


************************

************************
Document:  CACM-3142.html
************************


Consumer Difficulties With Computerized Transactions: 
An Empirical Investigation

The prevalence with which errors may be encountered by the 
end targets of a computerized process is assessed.  How many and
what type of errors occur?  How easily are they corrected?  What
<B>is the</B> reaction of consumers to errors-to a failure to correct
them?  What can be learned by designers of large management packages
from such data? Results show that with the present state of the
art, approximately 40 percent of individuals (or households) having
average contacts with different types of accounts experience one
or more errors per year.  Eighty percent relate to billing.  Attempts
to correct errors often turned out to be difficult and not always
successful. There appears to be some conflict between computer-using
organizations and their public.  Also the role of poor man
agement packages including poor software is indicated.  While most
management systems may be adequate, results of the survey raise
concerns about the timeliness and the number of designs of very
large linked program packages (as EFT for instance).  

CACM May, 1979

Sterling, T.

Errors, systems errors, billing errors, management systems, consumers

2.0 2.1 2.12 2.2 3.50 3.52 3.55 4.19 4.6

CA790503 DH June 5, 1979  3:21 PM

3142	4	3142
3142	4	3142
3179	4	3142
3178	4	3142
3182	4	3142
3183	4	3142
2583	5	3142
3076	5	3142
3142	5	3142
3142	5	3142
3142	5	3142
3178	5	3142
3076	6	3142
3140	6	3142
3142	6	3142
3179	6	3142
3180	6	3142
3181	6	3142
3182	6	3142


************************



Consumer Difficulties With Computerized Transactions: 
An Empirical Investigation

The prevalence with which errors may be encountered by the 
end targets of a computerized process is assessed.  How many and
what type of errors occur?  How easily are they corrected?  What
is the reaction of consumers to errors-to a failure to correct
them?  What can be learned by designers of large management packages
from such data? Results show that with the present state <B>of the</B>
art, approximately 40 percent of individuals (or households) having
average contacts with different types of accounts experience one
or more errors per year.  Eighty percent relate to billing.  Attempts
to correct errors often turned out to be difficult and not always
successful. There appears to be some conflict between computer-using
organizations and their public.  Also the role of poor man
agement packages including poor software is indicated.  While most
management systems may be adequate, results of the survey raise
concerns about the timeliness and the number of designs of very
large linked program packages (as EFT for instance).  

CACM May, 1979

Sterling, T.

Errors, systems errors, billing errors, management systems, consumers

2.0 2.1 2.12 2.2 3.50 3.52 3.55 4.19 4.6

CA790503 DH June 5, 1979  3:21 PM

3142	4	3142
3142	4	3142
3179	4	3142
3178	4	3142
3182	4	3142
3183	4	3142
2583	5	3142
3076	5	3142
3142	5	3142
3142	5	3142
3142	5	3142
3178	5	3142
3076	6	3142
3140	6	3142
3142	6	3142
3179	6	3142
3180	6	3142
3181	6	3142
3182	6	3142


************************



Consumer Difficulties With Computerized Transactions: 
An Empirical Investigation

The prevalence with which errors may be encountered by the 
end targets of a computerized process <B>is a</B>ssessed.  How many and
what type of errors occur?  How easily are they corrected?  What
is the reaction of consumers to errors-to a failure to correct
them?  What can be learned by designers of large management packages
from such data? Results show that with the present state of the
art, approximately 40 percent of individuals (or households) having
average contacts with different types of accounts experience one
or more errors per year.  Eighty percent relate to billing.  Attempts
to correct errors often turned out to be difficult and not always
successful. There appears to be some conflict between computer-using
organizations and their public.  Also the role of poor man
agement packages including poor software is indicated.  While most
management systems may be adequate, results of the survey raise
concerns about the timeliness and the number of designs of very
large linked program packages (as EFT for instance).  

CACM May, 1979

Sterling, T.

Errors, systems errors, billing errors, management systems, consumers

2.0 2.1 2.12 2.2 3.50 3.52 3.55 4.19 4.6

CA790503 DH June 5, 1979  3:21 PM

3142	4	3142
3142	4	3142
3179	4	3142
3178	4	3142
3182	4	3142
3183	4	3142
2583	5	3142
3076	5	3142
3142	5	3142
3142	5	3142
3142	5	3142
3178	5	3142
3076	6	3142
3140	6	3142
3142	6	3142
3179	6	3142
3180	6	3142
3181	6	3142
3182	6	3142


************************



Consumer Difficulties With Computerized Transactions: 
An Empirical Investigation

The prevalence with which errors may be encountered by the 
end targets of a computerized process is assessed.  How many and
what type of errors occur?  How easily are they corrected?  What
is the reaction of consumers to errors-to a failure to correct
them?  What can be learned by designers of large management packages
from such data? Results show that with the present state of the
art, approximately 40 percent of individuals (or households) having
average contacts with different types of accounts experience one
or more errors per year.  Eighty percent relate to billing.  Attempts
to correct errors often turned out to be difficult and not always
successful. There appears to be some conflict between computer-using
organizations <B>and the</B>ir public.  Also the role of poor man
agement packages including poor software is indicated.  While most
management systems may be adequate, results of the survey raise
concerns about the timeliness and the number of designs of very
large linked program packages (as EFT for instance).  

CACM May, 1979

Sterling, T.

Errors, systems errors, billing errors, management systems, consumers

2.0 2.1 2.12 2.2 3.50 3.52 3.55 4.19 4.6

CA790503 DH June 5, 1979  3:21 PM

3142	4	3142
3142	4	3142
3179	4	3142
3178	4	3142
3182	4	3142
3183	4	3142
2583	5	3142
3076	5	3142
3142	5	3142
3142	5	3142
3142	5	3142
3178	5	3142
3076	6	3142
3140	6	3142
3142	6	3142
3179	6	3142
3180	6	3142
3181	6	3142
3182	6	3142


************************



Consumer Difficulties With Computerized Transactions: 
An Empirical Investigation

The prevalence with which errors may be encountered by the 
end targets of a computerized process is assessed.  How many and
what <B>type of</B> errors occur?  How easily are they corrected?  What
is the reaction of consumers to errors-to a failure to correct
them?  What can be learned by designers of large management packages
from such data? Results show that with the present state of the
art, approximately 40 percent of individuals (or households) having
average contacts with different types of accounts experience one
or more errors per year.  Eighty percent relate to billing.  Attempts
to correct errors often turned out to be difficult and not always
successful. There appears to be some conflict between computer-using
organizations and their public.  Also the role of poor man
agement packages including poor software is indicated.  While most
management systems may be adequate, results of the survey raise
concerns about the timeliness and the number of designs of very
large linked program packages (as EFT for instance).  

CACM May, 1979

Sterling, T.

Errors, systems errors, billing errors, management systems, consumers

2.0 2.1 2.12 2.2 3.50 3.52 3.55 4.19 4.6

CA790503 DH June 5, 1979  3:21 PM

3142	4	3142
3142	4	3142
3179	4	3142
3178	4	3142
3182	4	3142
3183	4	3142
2583	5	3142
3076	5	3142
3142	5	3142
3142	5	3142
3142	5	3142
3178	5	3142
3076	6	3142
3140	6	3142
3142	6	3142
3179	6	3142
3180	6	3142
3181	6	3142
3182	6	3142


************************



Consumer Difficulties With Computerized Transactions: 
An Empirical Investigation

The prevalence with which errors may be encountered by the 
end targets <B>of a</B> computerized process is assessed.  How many and
what type of errors occur?  How easily are they corrected?  What
is the reaction of consumers to errors-to a failure to correct
them?  What can be learned by designers of large management packages
from such data? Results show that with the present state of the
art, approximately 40 percent of individuals (or households) having
average contacts with different types of accounts experience one
or more errors per year.  Eighty percent relate to billing.  Attempts
to correct errors often turned out to be difficult and not always
successful. There appears to be some conflict between computer-using
organizations and their public.  Also the role of poor man
agement packages including poor software is indicated.  While most
management systems may be adequate, results of the survey raise
concerns about the timeliness and the number of designs of very
large linked program packages (as EFT for instance).  

CACM May, 1979

Sterling, T.

Errors, systems errors, billing errors, management systems, consumers

2.0 2.1 2.12 2.2 3.50 3.52 3.55 4.19 4.6

CA790503 DH June 5, 1979  3:21 PM

3142	4	3142
3142	4	3142
3179	4	3142
3178	4	3142
3182	4	3142
3183	4	3142
2583	5	3142
3076	5	3142
3142	5	3142
3142	5	3142
3142	5	3142
3178	5	3142
3076	6	3142
3140	6	3142
3142	6	3142
3179	6	3142
3180	6	3142
3181	6	3142
3182	6	3142


************************



Consumer Difficulties With Computerized Transactions: 
An Empirical Investigation

The prevalence with which errors may be encountered by the 
end targets of a computerized process is assessed.  How many and
what type of errors occur?  How easily are they corrected?  What
is the reaction of consumers to errors-to a failure to correct
them?  What can be learned by designers of large management packages
from such data? Results show that with the present state of the
art, approximately 40 percent of individuals (or households) having
average contacts with different <B>types of</B> accounts experience one
or more errors per year.  Eighty percent relate to billing.  Attempts
to correct errors often turned out to be difficult and not always
successful. There appears to be some conflict between computer-using
organizations and their public.  Also the role of poor man
agement packages including poor software is indicated.  While most
management systems may be adequate, results of the survey raise
concerns about the timeliness and the number of designs of very
large linked program packages (as EFT for instance).  

CACM May, 1979

Sterling, T.

Errors, systems errors, billing errors, management systems, consumers

2.0 2.1 2.12 2.2 3.50 3.52 3.55 4.19 4.6

CA790503 DH June 5, 1979  3:21 PM

3142	4	3142
3142	4	3142
3179	4	3142
3178	4	3142
3182	4	3142
3183	4	3142
2583	5	3142
3076	5	3142
3142	5	3142
3142	5	3142
3142	5	3142
3178	5	3142
3076	6	3142
3140	6	3142
3142	6	3142
3179	6	3142
3180	6	3142
3181	6	3142
3182	6	3142


************************

************************
Document:  CACM-3039.html
************************


On-the-Fly Garbage Collection: An Exercise in Cooperation

As an example of cooperation between sequential
processes with very little mutual interference 
despite frequent manipulations of a large shared data
space,  a technique is developed which allows nearly 
all <B>of the</B> activity needed for garbage detection and collection
to be performed by an additional processor 
operating con-currently with the processor devoted to the
computation proper.  Exclusion and synchronization 
constraints have been kept as weak as could be achieved;
the severe complexities engendered by doing 
so are illustrated. 

CACM November, 1978

Dijkstra, E.
Lamport, L.
Martin, A.
Scholten, C.
Steffens, E.

Multiprocessing, fine-grained interleaving, cooperation
between sequential processes with minimized 
mutual exclusion, program correctness for multiprogramming
tasks, garbage collection 

4.32 4.34 4.35 4.39 5.24

CA781112 DH January 22, 1979  3:24 PM

2838	4	3039
2896	4	3039
2896	4	3039
2972	4	3039
3037	4	3039
3039	4	3039
3039	4	3039
3039	4	3039
3043	4	3039
3073	4	3039
3074	4	3039
3112	4	3039
2723	5	3039
2732	5	3039
2896	5	3039
3039	5	3039
3039	5	3039
3039	5	3039


************************



On-the-Fly Garbage Collection: An Exercise in Cooperation

As an example of cooperation between sequential
processes with very little mutual interference 
despite frequent manipulations <B>of a</B> large shared data
space,  a technique is developed which allows nearly 
all of the activity needed for garbage detection and collection
to be performed by an additional processor 
operating con-currently with the processor devoted to the
computation proper.  Exclusion and synchronization 
constraints have been kept as weak as could be achieved;
the severe complexities engendered by doing 
so are illustrated. 

CACM November, 1978

Dijkstra, E.
Lamport, L.
Martin, A.
Scholten, C.
Steffens, E.

Multiprocessing, fine-grained interleaving, cooperation
between sequential processes with minimized 
mutual exclusion, program correctness for multiprogramming
tasks, garbage collection 

4.32 4.34 4.35 4.39 5.24

CA781112 DH January 22, 1979  3:24 PM

2838	4	3039
2896	4	3039
2896	4	3039
2972	4	3039
3037	4	3039
3039	4	3039
3039	4	3039
3039	4	3039
3043	4	3039
3073	4	3039
3074	4	3039
3112	4	3039
2723	5	3039
2732	5	3039
2896	5	3039
3039	5	3039
3039	5	3039
3039	5	3039


************************

************************
Document:  CACM-2920.html
************************


Game Interpretation of the Deadlock Avoidance Problem

The deadlock avoidance problem may be defined
informally as the determination, from some a 
priori information about the processes, resources, operating
system, etc., of the "safe situations" which 
may be realized without endangering the smooth running
of the system.  When each process specifies its 
future needs by a flowchart of need-defined steps, a global
approach to the phenomenon and its in terpretation 
as a game between the operating system <B>and the</B> processes
allows formalization of risk and safety concepts. 
 The bipartite graph representation of this game may
then be used to construct explicitly the set of safe 
states and to study their properties.

CACM October, 1977

Devillers, R.

operating system, multiprogramming, time-sharing,
resource allocation, deadlock, in terlock, deadly 
embrace, deadlock avoidance, flowchart

4.30 4.32

CA771006 JB December 27, 1977  10:50 AM

2228	4	2920
2280	4	2920
2379	4	2920
2482	4	2920
2740	4	2920
2851	4	2920
2920	4	2920
1877	5	2920
2920	5	2920
2920	5	2920
2920	5	2920


************************



Game Interpretation <B>of the</B> Deadlock Avoidance Problem

The deadlock avoidance problem may be defined
informally as the determination, from some a 
priori information about the processes, resources, operating
system, etc., of the "safe situations" which 
may be realized without endangering the smooth running
of the system.  When each process specifies its 
future needs by a flowchart of need-defined steps, a global
approach to the phenomenon and its in terpretation 
as a game between the operating system and the processes
allows formalization of risk and safety concepts. 
 The bipartite graph representation of this game may
then be used to construct explicitly the set of safe 
states and to study their properties.

CACM October, 1977

Devillers, R.

operating system, multiprogramming, time-sharing,
resource allocation, deadlock, in terlock, deadly 
embrace, deadlock avoidance, flowchart

4.30 4.32

CA771006 JB December 27, 1977  10:50 AM

2228	4	2920
2280	4	2920
2379	4	2920
2482	4	2920
2740	4	2920
2851	4	2920
2920	4	2920
1877	5	2920
2920	5	2920
2920	5	2920
2920	5	2920


************************

************************
Document:  CACM-2634.html
************************


An Evaluation of Statistical Software in the Social Sciences 

Several hundred college and university computer
installations now offer various types of statistical 
packages for general use.  Among those most widely available
are OSIRIS, SPSS, BMD, DATA-TEXT, and TSAR. 
 In order to provide users with a basis for selection
and use, tests were made for each <B>of the</B>se systems, 
and the results are summarized as to cost and performance.

CACM June, 1974

Slysz, W. D.

statistical computation, statistical software,
descriptive statistics, bivariate tables, Pearson 
correlation, regression, factor analysis, one-way analysis of variance

1.3 3.30 4.19 4.22 4.49 5.5

CA740612 JB January 17, 1978  2:54 PM

2634	5	2634
2634	5	2634
2634	5	2634


************************



An Evaluation of Statistical Software in the Social Sciences 

Several hundred college and university computer
installations now offer various <B>types of</B> statistical 
packages for general use.  Among those most widely available
are OSIRIS, SPSS, BMD, DATA-TEXT, and TSAR. 
 In order to provide users with a basis for selection
and use, tests were made for each of these systems, 
and the results are summarized as to cost and performance.

CACM June, 1974

Slysz, W. D.

statistical computation, statistical software,
descriptive statistics, bivariate tables, Pearson 
correlation, regression, factor analysis, one-way analysis of variance

1.3 3.30 4.19 4.22 4.49 5.5

CA740612 JB January 17, 1978  2:54 PM

2634	5	2634
2634	5	2634
2634	5	2634


************************



An Evaluation of Statistical Software in the Social Sciences 

Several hundred college and university computer
installations now offer various types of statistical 
packages for general use.  Among those most widely available
are OSIRIS, SPSS, BMD, DATA-TEXT, and TSAR. 
 In order to provide users with a basis for selection
and use, tests were made for each of these systems, 
<B>and the</B> results are summarized as to cost and performance.

CACM June, 1974

Slysz, W. D.

statistical computation, statistical software,
descriptive statistics, bivariate tables, Pearson 
correlation, regression, factor analysis, one-way analysis of variance

1.3 3.30 4.19 4.22 4.49 5.5

CA740612 JB January 17, 1978  2:54 PM

2634	5	2634
2634	5	2634
2634	5	2634


************************

************************
Document:  CACM-3164.html
************************


Progressive Acyclic Digraphs-A Tool for Database Integrity

A progressive acyclic digraph (PAD) algorithm accepts are requests and
maintains a graph in an acyclic state.  When a request creates a cycle,
nodes are, "detached" until the new are can be entered acyclically
This process is important in certain areas of database implementation
in which there are constraints on the permissible sequences
<B>of a</B>ctions. Two PAD algorithms are presented; one uses a simple
path matrix representation and the other uses a list with an
"artificial gradient."  Experiments suggest that for large N the second
is considerably faster, though both are asymptotically O(NR),
where N is the number of nodes and R is the expected number
of nodes reachable along paths from any given node.

CACM September, 1979

Hansen, W.

List processing, data structures, topological sort,
acyclic digraph, database integrity, network, deadlock

4.34 5.32 4.33

CA790905 DB January 14, 1980  11:56 AM

3164	4	3164
1712	5	3164
3164	5	3164
3164	5	3164
3164	5	3164


************************



Progressive Acyclic Digraphs-A Tool for Database Integrity

A progressive acyclic digraph (PAD) algorithm accepts are requests and
maintains a graph in an acyclic state.  When a request creates a cycle,
nodes are, "detached" until the new are can be entered acyclically
This process is important in certain areas of database implementation
in which there are constraints on the permissible sequences
of actions. Two PAD algorithms are presented; one uses a simple
path matrix representation <B>and the</B> other uses a list with an
"artificial gradient."  Experiments suggest that for large N the second
is considerably faster, though both are asymptotically O(NR),
where N is the number of nodes and R is the expected number
of nodes reachable along paths from any given node.

CACM September, 1979

Hansen, W.

List processing, data structures, topological sort,
acyclic digraph, database integrity, network, deadlock

4.34 5.32 4.33

CA790905 DB January 14, 1980  11:56 AM

3164	4	3164
1712	5	3164
3164	5	3164
3164	5	3164
3164	5	3164


************************



Progressive Acyclic Digraphs-A Tool for Database Integrity

A progressive acyclic digraph (PAD) algorithm accepts are requests and
maintains a graph <B>in a</B>n acyclic state.  When a request creates a cycle,
nodes are, "detached" until the new are can be entered acyclically
This process is important in certain areas of database implementation
in which there are constraints on the permissible sequences
of actions. Two PAD algorithms are presented; one uses a simple
path matrix representation and the other uses a list with an
"artificial gradient."  Experiments suggest that for large N the second
is considerably faster, though both are asymptotically O(NR),
where N is the number of nodes and R is the expected number
of nodes reachable along paths from any given node.

CACM September, 1979

Hansen, W.

List processing, data structures, topological sort,
acyclic digraph, database integrity, network, deadlock

4.34 5.32 4.33

CA790905 DB January 14, 1980  11:56 AM

3164	4	3164
1712	5	3164
3164	5	3164
3164	5	3164
3164	5	3164


************************



Progressive Acyclic Digraphs-A Tool for Database Integrity

A progressive acyclic digraph (PAD) algorithm accepts are requests and
maintains a graph in an acyclic state.  When a request creates a cycle,
nodes are, "detached" until the new are can be entered acyclically
This process is important in certain areas of database implementation
in which there are constraints on the permissible sequences
of actions. Two PAD algorithms are presented; one uses a simple
path matrix representation and the other uses a list with an
"artificial gradient."  Experiments suggest that for large N the second
is considerably faster, though both are asymptotically O(NR),
where N <B>is the</B> number of nodes and R is the expected number
of nodes reachable along paths from any given node.

CACM September, 1979

Hansen, W.

List processing, data structures, topological sort,
acyclic digraph, database integrity, network, deadlock

4.34 5.32 4.33

CA790905 DB January 14, 1980  11:56 AM

3164	4	3164
1712	5	3164
3164	5	3164
3164	5	3164
3164	5	3164


************************

************************
Document:  CACM-1869.html
************************


Block Structures, Indirect Addressing, and Garbage Collection

Programming languages have included explicit
or implicit block structures to provide a naming 
convenience for the programmer.  However, when indirect
addressing is used, as in SNOBOL, naming constraints 
may be introduced.  Two modifications to SNOBOL are described,
resulting in two desirable consequences: 
(1) naming constraints disappear even when there is
indirect addressing within function definitions; 
and (2) there <B>is a</B> significant saving in the number of
calls to the garbage collector, because some garbage 
is collected, at little expense, each time a function
returns to its calling program.  These modifications 
have been implemented as an extension to a SNOBOL dialect.

CACM July, 1969

Kain, R. Y.

block structures, indirect addressing,
garbage collection, local names, SNOBOL

4.22

CA690711 JB February 15, 1978  6:49 PM

1869	4	1869
1869	4	1869
2513	4	1869
2665	4	1869
2723	4	1869
2855	4	1869
3106	4	1869
1549	5	1869
1570	5	1869
1869	5	1869
1869	5	1869
1869	5	1869
2060	5	1869
2770	5	1869
1380	6	1869
1421	6	1869
1469	6	1869
1477	6	1869
1491	6	1869
1786	6	1869
210	6	1869
1869	6	1869
1869	6	1869
1973	6	1869
1992	6	1869
2018	6	1869
2109	6	1869
2110	6	1869
2673	6	1869


************************

************************
Document:  CACM-0409.html
************************


CL-1, An Environment for a Compiler

A flexible, large-scale programming system to
facilitate the solution of information processing 
problems and to provide intercommunication between programs
and/or programmers has been developed and 
realized on the IBM 709/7090 computer.  The system is
based on a master file concept and has provisions 
for accepting, storing, and retrieving both descriptions
and instances of large and complex data sets, 
as well as algorithms defined on these data sets.  Both
data and algorithms may be expressed <B>in a</B> family 
of command and descriptive languages.  The concept
of distinct data descriptions and the content and 
use of such descriptions are discussed in some detail.

CACM January, 1961

Cheatham Jr., T. E.
Collins Jr., G. O.
Leonard, G. F.

CA610105 JB March 17, 1978  1:26 AM

409	5	409
409	5	409
409	5	409
657	5	409
279	6	409
409	6	409


************************



CL-1, An Environment for a Compiler

A flexible, large-scale programming system to
facilitate the solution of information processing 
problems and to provide intercommunication between programs
and/or programmers has been developed and 
realized on the IBM 709/7090 computer.  The system is
based on a master file concept and has provisions 
for accepting, storing, and retrieving both descriptions
and instances of large and complex data sets, 
as well as algorithms defined on these data sets.  Both
data and algorithms may be expressed in a family 
of command and descriptive languages.  The concept
of distinct data descriptions <B>and the</B> content and 
use of such descriptions are discussed in some detail.

CACM January, 1961

Cheatham Jr., T. E.
Collins Jr., G. O.
Leonard, G. F.

CA610105 JB March 17, 1978  1:26 AM

409	5	409
409	5	409
409	5	409
657	5	409
279	6	409
409	6	409


************************



CL-1, An Environment for a Compiler

A flexible, large-scale programming system to
facilitate the solution of information processing 
problems and to provide intercommunication between programs
and/or programmers has been developed and 
realized on the IBM 709/7090 computer.  The <B>system is</B>
based on a master file concept and has provisions 
for accepting, storing, and retrieving both descriptions
and instances of large and complex data sets, 
as well as algorithms defined on these data sets.  Both
data and algorithms may be expressed in a family 
of command and descriptive languages.  The concept
of distinct data descriptions and the content and 
use of such descriptions are discussed in some detail.

CACM January, 1961

Cheatham Jr., T. E.
Collins Jr., G. O.
Leonard, G. F.

CA610105 JB March 17, 1978  1:26 AM

409	5	409
409	5	409
409	5	409
657	5	409
279	6	409
409	6	409


************************

************************
Document:  CACM-2580.html
************************


A Method for Composing Simple Traditional Music by Computer

A method is described for composing musical
rounds by computer.  This method uses some music 
theory plus additional heuristics.  Fundamental to the
method is a set of productions together with sets 
of applicability rules and weight rules which operate
on the productions deciding when and to what extent 
they are available for use.  Several rounds generated
by the computer implementation <B>of the</B> method are 
presented.  Generally, the resultant music sounds mediocre
to the professional although usually pleasing 
to the layman.  It appears that full-blown music theory
is not needed for rounds--all the hardware required 
for structural levels is not necessary for these pieces.
 The author has tried to address both musicians 
and computer scientists.

CACM November, 1974

Rader, G. M.

artificial intelligence, heuristic programming,
models of cognitive processes, computer music, 
computer composition, music theory, formal languages, probabilistic grammars

3.44 3.65 5.23

CA741104 JB January 16, 1978  10:35 AM

2580	5	2580
2580	5	2580
2580	5	2580


************************



A Method for Composing Simple Traditional Music by Computer

A method is described for composing musical
rounds by computer.  This method uses some music 
theory plus additional heuristics.  Fundamental to the
method is a set of productions together with sets 
<B>of a</B>pplicability rules and weight rules which operate
on the productions deciding when and to what extent 
they are available for use.  Several rounds generated
by the computer implementation of the method are 
presented.  Generally, the resultant music sounds mediocre
to the professional although usually pleasing 
to the layman.  It appears that full-blown music theory
is not needed for rounds--all the hardware required 
for structural levels is not necessary for these pieces.
 The author has tried to address both musicians 
and computer scientists.

CACM November, 1974

Rader, G. M.

artificial intelligence, heuristic programming,
models of cognitive processes, computer music, 
computer composition, music theory, formal languages, probabilistic grammars

3.44 3.65 5.23

CA741104 JB January 16, 1978  10:35 AM

2580	5	2580
2580	5	2580
2580	5	2580


************************



A Method for Composing Simple Traditional Music by Computer

A method is described for composing musical
rounds by computer.  This method uses some music 
theory plus additional heuristics.  Fundamental to the
method <B>is a</B> set of productions together with sets 
of applicability rules and weight rules which operate
on the productions deciding when and to what extent 
they are available for use.  Several rounds generated
by the computer implementation of the method are 
presented.  Generally, the resultant music sounds mediocre
to the professional although usually pleasing 
to the layman.  It appears that full-blown music theory
is not needed for rounds--all the hardware required 
for structural levels is not necessary for these pieces.
 The author has tried to address both musicians 
and computer scientists.

CACM November, 1974

Rader, G. M.

artificial intelligence, heuristic programming,
models of cognitive processes, computer music, 
computer composition, music theory, formal languages, probabilistic grammars

3.44 3.65 5.23

CA741104 JB January 16, 1978  10:35 AM

2580	5	2580
2580	5	2580
2580	5	2580


************************

************************
Document:  CACM-2850.html
************************


Symbolic Execution and Program Testing

This paper describes the symbolic execution of
programs.  Instead of supplying the normal inputs 
to a program (e.g. numbers) one supplies symbols representing
arbitrary values.  The execution proceeds 
as in a normal execution except that values may be symbolic
formulas over the input symbols.  The difficult, 
yet interesting issues arise during the symbolic execution
of conditional branch type statements.  A 
particular system called EFFIGY which provides symbolic
execution for program testing and debugging is 
also described.  It interpretively executes programs written
in a simple PL/I style programming language. 
 It includes many standard debugging features, the ability
to manage and to prove things about symbolic 
expressions, a simple program testing manager, and a program
verifier.  A brief discussion <B>of the</B> relationship 
between symbolic execution and program proving is also included.

CACM July, 1976

King, J. C.

symbolic execution, program testing, program debugging,
program proving, program verification, 
symbolic interpretation

4.13 5.21 5.24

CA760703 JB January 4, 1978  12:59 PM

2850	5	2850
2850	5	2850
2850	5	2850
3080	5	2850
210	6	2850
2850	6	2850


************************



Symbolic Execution and Program Testing

This paper describes the symbolic execution of
programs.  Instead of supplying the normal inputs 
to a program (e.g. numbers) one supplies symbols representing
arbitrary values.  The execution proceeds 
as in a normal execution except that values may be symbolic
formulas over the input symbols.  The difficult, 
yet interesting issues arise during the symbolic execution
of conditional branch type statements.  A 
particular system called EFFIGY which provides symbolic
execution for program testing and debugging is 
also described.  It interpretively executes programs written
in a simple PL/I style programming language. 
 It includes many standard debugging features, the ability
to manage and to prove things about symbolic 
expressions, a simple program testing manager, and a program
verifier.  A brief discussion of <B>the relationship</B> 
between symbolic execution and program proving is also included.

CACM July, 1976

King, J. C.

symbolic execution, program testing, program debugging,
program proving, program verification, 
symbolic interpretation

4.13 5.21 5.24

CA760703 JB January 4, 1978  12:59 PM

2850	5	2850
2850	5	2850
2850	5	2850
3080	5	2850
210	6	2850
2850	6	2850


************************



Symbolic Execution and Program Testing

This paper describes the symbolic execution of
programs.  Instead of supplying the normal inputs 
to a program (e.g. numbers) one supplies symbols representing
arbitrary values.  The execution proceeds 
as in a normal execution except that values may be symbolic
formulas over the input symbols.  The difficult, 
yet interesting issues arise during the symbolic execution
of conditional branch type statements.  A 
particular system called EFFIGY which provides symbolic
execution for program testing and debugging is 
also described.  It interpretively executes programs written
in a simple PL/I style programming language. 
 It includes many standard debugging features, the ability
to manage and to prove things about symbolic 
expressions, a simple program testing manager, and a program
verifier.  A brief discussion of the relationship 
between symbolic execution and program proving <B>is a</B>lso included.

CACM July, 1976

King, J. C.

symbolic execution, program testing, program debugging,
program proving, program verification, 
symbolic interpretation

4.13 5.21 5.24

CA760703 JB January 4, 1978  12:59 PM

2850	5	2850
2850	5	2850
2850	5	2850
3080	5	2850
210	6	2850
2850	6	2850


************************



Symbolic Execution and Program Testing

This paper describes the symbolic execution of
programs.  Instead of supplying the normal inputs 
to a program (e.g. numbers) one supplies symbols representing
arbitrary values.  The execution proceeds 
as <B>in a</B> normal execution except that values may be symbolic
formulas over the input symbols.  The difficult, 
yet interesting issues arise during the symbolic execution
of conditional branch type statements.  A 
particular system called EFFIGY which provides symbolic
execution for program testing and debugging is 
also described.  It interpretively executes programs written
in a simple PL/I style programming language. 
 It includes many standard debugging features, the ability
to manage and to prove things about symbolic 
expressions, a simple program testing manager, and a program
verifier.  A brief discussion of the relationship 
between symbolic execution and program proving is also included.

CACM July, 1976

King, J. C.

symbolic execution, program testing, program debugging,
program proving, program verification, 
symbolic interpretation

4.13 5.21 5.24

CA760703 JB January 4, 1978  12:59 PM

2850	5	2850
2850	5	2850
2850	5	2850
3080	5	2850
210	6	2850
2850	6	2850


************************

************************
Document:  CACM-2632.html
************************


HYDRA: The Kernel of a Multiprocessor Operating System

This paper describes the design philosophy of
HYDRA-the kernel of an operating system for C.mmp, 
the Carnegie-Mellon Multi-Mini-Processor.  This philosophy
is realized through the introduction of a 
generalized notion of "resource", both physical and virtual,
called an "object".  Mechanisms are presented 
for dealing with objects, including the creation of new
types, specification of new operations applicable 
to a given type, sharing, and protection of any reference
to a given object against improper application 
of any of the operations defined with respect to that
type of object.  The mechanisms provide a coherent 
basis for extension of the system in two directions: the
introduction of new facilities, <B>and the</B> creation 
of highly secure systems. 

CACM June, 1974

Wulf, W.
Cohen, E.
Corwin, W.
Jones, A.
Levin, R.
Pierson, C.
Pollack, F.

operating system, kernel, nucleus, protection, security

4.3 6.2

CA740614 JB January 17, 1978  2:40 PM

1458	4	2632
1523	4	2632
1603	4	2632
1698	4	2632
1747	4	2632
1748	4	2632
1828	4	2632
1854	4	2632
1854	4	2632
1877	4	2632
1877	4	2632
1960	4	2632
1960	4	2632
2150	4	2632
2317	4	2632
2319	4	2632
2319	4	2632
2377	4	2632
2377	4	2632
2378	4	2632
2378	4	2632
2342	4	2632
2376	4	2632
2379	4	2632
2320	4	2632
2424	4	2632
2482	4	2632
2497	4	2632
2558	4	2632
2618	4	2632
2625	4	2632
2632	4	2632
2632	4	2632
2632	4	2632
2704	4	2632
2723	4	2632
2738	4	2632
2738	4	2632
2740	4	2632
2740	4	2632
2741	4	2632
2840	4	2632
2867	4	2632
2868	4	2632
2941	4	2632
3105	4	2632
3127	4	2632
3144	4	2632
3184	4	2632
1471	5	2632
1749	5	2632
2080	5	2632
2632	5	2632
2632	5	2632
2632	5	2632
2868	5	2632
2870	5	2632
2876	5	2632
3105	5	2632
3144	5	2632
953	6	2632
1471	6	2632
1471	6	2632
2080	6	2632
2298	6	2632
2377	6	2632
2377	6	2632
2380	6	2632
2491	6	2632
2558	6	2632
2597	6	2632
2624	6	2632
2625	6	2632
2625	6	2632
2625	6	2632
2632	6	2632
2632	6	2632
2632	6	2632
2632	6	2632
2632	6	2632
2685	6	2632
2868	6	2632
2939	6	2632
3068	6	2632


************************



HYDRA: The Kernel of a Multiprocessor Operating System

This paper describes the design philosophy of
HYDRA-the kernel of an operating system for C.mmp, 
the Carnegie-Mellon Multi-Mini-Processor.  This philosophy
is realized through the introduction of a 
generalized notion of "resource", both physical and virtual,
called an "object".  Mechanisms are presented 
for dealing with objects, including the creation of new
types, specification of new operations applicable 
to a given type, sharing, and protection of any reference
to a given object against improper application 
of any <B>of the</B> operations defined with respect to that
type of object.  The mechanisms provide a coherent 
basis for extension of the system in two directions: the
introduction of new facilities, and the creation 
of highly secure systems. 

CACM June, 1974

Wulf, W.
Cohen, E.
Corwin, W.
Jones, A.
Levin, R.
Pierson, C.
Pollack, F.

operating system, kernel, nucleus, protection, security

4.3 6.2

CA740614 JB January 17, 1978  2:40 PM

1458	4	2632
1523	4	2632
1603	4	2632
1698	4	2632
1747	4	2632
1748	4	2632
1828	4	2632
1854	4	2632
1854	4	2632
1877	4	2632
1877	4	2632
1960	4	2632
1960	4	2632
2150	4	2632
2317	4	2632
2319	4	2632
2319	4	2632
2377	4	2632
2377	4	2632
2378	4	2632
2378	4	2632
2342	4	2632
2376	4	2632
2379	4	2632
2320	4	2632
2424	4	2632
2482	4	2632
2497	4	2632
2558	4	2632
2618	4	2632
2625	4	2632
2632	4	2632
2632	4	2632
2632	4	2632
2704	4	2632
2723	4	2632
2738	4	2632
2738	4	2632
2740	4	2632
2740	4	2632
2741	4	2632
2840	4	2632
2867	4	2632
2868	4	2632
2941	4	2632
3105	4	2632
3127	4	2632
3144	4	2632
3184	4	2632
1471	5	2632
1749	5	2632
2080	5	2632
2632	5	2632
2632	5	2632
2632	5	2632
2868	5	2632
2870	5	2632
2876	5	2632
3105	5	2632
3144	5	2632
953	6	2632
1471	6	2632
1471	6	2632
2080	6	2632
2298	6	2632
2377	6	2632
2377	6	2632
2380	6	2632
2491	6	2632
2558	6	2632
2597	6	2632
2624	6	2632
2625	6	2632
2625	6	2632
2625	6	2632
2632	6	2632
2632	6	2632
2632	6	2632
2632	6	2632
2632	6	2632
2685	6	2632
2868	6	2632
2939	6	2632
3068	6	2632


************************



HYDRA: The Kernel of a Multiprocessor Operating System

This paper describes the design philosophy of
HYDRA-the kernel of an operating system for C.mmp, 
the Carnegie-Mellon Multi-Mini-Processor.  This philosophy
is realized through the introduction of a 
generalized <B>notion of</B> "resource", both physical and virtual,
called an "object".  Mechanisms are presented 
for dealing with objects, including the creation of new
types, specification of new operations applicable 
to a given type, sharing, and protection of any reference
to a given object against improper application 
of any of the operations defined with respect to that
type of object.  The mechanisms provide a coherent 
basis for extension of the system in two directions: the
introduction of new facilities, and the creation 
of highly secure systems. 

CACM June, 1974

Wulf, W.
Cohen, E.
Corwin, W.
Jones, A.
Levin, R.
Pierson, C.
Pollack, F.

operating system, kernel, nucleus, protection, security

4.3 6.2

CA740614 JB January 17, 1978  2:40 PM

1458	4	2632
1523	4	2632
1603	4	2632
1698	4	2632
1747	4	2632
1748	4	2632
1828	4	2632
1854	4	2632
1854	4	2632
1877	4	2632
1877	4	2632
1960	4	2632
1960	4	2632
2150	4	2632
2317	4	2632
2319	4	2632
2319	4	2632
2377	4	2632
2377	4	2632
2378	4	2632
2378	4	2632
2342	4	2632
2376	4	2632
2379	4	2632
2320	4	2632
2424	4	2632
2482	4	2632
2497	4	2632
2558	4	2632
2618	4	2632
2625	4	2632
2632	4	2632
2632	4	2632
2632	4	2632
2704	4	2632
2723	4	2632
2738	4	2632
2738	4	2632
2740	4	2632
2740	4	2632
2741	4	2632
2840	4	2632
2867	4	2632
2868	4	2632
2941	4	2632
3105	4	2632
3127	4	2632
3144	4	2632
3184	4	2632
1471	5	2632
1749	5	2632
2080	5	2632
2632	5	2632
2632	5	2632
2632	5	2632
2868	5	2632
2870	5	2632
2876	5	2632
3105	5	2632
3144	5	2632
953	6	2632
1471	6	2632
1471	6	2632
2080	6	2632
2298	6	2632
2377	6	2632
2377	6	2632
2380	6	2632
2491	6	2632
2558	6	2632
2597	6	2632
2624	6	2632
2625	6	2632
2625	6	2632
2625	6	2632
2632	6	2632
2632	6	2632
2632	6	2632
2632	6	2632
2632	6	2632
2685	6	2632
2868	6	2632
2939	6	2632
3068	6	2632


************************



HYDRA: The Kernel of a Multiprocessor Operating System

This paper describes the design philosophy of
HYDRA-the kernel of an operating system for C.mmp, 
the Carnegie-Mellon Multi-Mini-Processor.  This philosophy
is realized through the introduction of a 
generalized notion of "resource", both physical and virtual,
called an "object".  Mechanisms are presented 
for dealing with objects, including the creation of new
types, specification of new operations applicable 
to a given type, sharing, and protection of any reference
to a given object against improper application 
of any of the operations defined with respect to that
<B>type of</B> object.  The mechanisms provide a coherent 
basis for extension of the system in two directions: the
introduction of new facilities, and the creation 
of highly secure systems. 

CACM June, 1974

Wulf, W.
Cohen, E.
Corwin, W.
Jones, A.
Levin, R.
Pierson, C.
Pollack, F.

operating system, kernel, nucleus, protection, security

4.3 6.2

CA740614 JB January 17, 1978  2:40 PM

1458	4	2632
1523	4	2632
1603	4	2632
1698	4	2632
1747	4	2632
1748	4	2632
1828	4	2632
1854	4	2632
1854	4	2632
1877	4	2632
1877	4	2632
1960	4	2632
1960	4	2632
2150	4	2632
2317	4	2632
2319	4	2632
2319	4	2632
2377	4	2632
2377	4	2632
2378	4	2632
2378	4	2632
2342	4	2632
2376	4	2632
2379	4	2632
2320	4	2632
2424	4	2632
2482	4	2632
2497	4	2632
2558	4	2632
2618	4	2632
2625	4	2632
2632	4	2632
2632	4	2632
2632	4	2632
2704	4	2632
2723	4	2632
2738	4	2632
2738	4	2632
2740	4	2632
2740	4	2632
2741	4	2632
2840	4	2632
2867	4	2632
2868	4	2632
2941	4	2632
3105	4	2632
3127	4	2632
3144	4	2632
3184	4	2632
1471	5	2632
1749	5	2632
2080	5	2632
2632	5	2632
2632	5	2632
2632	5	2632
2868	5	2632
2870	5	2632
2876	5	2632
3105	5	2632
3144	5	2632
953	6	2632
1471	6	2632
1471	6	2632
2080	6	2632
2298	6	2632
2377	6	2632
2377	6	2632
2380	6	2632
2491	6	2632
2558	6	2632
2597	6	2632
2624	6	2632
2625	6	2632
2625	6	2632
2625	6	2632
2632	6	2632
2632	6	2632
2632	6	2632
2632	6	2632
2632	6	2632
2685	6	2632
2868	6	2632
2939	6	2632
3068	6	2632


************************



HYDRA: The Kernel <B>of a</B> Multiprocessor Operating System

This paper describes the design philosophy of
HYDRA-the kernel of an operating system for C.mmp, 
the Carnegie-Mellon Multi-Mini-Processor.  This philosophy
is realized through the introduction of a 
generalized notion of "resource", both physical and virtual,
called an "object".  Mechanisms are presented 
for dealing with objects, including the creation of new
types, specification of new operations applicable 
to a given type, sharing, and protection of any reference
to a given object against improper application 
of any of the operations defined with respect to that
type of object.  The mechanisms provide a coherent 
basis for extension of the system in two directions: the
introduction of new facilities, and the creation 
of highly secure systems. 

CACM June, 1974

Wulf, W.
Cohen, E.
Corwin, W.
Jones, A.
Levin, R.
Pierson, C.
Pollack, F.

operating system, kernel, nucleus, protection, security

4.3 6.2

CA740614 JB January 17, 1978  2:40 PM

1458	4	2632
1523	4	2632
1603	4	2632
1698	4	2632
1747	4	2632
1748	4	2632
1828	4	2632
1854	4	2632
1854	4	2632
1877	4	2632
1877	4	2632
1960	4	2632
1960	4	2632
2150	4	2632
2317	4	2632
2319	4	2632
2319	4	2632
2377	4	2632
2377	4	2632
2378	4	2632
2378	4	2632
2342	4	2632
2376	4	2632
2379	4	2632
2320	4	2632
2424	4	2632
2482	4	2632
2497	4	2632
2558	4	2632
2618	4	2632
2625	4	2632
2632	4	2632
2632	4	2632
2632	4	2632
2704	4	2632
2723	4	2632
2738	4	2632
2738	4	2632
2740	4	2632
2740	4	2632
2741	4	2632
2840	4	2632
2867	4	2632
2868	4	2632
2941	4	2632
3105	4	2632
3127	4	2632
3144	4	2632
3184	4	2632
1471	5	2632
1749	5	2632
2080	5	2632
2632	5	2632
2632	5	2632
2632	5	2632
2868	5	2632
2870	5	2632
2876	5	2632
3105	5	2632
3144	5	2632
953	6	2632
1471	6	2632
1471	6	2632
2080	6	2632
2298	6	2632
2377	6	2632
2377	6	2632
2380	6	2632
2491	6	2632
2558	6	2632
2597	6	2632
2624	6	2632
2625	6	2632
2625	6	2632
2625	6	2632
2632	6	2632
2632	6	2632
2632	6	2632
2632	6	2632
2632	6	2632
2685	6	2632
2868	6	2632
2939	6	2632
3068	6	2632


************************

