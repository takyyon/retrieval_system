Snippets for the query:  List all articles dealing with data types in the following languages: that are referenced frequently in papers on the above languages (e.g. catch any languages with interesting type structures that I might have missed).
************************
Total Hits:  96
************************

************************
Document:  CACM-2958.html
************************


Abstract Data Types and the Development of Data Structures

Abstract <B>data types</B> can play a significant role
in the development of software that is reliable, 
efficient, and flexible.  This paper presents and discusses
the application of an algebraic technique 
for the specification of abstract data types.  Among
the examples presented is a top-down development 
of a symbol table for a block structured language; a discussion
of the proof of its correctness is given. 
 The paper also contains a brief discussion of the problems
involved in constructing algebraic specifications 
that are both consistent and complete.

CACM June, 1977

Guttag, J.

abstract data type, correctness proof, data type,
data structure, specification, software specification

4.34 5.24

CA770605 JB December 29, 1977  1:17 AM

2704	4	2958
2738	4	2958
2866	4	2958
2869	4	2958
2941	4	2958
2958	4	2958
3004	4	2958
3030	4	2958
2356	5	2958
2958	5	2958
2958	5	2958
2958	5	2958
3030	5	2958
3031	5	2958
3049	5	2958
2247	6	2958
2356	6	2958
2457	6	2958
2651	6	2958
2939	6	2958
2956	6	2958
2958	6	2958
2958	6	2958
2958	6	2958
2957	6	2958
2960	6	2958
2972	6	2958


************************



Abstract Data Types and the Development of Data Structures

Abstract data types can play a significant role
<B>in the</B> development of software that is reliable, 
efficient, and flexible.  This paper presents and discusses
the application of an algebraic technique 
for the specification of abstract data types.  Among
the examples presented is a top-down development 
of a symbol table for a block structured language; a discussion
of the proof of its correctness is given. 
 The paper also contains a brief discussion of the problems
involved in constructing algebraic specifications 
that are both consistent and complete.

CACM June, 1977

Guttag, J.

abstract data type, correctness proof, data type,
data structure, specification, software specification

4.34 5.24

CA770605 JB December 29, 1977  1:17 AM

2704	4	2958
2738	4	2958
2866	4	2958
2869	4	2958
2941	4	2958
2958	4	2958
3004	4	2958
3030	4	2958
2356	5	2958
2958	5	2958
2958	5	2958
2958	5	2958
3030	5	2958
3031	5	2958
3049	5	2958
2247	6	2958
2356	6	2958
2457	6	2958
2651	6	2958
2939	6	2958
2956	6	2958
2958	6	2958
2958	6	2958
2958	6	2958
2957	6	2958
2960	6	2958
2972	6	2958


************************



Abstract Data Types and the Development of Data Structures

Abstract data types can play a significant role
in the development of software that is reliable, 
efficient, and flexible.  This paper presents and discusses
the application of an algebraic technique 
for the specification of abstract data types.  Among
the examples presented is a top-down development 
of a symbol table for a block structured language; a discussion
of the proof of its correctness is given. 
 The paper also contains a brief discussion of the problems
involved in constructing algebraic specifications 
<B>that are</B> both consistent and complete.

CACM June, 1977

Guttag, J.

abstract data type, correctness proof, data type,
data structure, specification, software specification

4.34 5.24

CA770605 JB December 29, 1977  1:17 AM

2704	4	2958
2738	4	2958
2866	4	2958
2869	4	2958
2941	4	2958
2958	4	2958
3004	4	2958
3030	4	2958
2356	5	2958
2958	5	2958
2958	5	2958
2958	5	2958
3030	5	2958
3031	5	2958
3049	5	2958
2247	6	2958
2356	6	2958
2457	6	2958
2651	6	2958
2939	6	2958
2956	6	2958
2958	6	2958
2958	6	2958
2958	6	2958
2957	6	2958
2960	6	2958
2972	6	2958


************************

************************
Document:  CACM-2406.html
************************


A Data Definition and Mapping Language

A data definition language i sa declarative
computer language for specifying data structures. 
 Most data definition languages concentrate on the declaration
of logical data structures with little 
concern for how these structures are physically realized
on a computer system.  However, the need for 
data definition languages which describe both the logical
and physical aspects of data is increasingly 
apparent.  Such languages will be a key systems, as well
as in advanced data management systems and distributed 
data bases.  This paper reviews past work <B>in the</B> data
definition language for describing both logical 
and physical aspects of data.  Applications of these
"generalized" data definition languages are also 
discussed.

CACM December, 1973

Sibley, E. H.
Taylor, R. W.

data definition language, data and storage structure,
data translation, data base management systems, 
file translation

3.51 3.70 3.73 4.29 4.82

CA731202 JB January 19, 1978  2:58 PM

2155	4	2406
2406	4	2406
2710	4	2406
2715	4	2406
2716	4	2406
2717	4	2406
2718	4	2406
2765	4	2406
2817	4	2406
2888	4	2406
2901	4	2406
2957	4	2406
2959	4	2406
2965	4	2406
3087	4	2406
3154	4	2406
2046	5	2406
2406	5	2406
2406	5	2406
2406	5	2406
2717	5	2406
2046	6	2406
2406	6	2406


************************



A Data Definition and Mapping Language

A data definition language i sa declarative
computer language for specifying data structures. 
 Most data definition languages concentrate <B>on the</B> declaration
of logical data structures with little 
concern for how these structures are physically realized
on a computer system.  However, the need for 
data definition languages which describe both the logical
and physical aspects of data is increasingly 
apparent.  Such languages will be a key systems, as well
as in advanced data management systems and distributed 
data bases.  This paper reviews past work in the data
definition language for describing both logical 
and physical aspects of data.  Applications of these
"generalized" data definition languages are also 
discussed.

CACM December, 1973

Sibley, E. H.
Taylor, R. W.

data definition language, data and storage structure,
data translation, data base management systems, 
file translation

3.51 3.70 3.73 4.29 4.82

CA731202 JB January 19, 1978  2:58 PM

2155	4	2406
2406	4	2406
2710	4	2406
2715	4	2406
2716	4	2406
2717	4	2406
2718	4	2406
2765	4	2406
2817	4	2406
2888	4	2406
2901	4	2406
2957	4	2406
2959	4	2406
2965	4	2406
3087	4	2406
3154	4	2406
2046	5	2406
2406	5	2406
2406	5	2406
2406	5	2406
2717	5	2406
2046	6	2406
2406	6	2406


************************

************************
Document:  CACM-2177.html
************************


An Algorithm for the Blocks and Cutnodes of a Graph

An efficient method is presented for finding
blocks and cutnodes of an arbitrary undirected 
graph.  The graph may be represented either (i) as an
ordered list of edges or (ii) as a packed adjacency 
matrix.  If w denotes the word length of the machine
employed, the storage (in machine words) required 
for a graph with n nodes and m edges increases essentially
as 2(m+n) in case (i), or (n^2)/win case 
(ii).  A spanning tree with labeled edges is grown,
two edges finally bearing different labels if and 
only if they belong to different blocks.  For both representations
the time required to analyze a graph 
on n nodes increases as n^G where G depends <B>on the</B> type
of graph, 1 <= G <= 2, and both bounds are attained. 
 Values of G are derived for each of several suitable
families of test graphs, generated by an extension 
of the web grammar approach.  The algorithm is compared
in detail with that proposed by Read for which 
1 <= G <= 3.

CACM July, 1971

Paton, K.

algorithm, block, block-cutpoint-tree, cutnode, fundamental
cycle set, graph, lobe, lobe decomposition 
graph, separable, spanning tree, web grammar

5.32

CA710705 JB February 3, 1978  8:58 AM

1961	4	2177
2177	4	2177
2763	4	2177
1847	5	2177
2177	5	2177
2177	5	2177
2177	5	2177
2490	5	2177
2177	6	2177


************************

************************
Document:  CACM-1847.html
************************


An Algorithm for Finding a Fundamental Set of Cycles of a Graph

A fast method is presented for finding a fundamental
set of cycles for an undirected finite 
graph.  A spanning tree is grown and the vertices examined
in turn, unexamined vertices being stored 
in a pushdown list to await examination.  One stage
in the process is to take the top element v of the 
pushdown list and examine it, i.e. inspect all those
edges (v,z) of the graph for which z has not yet 
been examined.  If z is already in the tree, a fundamental
cycle is added; if not, the edge (v,z) is 
placed in the tree.  There is exactly one such stage
for each of the n vertices of the graph.  For large 
n, the store required in creases as n^2 and the time as
n^g where g depends <B>on the</B> type of graph involved. 
 g is bounded below by 2 and above by 3, and it is shown
that both bounds are attained.  In terms of 
storage our algorithm is similar to that of Gotlieb and
Corneil and superior to that of Welch; in terms 
of speed it is similar to that of Welch and superior
to that of Gotlieb and Corneil.  Testsshow our 
algorithm to be remarkably efficient (g=2) on random graphs.

CACM September, 1969

Paton, K.

fundamental cycle set, graph, algorithm, cycle, spanning tree

5.32

CA690909 JB February 15, 1978  4:29 PM

1847	4	1847
1961	4	1847
2052	4	1847
1504	5	1847
1847	5	1847
1847	5	1847
1847	5	1847
1961	5	1847
2177	5	1847
2763	5	1847
1369	6	1847
1504	6	1847
1847	6	1847
1847	6	1847
1847	6	1847


************************



An Algorithm for Finding a Fundamental Set of Cycles of a Graph

A fast method is presented for finding a fundamental
set of cycles for an undirected finite 
graph.  A spanning tree is grown and the vertices examined
in turn, unexamined vertices being stored 
in a pushdown list to await examination.  One stage
<B>in the</B> process is to take the top element v of the 
pushdown list and examine it, i.e. inspect all those
edges (v,z) of the graph for which z has not yet 
been examined.  If z is already in the tree, a fundamental
cycle is added; if not, the edge (v,z) is 
placed in the tree.  There is exactly one such stage
for each of the n vertices of the graph.  For large 
n, the store required in creases as n^2 and the time as
n^g where g depends on the type of graph involved. 
 g is bounded below by 2 and above by 3, and it is shown
that both bounds are attained.  In terms of 
storage our algorithm is similar to that of Gotlieb and
Corneil and superior to that of Welch; in terms 
of speed it is similar to that of Welch and superior
to that of Gotlieb and Corneil.  Testsshow our 
algorithm to be remarkably efficient (g=2) on random graphs.

CACM September, 1969

Paton, K.

fundamental cycle set, graph, algorithm, cycle, spanning tree

5.32

CA690909 JB February 15, 1978  4:29 PM

1847	4	1847
1961	4	1847
2052	4	1847
1504	5	1847
1847	5	1847
1847	5	1847
1847	5	1847
1961	5	1847
2177	5	1847
2763	5	1847
1369	6	1847
1504	6	1847
1847	6	1847
1847	6	1847
1847	6	1847


************************

************************
Document:  CACM-1835.html
************************


The IITRAN Programming Language

The IITRAN language, developed to be used
by students, and its important important features 
are described. IITRAN is a procedure-oriented language
with a one-level block structure and a variety 
of <B>data types</B>.  Several novel and powerful features
are included.  A discussion of design principles 
to be followed in a student language is given.

CACM October, 1969

Dewar, R. B. K.
Hochsprung, R. R.

languages programming languages, student programming
systems, language design, high school programs, 
college courses

1.51 1.52 4.12 4.22

CA691011 JB February 15, 1978  1:54 PM

1835	5	1835
1835	5	1835
1835	5	1835
2971	5	1835
1835	6	1835
1974	6	1835
2534	6	1835


************************

************************
Document:  CACM-2710.html
************************


Specifying Queries as Relational Expressions:
The SQUARE Data Sublanguage

This paper presents a data sublanguage called
SQUARE, intended for use in ad hoc, interactive 
problem solving by non-computer specialists. SQUARE
is based <B>on the</B> relational model of data, and is 
shown to be relationally complete; however, it avoids
the quantifiers and bound variables required by 
languages based on the relational calculus.  Facilities
for query, insertion, deletion, and update on 
tabular data bases are described.  A syntax is given,
and suggestions are made for alternative syntaxes, 
including a syntax based on English key words for
users with limited mathematical background.

CACM November, 1975

Boyce, R. F
Chamberlin, D. D.
King, W. F. III

database, data sublanguages, relations, query languages,
casual user, relational data model, tabular 
data, interactive problem solving, nonprocedural
languages, relational completeness

3.50 3.70 4.20

CA751102 JB January 6, 1978  10:04 AM

1135	4	2710
1136	4	2710
2046	4	2710
2155	4	2710
2406	4	2710
493	4	2710
2710	4	2710
2710	4	2710
2710	4	2710
2710	4	2710
2715	4	2710
2716	4	2710
2716	4	2710
2717	4	2710
2718	4	2710
2765	4	2710
2765	4	2710
2817	4	2710
2888	4	2710
2888	4	2710
2901	4	2710
2901	4	2710
2906	4	2710
2957	4	2710
2959	4	2710
2965	4	2710
3087	4	2710
3154	4	2710
729	4	2710
1515	5	2710
2046	5	2710
2710	5	2710
2710	5	2710
2710	5	2710
2715	5	2710
616	5	2710


************************

************************
Document:  CACM-2198.html
************************


Introduction to "Feature Analysis of
Generalized Data Base Management Systems"

This paper is a separately published introduction
to a main report which analyzes the features 
of generalized data base management systems.  This introduction
gives a review of the current state of 
the art <B>in the</B>se systems and discusses the differences
and similarities between capabilities found in 
host language systems and those found in self-contained
systems.  After some discussion of the problems 
of data independence and binding,the four user levels
are identified and described.  Technical problems 
facing future designers are described.  The first of
these is that of handling existing stored data and 
the next is that of providing more complex data structures
than those already available in conventional 
programming languages.  The problem of high level interrogation
and update functions acting on network 
structures is mentioned, followed by a discussion of the
problem of catering to a high volume of transactions 
initiated from terminals by parametric users-the lowest
level of user.  The use of Cobol as a basis for 
further development work is considered at some length
with respect to data structures, host language 
capabilities, and self-contained capabilities.  This
section also assesses the effect of the Data Base 
Task Group proposals.  The final section outlines the
ten major topics in the main body of the full report.

CACM May, 1971

Codasyl Systems Committee

data base management systems, programming languages,
data structures, storage structures, information 
retrieval, transaction processing

3.5 3.70 3.72 3.73 3.74 4.29

CA710501 JB February 3, 1978  3:18 PM

2198	5	2198
2198	5	2198
2198	5	2198
2452	5	2198
2882	5	2198
849	6	2198
1936	6	2198
1976	6	2198
2198	6	2198
2198	6	2198
2452	6	2198
627	6	2198


************************

************************
Document:  CACM-1588.html
************************


PL/I List Processing

The concepts of list processing have been introduced
into the PL/I language.  With these new 
facilities, it is possible to write PL/I procedures that
operate on simple and complex data list organizations. 
 Most list-processing languages have suffered from their
inability to deal directly with complex data 
structures and/or from their inability to perform the
complete range of programming language operations 
upon the data list structures.  These two problems have
been eliminated <B>in the</B> list-processing facilities 
of PL/I.  The basic concepts of list processing and
the philosophy of the PL/I language extensions are 
discussed.  In addition, several detailed list-processing examples are provided.

CACM June, 1967

Lawson Jr., H. W.

CA670604 JB February 28, 1978  9:30 AM

1588	5	1588
1588	5	1588
1588	5	1588


************************



PL/I List Processing

The concepts of list processing have been introduced
into the PL/I language.  With these new 
facilities, it is possible to write PL/I procedures that
operate on simple and complex data list organizations. 
 Most list-processing languages have suffered from their
inability to deal directly with complex data 
structures and/or from their inability to perform the
complete range of programming language operations 
up<B>on the</B> data list structures.  These two problems have
been eliminated in the list-processing facilities 
of PL/I.  The basic concepts of list processing and
the philosophy of the PL/I language extensions are 
discussed.  In addition, several detailed list-processing examples are provided.

CACM June, 1967

Lawson Jr., H. W.

CA670604 JB February 28, 1978  9:30 AM

1588	5	1588
1588	5	1588
1588	5	1588


************************

************************
Document:  CACM-1154.html
************************


Multi-Tape and Infinite-State Automata -- A Survey

A survey of machines which are more powerful
than finite automata and less powerful than general 
Turing machines is presented.  It is felt that the machines
in this category are as closely related to 
digital computers as either the finite automata or the
unrestricted Turing machines.  Intermediate machines 
can be created by adjoining on infinite-state memory
to a finite-state machine and then performing any 
or all of <B>the following</B>: (1) restrict the manner in
which the unbounded portion of the memory can be 
accessed, (2) bound the number of steps allowed for a
computation by some increasing recursive function 
of the length of the input, (3) restrict the total amount
of memory available in the same manner.  Examples 
from all three classes and their properties are discussed.

CACM December, 1965

Fischer, P. C.

CA651215 JB March 6, 1978  3:24 PM

1154	5	1154
1154	5	1154
1154	5	1154


************************



Multi-Tape and Infinite-State Automata -- A Survey

A survey of machines which are more powerful
than finite automata and less powerful than general 
Turing machines is presented.  It is felt that the machines
in this category are as closely related to 
digital computers as either the finite automata or the
unrestricted Turing machines.  Intermediate machines 
can be created by adjoining on infinite-state memory
to a finite-state machine and then performing any 
or all of the following: (1) restrict the manner in
which the unbounded portion of the memory can be 
accessed, (2) bound the number of steps allowed for a
computation by some increasing recursive function 
of the length of the input, (3) restrict the total amount
of memory available <B>in the</B> same manner.  Examples 
from all three classes and their properties are discussed.

CACM December, 1965

Fischer, P. C.

CA651215 JB March 6, 1978  3:24 PM

1154	5	1154
1154	5	1154
1154	5	1154


************************

************************
Document:  CACM-2912.html
************************


Concurrent Reading and Writing

The problem of sharing data among asynchronous
process is considered.  It is assumed that only 
one process at a time can modify the data, but concurrent
reading and writing is permitted.  Two general 
theorems are proved, and some algorithms are presented
to illustrate their use.  These include a solution 
to the general problem in which a read is repeated if
it <B>might have</B> obtained an incorrect result, and 
two techniques for transmitting messages between processes.
 These solutions do not assume any synchronizing 
mechanism other than data which can be written
by one process and read by other processes.

CACM November, 1977

Lamport, L.

asynchronous multiprocessing, multiprocess synchronization,
readers/writers problem, shared data

4.32 5.24

CA771104 JB December 27, 1977  7:47 AM

2320	4	2912
2597	4	2912
2777	4	2912
2851	4	2912
2895	4	2912
2912	4	2912
2946	4	2912
3128	4	2912
2150	5	2912
2912	5	2912
2912	5	2912
2912	5	2912
3128	5	2912
2150	6	2912
2376	6	2912
2436	6	2912
2597	6	2912
2865	6	2912
2866	6	2912
2870	6	2912
2912	6	2912
3082	6	2912


************************

************************
Document:  CACM-2201.html
************************


Animator: An On-Line Two-dimensional Film Animation System

Animator is a computer animation system which
was designed to overcome some of the inherent 
disadvantages associated with conventional computer animation
techniqueshe DEC-338 serves as an input 
terminal for movie making, allowing the trial and error
design of picture sequences in a conversational 
mode.  During all stages <B>on the</B> system input elements
(light pen, pushbuttons, and teletype) is maintained. 
 At the user's request, this record is sent to the IBM
360/75 where the S-D 4020 instructions necessary 
to produce the same sequence of pictures can be generated.
 It is anticipated that one of the primary 
contributions of Animator will be the provision of a
facility which will allow any professor to produce 
his own expository film strips.

CACM April, 1971

Talbot, P. A.
Carr III, J. W.
Coulter Jr., R. R.
Hwang, R. C.

computer graphics, computer animation, on-line
systems, two-dimensional languages, CRT, microfilm 
recorder

3.41 3.80 4.22

CA710404 JB February 3, 1978  3:37 PM

2201	5	2201
2201	5	2201
2201	5	2201


************************

************************
Document:  CACM-2940.html
************************


Abstraction and Verification in Alphard: Defining
and Specifying Iteration and Generators

The Alphard "form" provides the programmer with
a great deal of control over the implementation 
of abstract <B>data types</B>.  In this paper the abstraction techniques
are extended from simple data representation 
and function definition to the iteration statement, the
most important poin t of interaction between data 
and the control structure of the language itself.  A
means of specializing Alphard's loops to operate 
on abstract entities without explicit dependence on the
representation of those entities is in troduced. 
 Specification and verification techniques that allow
the properties of the generators for such iterations 
to be expressed in the form of proof rules are developed.
 Results are obtained that for common special 
cases of these loops are essentially identical to the
corresponding constructs in other languages.  A 
means of showing that a generator will terminate is also provided.

CACM August, 1977

Shaw, M.
Wulf, W. A.

abstraction and representation, abstract data types,
assertions, control specialization, correctness, 
generators,invariants, iteration statements, modular
decomposition, program specifications, programming 
languages, programming methodology, proofs of correctness, types, verification

4.20 5.24

CA770803 JB December 28, 1977  7:59 AM

2940	5	2940
2940	5	2940
2940	5	2940
3150	5	2940
2060	6	2940
2704	6	2940
2842	6	2940
2939	6	2940
2940	6	2940
2941	6	2940
2943	6	2940
3073	6	2940
3148	6	2940


************************



Abstraction and Verification in Alphard: Defining
and Specifying Iteration and Generators

The Alphard "form" provides the programmer with
a great deal of control over the implementation 
of abstract data types.  In this paper the abstraction techniques
are extended from simple data representation 
and function definition to the iteration statement, the
most important poin t of interaction between data 
and the control structure of the language itself.  A
means of specializing Alphard's loops to operate 
on abstract entities without explicit dependence <B>on the</B>
representation of those entities is in troduced. 
 Specification and verification techniques that allow
the properties of the generators for such iterations 
to be expressed in the form of proof rules are developed.
 Results are obtained that for common special 
cases of these loops are essentially identical to the
corresponding constructs in other languages.  A 
means of showing that a generator will terminate is also provided.

CACM August, 1977

Shaw, M.
Wulf, W. A.

abstraction and representation, abstract data types,
assertions, control specialization, correctness, 
generators,invariants, iteration statements, modular
decomposition, program specifications, programming 
languages, programming methodology, proofs of correctness, types, verification

4.20 5.24

CA770803 JB December 28, 1977  7:59 AM

2940	5	2940
2940	5	2940
2940	5	2940
3150	5	2940
2060	6	2940
2704	6	2940
2842	6	2940
2939	6	2940
2940	6	2940
2941	6	2940
2943	6	2940
3073	6	2940
3148	6	2940


************************



Abstraction and Verification in Alphard: Defining
and Specifying Iteration and Generators

The Alphard "form" provides the programmer with
a great deal of control over the implementation 
of abstract data types.  In this paper the abstraction techniques
are extended from simple data representation 
and function definition to the iteration statement, the
most important poin t of interaction between data 
and the control structure of the language itself.  A
means of specializing Alphard's loops to operate 
on abstract entities without explicit dependence on the
representation of those entities is in troduced. 
 Specification and verification techniques that allow
the properties of the generators for such iterations 
to be expressed <B>in the</B> form of proof rules are developed.
 Results are obtained that for common special 
cases of these loops are essentially identical to the
corresponding constructs in other languages.  A 
means of showing that a generator will terminate is also provided.

CACM August, 1977

Shaw, M.
Wulf, W. A.

abstraction and representation, abstract data types,
assertions, control specialization, correctness, 
generators,invariants, iteration statements, modular
decomposition, program specifications, programming 
languages, programming methodology, proofs of correctness, types, verification

4.20 5.24

CA770803 JB December 28, 1977  7:59 AM

2940	5	2940
2940	5	2940
2940	5	2940
3150	5	2940
2060	6	2940
2704	6	2940
2842	6	2940
2939	6	2940
2940	6	2940
2941	6	2940
2943	6	2940
3073	6	2940
3148	6	2940


************************

************************
Document:  CACM-0536.html
************************


Nonlinear Regression and the Solution of Simultaneous Equations

If one has a set of observables (Z1,...,Zm) which
are bound in a relation with certain parameters 
(A1,...,An) by an equation S(Z1,...;A1,...)=0, one frequently
has the problem of determining a set of 
values of the Ai which minimizes the sum of squares of
differences between observed and calculated values 
of a distinguished observable, say Zm.  If the solution
of <B>the above</B> equation for Zm,  Zm=N(Z1,...;A1,...) 
gives rise to a function N which is nonlinear in the Ai,
then one may rely on a version of Gaussian regression 
[1,2] for an iteration scheme that converges to a minimizing
set of values.  It is shown here that this 
same minimization technique may be used for the solution
of simultaneous (not necessarily linear) equations.

CACM July, 1962

Baer, R. M.

CA620725 JB March 17, 1978  8:09 PM

536	5	536
536	5	536
536	5	536


************************



Nonlinear Regression and the Solution of Simultaneous Equations

If one has a set of observables (Z1,...,Zm) which
are bound in a relation with certain parameters 
(A1,...,An) by an equation S(Z1,...;A1,...)=0, one frequently
has the problem of determining a set of 
values of the Ai which minimizes the sum of squares of
differences between observed and calculated values 
of a distinguished observable, say Zm.  If the solution
of the above equation for Zm,  Zm=N(Z1,...;A1,...) 
gives rise to a function N which is nonlinear <B>in the</B> Ai,
then one may rely on a version of Gaussian regression 
[1,2] for an iteration scheme that converges to a minimizing
set of values.  It is shown here that this 
same minimization technique may be used for the solution
of simultaneous (not necessarily linear) equations.

CACM July, 1962

Baer, R. M.

CA620725 JB March 17, 1978  8:09 PM

536	5	536
536	5	536
536	5	536


************************

************************
Document:  CACM-2833.html
************************


An Efficient, Incremental, Automatic Garbage Collector

This paper describes a new way of solving
the storage reclamation problem for a system such 
as Lisp that allocates storage automatically from a
heap, and does not require the programmer to give 
any indication that particular items are no longer useful
or accessible.  A reference count scheme for 
reclaiming non-self-referential structures, and a linearizing,
compacting, copying scheme to reorganize 
all storage at the users discretion are proposed.  The
algorithms are designed to work well in systems 
which use multiple levels of storage, and large virtual
address space.  They depend <B>on the</B> fact that 
most cells are referenced exactly once, and that reference
counts need only be accurate when storage 
is about to be reclaimed.  A transaction file stores changes
to reference counts, and a multiple reference 
table stores the count for items which are referenced more than once.

CACM September, 1976

Deutsch, L. P.
Bobrow, D. G.

storage management, garbage collection, Lisp

4.19

CA760906 JB January 4, 1978  8:58 AM

1708	4	2833
1781	4	2833
1826	4	2833
1860	4	2833
1972	4	2833
2156	4	2833
2156	4	2833
2168	4	2833
2168	4	2833
2249	4	2833
2314	4	2833
2438	4	2833
2719	4	2833
2723	4	2833
2736	4	2833
2736	4	2833
2833	4	2833
2833	4	2833
2833	4	2833
2845	4	2833
2855	4	2833
3074	4	2833
3112	4	2833
3112	4	2833
1626	5	2833
1826	5	2833
2736	5	2833
2833	5	2833
2833	5	2833
2833	5	2833
2855	5	2833
2944	5	2833
3112	5	2833
106	6	2833
1380	6	2833
1549	6	2833
1826	6	2833
1826	6	2833
210	6	2833
1972	6	2833
1972	6	2833
2438	6	2833
2513	6	2833
2723	6	2833
2736	6	2833
2766	6	2833
2833	6	2833
2833	6	2833
2833	6	2833
2838	6	2833
2998	6	2833
2998	6	2833
731	6	2833


************************



An Efficient, Incremental, Automatic Garbage Collector

This paper describes a new way of solving
the storage reclamation problem for a system such 
as Lisp that allocates storage automatically from a
heap, and does not require the programmer to give 
any indication that particular items are no longer useful
or accessible.  A reference count scheme for 
reclaiming non-self-referential structures, and a linearizing,
compacting, copying scheme to reorganize 
all storage at the users discretion are proposed.  The
algorithms are designed to work well in systems 
which use multiple levels of storage, and large virtual
address space.  They depend on the fact that 
most cells <B>are referenced</B> exactly once, and that reference
counts need only be accurate when storage 
is about to be reclaimed.  A transaction file stores changes
to reference counts, and a multiple reference 
table stores the count for items which are referenced more than once.

CACM September, 1976

Deutsch, L. P.
Bobrow, D. G.

storage management, garbage collection, Lisp

4.19

CA760906 JB January 4, 1978  8:58 AM

1708	4	2833
1781	4	2833
1826	4	2833
1860	4	2833
1972	4	2833
2156	4	2833
2156	4	2833
2168	4	2833
2168	4	2833
2249	4	2833
2314	4	2833
2438	4	2833
2719	4	2833
2723	4	2833
2736	4	2833
2736	4	2833
2833	4	2833
2833	4	2833
2833	4	2833
2845	4	2833
2855	4	2833
3074	4	2833
3112	4	2833
3112	4	2833
1626	5	2833
1826	5	2833
2736	5	2833
2833	5	2833
2833	5	2833
2833	5	2833
2855	5	2833
2944	5	2833
3112	5	2833
106	6	2833
1380	6	2833
1549	6	2833
1826	6	2833
1826	6	2833
210	6	2833
1972	6	2833
1972	6	2833
2438	6	2833
2513	6	2833
2723	6	2833
2736	6	2833
2766	6	2833
2833	6	2833
2833	6	2833
2833	6	2833
2838	6	2833
2998	6	2833
2998	6	2833
731	6	2833


************************

************************
Document:  CACM-2931.html
************************


Logic and Programming Languages

Logic has been long in terested in whether answers
to certain questions are computable in principle, 
since the outcome puts bounds on the possibilities of
formalization.  More recently, precise comparisons 
<B>in the</B> efficiency of decision methods have become available
through the developments in complexity theory. 
 These, however, are applications to logic, and a big question
is whether methods of logic have significance 
in the other direction for the more applied parts of
computability theory.  Programming languages offer 
an obvious opportunity as their syntactic formalization
is well advanced; however, the semantical theory 
can hardly be said to be complete.  Though we have
many examples, we have still to give wide-ranging 
mathematical answers to these queries:  What is a machine?
 What is a computable process?  How (or how 
well) does a machine simulate a process?  Programs naturally
enter in giving descriptions of processes. 
 The definition of the precise meaning of a program
then requires us to explain what are the objects 
of computation (in a way, the statics of the problem)
and how they are to be transformed (the dynamics). 
 So far the theories of automata and of nets, though
most in teresting for dynamics, have formalized only 
a portion of the field, and there has been perhaps too
much concentration on the finite-state and algebraic 
aspects.  It would seem that the understanding of higher-level
program features involves us with infinite 
objects and forces us to pass through several levels
of explanation to go from the conceptual ideas to 
the final simulation on a real machine.  These levels
can be made mathematically exact if we can find 
the right abstractions to represent the necessary structures.
 The experience of many independent workers 
with the method of data types as lattices (or partial
orderings) under an information content ordering, 
and with their continuous mappings, has demonstrated the
flexibility of this approach in providing definitions 
and proofs, which are clean and without undue dependence
on implementations.  Nevertheless much remains 
to be done in showing how abstract conceptualizations
can (or cannot) be actualized before we can say 
we have a unified theory.

CACM September, 1977

Scott, D. S.

logic, programming languages, automata, denotational
semantics, a-calculus models, computability, 
partial functions, approximation, function spaces

1.2 4.20 5.21 5.24 5.27

CA770902 JB December 28, 1977  6:49 AM

2931	5	2931
2931	5	2931
2931	5	2931


************************



Logic and Programming Languages

Logic has been long in terested in whether answers
to certain questions are computable in principle, 
since the outcome puts bounds <B>on the</B> possibilities of
formalization.  More recently, precise comparisons 
in the efficiency of decision methods have become available
through the developments in complexity theory. 
 These, however, are applications to logic, and a big question
is whether methods of logic have significance 
in the other direction for the more applied parts of
computability theory.  Programming languages offer 
an obvious opportunity as their syntactic formalization
is well advanced; however, the semantical theory 
can hardly be said to be complete.  Though we have
many examples, we have still to give wide-ranging 
mathematical answers to these queries:  What is a machine?
 What is a computable process?  How (or how 
well) does a machine simulate a process?  Programs naturally
enter in giving descriptions of processes. 
 The definition of the precise meaning of a program
then requires us to explain what are the objects 
of computation (in a way, the statics of the problem)
and how they are to be transformed (the dynamics). 
 So far the theories of automata and of nets, though
most in teresting for dynamics, have formalized only 
a portion of the field, and there has been perhaps too
much concentration on the finite-state and algebraic 
aspects.  It would seem that the understanding of higher-level
program features involves us with infinite 
objects and forces us to pass through several levels
of explanation to go from the conceptual ideas to 
the final simulation on a real machine.  These levels
can be made mathematically exact if we can find 
the right abstractions to represent the necessary structures.
 The experience of many independent workers 
with the method of data types as lattices (or partial
orderings) under an information content ordering, 
and with their continuous mappings, has demonstrated the
flexibility of this approach in providing definitions 
and proofs, which are clean and without undue dependence
on implementations.  Nevertheless much remains 
to be done in showing how abstract conceptualizations
can (or cannot) be actualized before we can say 
we have a unified theory.

CACM September, 1977

Scott, D. S.

logic, programming languages, automata, denotational
semantics, a-calculus models, computability, 
partial functions, approximation, function spaces

1.2 4.20 5.21 5.24 5.27

CA770902 JB December 28, 1977  6:49 AM

2931	5	2931
2931	5	2931
2931	5	2931


************************



Logic and Programming Languages

Logic has been long in terested in whether answers
to certain questions are computable in principle, 
since the outcome puts bounds on the possibilities of
formalization.  More recently, precise comparisons 
in the efficiency of decision methods have become available
through the developments in complexity theory. 
 These, however, are applications to logic, and a big question
is whether methods of logic have significance 
in the other direction for the more applied parts of
computability theory.  Programming languages offer 
an obvious opportunity as their syntactic formalization
is well advanced; however, the semantical theory 
can hardly be said to be complete.  Though we have
many examples, we have still to give wide-ranging 
mathematical answers to these queries:  What is a machine?
 What is a computable process?  How (or how 
well) does a machine simulate a process?  Programs naturally
enter in giving descriptions of processes. 
 The definition of the precise meaning of a program
then requires us to explain what are the objects 
of computation (in a way, the statics of the problem)
and how they are to be transformed (the dynamics). 
 So far the theories of automata and of nets, though
most in teresting for dynamics, have formalized only 
a portion of the field, and there has been perhaps too
much concentration on the finite-state and algebraic 
aspects.  It would seem that the understanding of higher-level
program features involves us with infinite 
objects and forces us to pass through several levels
of explanation to go from the conceptual ideas to 
the final simulation on a real machine.  These levels
can be made mathematically exact if we can find 
the right abstractions to represent the necessary structures.
 The experience of many independent workers 
with the method of <B>data types</B> as lattices (or partial
orderings) under an information content ordering, 
and with their continuous mappings, has demonstrated the
flexibility of this approach in providing definitions 
and proofs, which are clean and without undue dependence
on implementations.  Nevertheless much remains 
to be done in showing how abstract conceptualizations
can (or cannot) be actualized before we can say 
we have a unified theory.

CACM September, 1977

Scott, D. S.

logic, programming languages, automata, denotational
semantics, a-calculus models, computability, 
partial functions, approximation, function spaces

1.2 4.20 5.21 5.24 5.27

CA770902 JB December 28, 1977  6:49 AM

2931	5	2931
2931	5	2931
2931	5	2931


************************

************************
Document:  CACM-2264.html
************************


Derived Semantics for Some Programming Language Constructs

The constructs of a simple programming language
are introduced and described informally in 
terms of values and side-effects.  A translator is defined
which translates the language into flowcharts 
for a simple machine.  The action of the machine in executing
a flowchart is defined.  A proof is constructed 
that the effect of translating and executing any program
can be expressed solely in terms of the value 
and side-effect of the program.  During the course of
constructing the proof, formal definitions of the 
concepts of value and side-effect are derived in order
to make the proof rigorous.  Correctness of the 
implementation involves checking that the definitions derived
<B>in the</B> step above are an acceptable formalization 
of the informal description given in the first step.

CACM November, 1972

Henderson, P.

lambda calculus, formal description, program
correctness, programming languages, semantics

4.22 5.23 5.24

CA721105 JB January 27, 1978  2:19 PM

2264	5	2264
2264	5	2264
2264	5	2264
2470	5	2264
1303	6	2264
1469	6	2264
1834	6	2264
2264	6	2264


************************

************************
Document:  CACM-2838.html
************************


Analysis of an Algorithm for Real Time Garbage Collection

A real time garbage collection system avoids
suspending the operations of a list processor 
for the long times that garbage collection normally requires
by performing garbage collection on a second 
processor in parallel with list processing operations,
or on a single processor time-shared with them. 
 Algorithms for recovering discarded list structures in
this manner are presented and analyzed to determine 
sufficient conditions under which the list processor never
needs to wait <B>on the</B> collector.  These techniques 
are shown to require at most twice as much processing
power as regular garbage collectors, if they are 
used efficiently.  The average behavior of the program
is shown to be very nearly equal to the worst-case 
performance, so that the sufficient conditions are also
suitable for measuring the typical behavior of 
the algorithm.

CACM September, 1976

Wadler, P. L.

garbage collection, storage reclamation, list
processing, Lisp, time-sharing, multiprocessing, 
parallel processing, real time, data structures, analysis of algorithms

3.69 3.89 4.19 4.29 4.32 4.34 4.9 5.25

CA760901 JB January 4, 1978  9:57 AM

1024	4	2838
1051	4	2838
1102	4	2838
1132	4	2838
1390	4	2838
1486	4	2838
1549	4	2838
1706	4	2838
1826	4	2838
1878	4	2838
378	4	2838
2060	4	2838
2155	4	2838
2168	4	2838
2719	4	2838
2723	4	2838
2838	4	2838
2838	4	2838
2842	4	2838
2855	4	2838
2879	4	2838
2896	4	2838
3039	4	2838
3074	4	2838
3077	4	2838
3080	4	2838
3106	4	2838
3112	4	2838
627	4	2838
106	4	2838
210	5	2838
2723	5	2838
2838	5	2838
2838	5	2838
2838	5	2838
3112	5	2838
106	6	2838
1380	6	2838
1826	6	2838
1972	6	2838
2438	6	2838
2723	6	2838
2736	6	2838
2833	6	2838
2838	6	2838
731	6	2838


************************

************************
Document:  CACM-1098.html
************************


A Comparison of List-Processing Computer Languages
(Including a Detailed Comparison of COMIT, 
IPL-V, LISP 1.5, and SLIP)

A detailed comparison is presented of COMIT,
IPL-V, LISP 1.5 and SLIP - four well-known computer 
programming languages which, among them, exhibit all the
principal characteristics of existing list-processing 
languages.  Important common features of list-processing
languages are reviewed: forms of data structures 
which are manipulated, necessity for dynamic allocation
of storage, use of pushdown stores, and use of 
recursive operations.  Principal differences between the
four languages under consideration are detailed: 
representations of data, both by the programmer and within
the machine; methods for storage allocation; 
programming formalisms and special processes available,
including arithmetic facilities; and usability 
in terms of availability, documentation, learning aids
and debugging facilities.  A rough comparison 
shows that all the languages discussed have approximately
the same speed.  Finally, the authors give 
some heuristics to aid <B>in the</B> selection of one of these
languages for use in particular problem applications, 
concluding that no one of the languages considered is
distinctly superior in all possible list-processing 
applications.

CACM April, 1964

Bobrow, D. G.
Raphael, B.

CA640410 JB March 10, 1978  1:37 AM

1024	4	1098
1051	4	1098
1098	4	1098
1214	4	1098
1380	4	1098
1388	4	1098
1393	4	1098
1485	4	1098
1487	4	1098
1549	4	1098
1570	4	1098
1878	4	1098
1946	4	1098
1957	4	1098
2168	4	1098
2723	4	1098
2857	4	1098
3112	4	1098
1098	5	1098
1098	5	1098
1098	5	1098
1570	5	1098
1945	5	1098
2314	5	1098
731	5	1098
823	6	1098
914	6	1098
915	6	1098
917	6	1098
984	6	1098
989	6	1098
990	6	1098
1012	6	1098
1084	6	1098
1098	6	1098
1098	6	1098
1098	6	1098
1122	6	1098
1138	6	1098
1139	6	1098
1141	6	1098
1200	6	1098
1223	6	1098
1265	6	1098
1336	6	1098
1396	6	1098
1455	6	1098
1477	6	1098
1487	6	1098
1491	6	1098
1496	6	1098
1626	6	1098
2082	6	1098
2148	6	1098
483	6	1098
584	6	1098
669	6	1098
680	6	1098
731	6	1098
763	6	1098


************************

************************
Document:  CACM-3103.html
************************


Automatic Data Structure Selection: An Example and Overview

The use of several levels of abstraction has
proved to be very helpful in constructing and 
maintaining programs.  When programs are designed with abstract
<B>data types</B> such as sets and lists, programmer 
time can be saved by automating the process of filling
in low-level implementation details.  In the past, 
programming systems have provided only a single general
purpose implementation for an abstract type. 
 Thus the programs produced using abstract types were
then inefficient in space or time.  In this paper 
a system for automatically choosing efficient implementations
for abstract types from a library of implementations 
is discussed.  This process is discussed in detail for
an example program.  General issues in data structure 
selection are also reviewed. 

CACM May, 1978

Low, J.

Abstract data types, automatic programming, data
structures, optimizing compilers, sets, lists

4.12 4.22 4.6

CA780504 DH February 26, 1979  1:51 PM

1957	4	3103
2151	4	3103
3103	4	3103
3103	4	3103
3148	4	3103
1860	5	3103
2877	5	3103
3103	5	3103
3103	5	3103
3103	5	3103


************************

************************
Document:  CACM-2003.html
************************


An Interactive Software System for Computers-Aided
Design:  An Application to Circuit Project

The characteristics of an interactive software system, intended to constitute 
an interface between designer and computer during various steps of
the design process, are presented.  The main emphasis is given to the
description of the features of the two high level user oriented
languages, operating at different levels, on which the interaction
is based.  The first one is IMOL, an interactive monitor language,
which is designed to perform the overall and control functions
of the software system; its design criteria provide the user with
commands which are both simple and efficient in order to perform all
the functions needed in computer-aided circuit design.  The second one is 
COIF, a circuit oriented graphic language, which is designed
to describe, generate, and manipulate graphic problem specifications; 
it is an  extension of Fortran with graphic-type variables,
so that the designer who is familiar with Fortran need not learn a new 
language.  The application to computer-aided circuit design
is in particular examined; <B>on the</B> other hand, the adopted design
criteria provide sufficient generality to extend the use of the two languages 
to different computer-assisted applications.

CACM September, 1970

Bracchi, G.
Somalvico, M.

interaction, graphics, computer graphics, computer-aided design, circuit
design, software system, software organization, language,
monitor language, graphic language, extended Fortran

3.24 3.25 4.13 4.22 4.3

CA700902 JB February 10, 1978  2:20 PM

1853	4	2003
2003	4	2003
2003	4	2003
2003	4	2003
2002	4	2003
2152	4	2003
1710	5	2003
1767	5	2003
2003	5	2003
2003	5	2003
2003	5	2003
2105	5	2003
2230	5	2003
2003	6	2003


************************

************************
Document:  CACM-1650.html
************************


A Unifying Computational Method for the
Analysis of Complete Factorial Experiments

A computational method which may be used for
the calculation of sums of squares <B>in the</B> analysis 
of variance of complete factorial experiments and in
the computation of main effect or interaction means 
is described.  The method is elucidated as unifying since
one method can be used for a variety of purposes 
each previously requiring different methods.  The programming
advantages of such a method are obvious. 
 The following variants are discussed: (1) the standard
analysis of variance; (2) analyses omitting certain 
levels of one or more factors; (3) separate analyses
for some levels of a factor or for combinations 
of levels of more than one factor.  These are performed
simultaneously; (4) the calculation of main effect 
or interaction means.  The mean expects the data in standard
order and it leaves the data in that order 
so that many analyses of the same data can be performed
without rearrangement.  The total sum of squares, 
excluding a replication sum of squares, is partitioned
into all polynomial partitions and their interactions 
each with one degree of freedom.  This is so even
if factors have unequally spaced factor levels.

CACM January, 1967

Cooper, B. E.

CA670105 JB February 28, 1978  4:49 PM

1650	5	1650
1650	5	1650
1650	5	1650


************************

************************
Document:  CACM-1625.html
************************


On the Automatic Simplification of Source-Language Programs

Methods of simplification that can be applied
automatically to programs written in an ALGOL-like 
language are discussed.  The simplifications are based
<B>on the</B> form of the program and the knowledge obtained 
by a processor, without any understanding of what the
program is supposed to do.  These methods have 
been implemented in a processor called SURE that accepts
a program written in JOVIAL and outputs an equivalent 
JOVIAL program that may be shorter and may be executed
faster than the original.  SURE is described, 
some of the problems encountered in automatic improvement
at the source-language level are discussed, 
and further types of automatic program improvement are suggested.

CACM March, 1967

Clark, E. R.

CA670304 JB February 28, 1978  1:33 PM

1084	4	1625
1379	4	1625
1625	4	1625
1625	4	1625
1807	4	1625
1945	4	1625
1947	4	1625
1248	5	1625
1625	5	1625
1625	5	1625
1625	5	1625
669	5	1625


************************

************************
Document:  CACM-3105.html
************************


A Language Extension for Expressing Constraints on Data Access

Controlled sharing of information is needed and
desirable for many applications and is supported 
in operating systems by access control mechanisms.  This
paper shows how to extend programming languages 
to provide controlled sharing.  The extension permits
expression of access constraints on shared data. 
 Access constraints can apply both to simple objects, and
to objects that are components of larger objects, 
such as bank account records in a bank's data base.
 The constraints are stated declaratively, and can 
be enforced by static checking similar to type checking.
 The approach can be used to extend any strongly-typed 
language, but is particularly suitable for extending
languages that support the notion of abstract data 
types. 

CACM May, 1978

Jones, A.
Liskov,B.

Programming languages, access control, <B>data types</B>,
abstract data types, type checking, capabilities

4.20 4.35

CA780502 DH February 26, 1979  3:19 PM

1458	4	3105
1523	4	3105
1603	4	3105
1698	4	3105
1747	4	3105
1748	4	3105
1854	4	3105
1877	4	3105
1960	4	3105
2377	4	3105
2378	4	3105
2497	4	3105
2558	4	3105
2625	4	3105
2626	4	3105
2632	4	3105
2840	4	3105
2868	4	3105
2868	4	3105
2870	4	3105
2876	4	3105
2941	4	3105
3031	4	3105
3105	4	3105
3105	4	3105
3105	4	3105
3105	4	3105
3105	4	3105
3105	4	3105
3144	4	3105
3144	4	3105
3144	4	3105
3148	4	3105
3150	4	3105
1471	5	3105
2625	5	3105
2632	5	3105
2868	5	3105
2939	5	3105
3068	5	3105
3105	5	3105
3105	5	3105
3105	5	3105


************************



A Language Extension for Expressing Constraints on Data Access

Controlled sharing of information is needed and
desirable for many applications and is supported 
in operating systems by access control mechanisms.  This
paper shows how to extend programming languages 
to provide controlled sharing.  The extension permits
expression of access constraints on shared data. 
 Access constraints can apply both to simple objects, and
to objects <B>that are</B> components of larger objects, 
such as bank account records in a bank's data base.
 The constraints are stated declaratively, and can 
be enforced by static checking similar to type checking.
 The approach can be used to extend any strongly-typed 
language, but is particularly suitable for extending
languages that support the notion of abstract data 
types. 

CACM May, 1978

Jones, A.
Liskov,B.

Programming languages, access control, data types,
abstract data types, type checking, capabilities

4.20 4.35

CA780502 DH February 26, 1979  3:19 PM

1458	4	3105
1523	4	3105
1603	4	3105
1698	4	3105
1747	4	3105
1748	4	3105
1854	4	3105
1877	4	3105
1960	4	3105
2377	4	3105
2378	4	3105
2497	4	3105
2558	4	3105
2625	4	3105
2626	4	3105
2632	4	3105
2840	4	3105
2868	4	3105
2868	4	3105
2870	4	3105
2876	4	3105
2941	4	3105
3031	4	3105
3105	4	3105
3105	4	3105
3105	4	3105
3105	4	3105
3105	4	3105
3105	4	3105
3144	4	3105
3144	4	3105
3144	4	3105
3148	4	3105
3150	4	3105
1471	5	3105
2625	5	3105
2632	5	3105
2868	5	3105
2939	5	3105
3068	5	3105
3105	5	3105
3105	5	3105
3105	5	3105


************************

************************
Document:  CACM-2092.html
************************


A Deductive Question-Answer for Natural Language Inference

The question-answering aspects of the Protosynthex III pro
totype language processing system are described and exemplified in
detail.  The system is written in LISP 1.5 and operates <B>on the</B> Q-32
time-sharing system.  The system's data structures and their semantic
organization, the deductive question-answering formalism of
relational properties and complex-relation-forming operators, and
the question-answering procedures which employ these features in
their operation are all described and illustrated.  Examples of the
system's performance and of the limitations of its question-answering 
capability are presented and discussed.  It is shown that the
use of semantic information in deductive question answering greatly 
facilitates the process, and that a top-down procedure which works
from question to answer enables effective use to be made of this
information.  It is concluded that the development of Protosynthex
III into a practically useful system to work with large data
bases is possible but will require changes in both the data
structures and the algorithms used for question answering.

CACM March, 1970

Schwarcz, R. M.
Burger, J. F.
Simmons, R. F.

question answering, natural language, Protosynthex III, LISP,
semantics, artificial intelligence, computational
linguistics, language processing, fact retrieval

3.42 3.61

CA700306 JB February 13, 1978  4:30 PM

2092	4	2092
2127	4	2092
1527	5	2092
2092	5	2092
2092	5	2092
2092	5	2092
2396	5	2092
1487	6	2092
1856	6	2092
2092	6	2092
2127	6	2092


************************

************************
Document:  CACM-2956.html
************************


Some Ideas on Data Types in High-Level Languages

A number of issues are explored concerning the
notion that a data type is a set of values together 
with a set of primitive operations on those values.  Among
these are the need for a notation for iterating 
over the elements of any finite set (instead of the
more narrow for i:= 1 to n notation), the use of 
the domain of an array as a data type, the need for
a simple notation for allowing types of parameters 
to be themselves parameters (but in a restrictive fashion),
and resulting problems with conversion of 
values from one type to another.

CACM June, 1977

Gries, D.
Gehani, N.

<B>data types</B>, generic procedures, programming languages

4.12 4.20 4.22

CA770607 JB December 28, 1977  1:27 PM

2167	4	2956
2723	4	2956
2941	4	2956
2956	4	2956
2956	4	2956
3030	4	2956
1379	5	2956
2651	5	2956
2956	5	2956
2956	5	2956
2956	5	2956
3049	5	2956
2956	6	2956
2958	6	2956
2957	6	2956
2960	6	2956


************************

************************
Document:  CACM-1385.html
************************


Computer Technology in Communist China, 1956-1965

Based on information from translations of Communist
Chinese news items and periodical literature 
for the 1965 period, computer technology in China is
reviewed under <B>the following</B> headings: (1) initial 
planning, organization and educational aspects of computer
technology and automation; (2) machine development 
progress: two major specific machines in 1958-59, with
Soviet aid; a vacuum in 1960-64 due to the withdrawal 
of Soviet aid; then presumably all-Chinese-made machines
from 1965 to the present; (3) computer applications; 
(4) the trend of automation: control of production processes
rather than data processing; and (5) the 
"Yun Ch'ou Hsueh" (Science of Operation and Programming)
campaign of 1958-60, during which an attempt 
was made to bring concepts such as linear programming
to ordinary Chinese workers and peasants.  Communist 
China is adjudged to have a marginal computer capability,
with most of its machines probably being of 
a binary nature; however, a turning point may have been reached in mid-1965.

CACM September, 1966

Audette, D. G.

CA660901 JB March 2, 1978  6:59 PM

1385	5	1385
1385	5	1385
1385	5	1385


************************

************************
Document:  CACM-2470.html
************************


Fen-An Axiomatic Basis for Program Semantics

A formal system is presented which abstracts
the notions of data item, function, and relation. 
 It is argued that the system is more suitable than set
theory (or its derivatives) for the concise and 
accurate description of program semantics.  It is shown
how the system can be used to build composite 
data types out of simper ones with the operations of rowing,
structuring, and uniting.  It is also demonstrated 
that completely new primitive types can be introduced
into languages through the mechanism of singleton 
data types.  Both deterministic and nondeterministic
functions are shown to be definable in the system. 
 It is described how the local environment can be modeled
as a data item and how imperative statements 
can be considered functions <B>on the</B> environment.  The
nature of recursive functions is briefly discussed, 
and a technique is presented by which they can be introduced
into the system.  The technique is contrasted 
with the use of the paradoxical combinator, Y.  The
questions of local and global environments and of 
various modes of function calling and parameter passing
are touched upon. The theory is applied to the 
proof of several elementary theorems concerning the semantics
of the assignment, conditional, and iterative 
statements.  An appendix is included which presents in
detail the formal system governing webs and fen, 
the abstractions used informally in the body of the paper.

CACM August, 1973

MacLennan, B. J.

semantics, formal systems, lambda-calculus, extensible
languages, data types, modes, axioms, correctness, 
formal language definition, formal description, data structures,
description languages, models of computation

4.22 5.21 5.24 5.26

CA730804 JB January 23, 1978  11:01 AM

1469	4	2470
1486	4	2470
1491	4	2470
1781	4	2470
2021	4	2470
2060	4	2470
2178	4	2470
2222	4	2470
2227	4	2470
2294	4	2470
2315	4	2470
2326	4	2470
2326	4	2470
2470	4	2470
2470	4	2470
2470	4	2470
2470	4	2470
2684	4	2470
2732	4	2470
2865	4	2470
2896	4	2470
2943	4	2470
3014	4	2470
3044	4	2470
3068	4	2470
3077	4	2470
3124	4	2470
3143	4	2470
1303	5	2470
1469	5	2470
1834	5	2470
2264	5	2470
2470	5	2470
2470	5	2470
2470	5	2470


************************



Fen-An Axiomatic Basis for Program Semantics

A formal system is presented which abstracts
the notions of data item, function, and relation. 
 It is argued that the system is more suitable than set
theory (or its derivatives) for the concise and 
accurate description of program semantics.  It is shown
how the system can be used to build composite 
<B>data types</B> out of simper ones with the operations of rowing,
structuring, and uniting.  It is also demonstrated 
that completely new primitive types can be introduced
into languages through the mechanism of singleton 
data types.  Both deterministic and nondeterministic
functions are shown to be definable in the system. 
 It is described how the local environment can be modeled
as a data item and how imperative statements 
can be considered functions on the environment.  The
nature of recursive functions is briefly discussed, 
and a technique is presented by which they can be introduced
into the system.  The technique is contrasted 
with the use of the paradoxical combinator, Y.  The
questions of local and global environments and of 
various modes of function calling and parameter passing
are touched upon. The theory is applied to the 
proof of several elementary theorems concerning the semantics
of the assignment, conditional, and iterative 
statements.  An appendix is included which presents in
detail the formal system governing webs and fen, 
the abstractions used informally in the body of the paper.

CACM August, 1973

MacLennan, B. J.

semantics, formal systems, lambda-calculus, extensible
languages, data types, modes, axioms, correctness, 
formal language definition, formal description, data structures,
description languages, models of computation

4.22 5.21 5.24 5.26

CA730804 JB January 23, 1978  11:01 AM

1469	4	2470
1486	4	2470
1491	4	2470
1781	4	2470
2021	4	2470
2060	4	2470
2178	4	2470
2222	4	2470
2227	4	2470
2294	4	2470
2315	4	2470
2326	4	2470
2326	4	2470
2470	4	2470
2470	4	2470
2470	4	2470
2470	4	2470
2684	4	2470
2732	4	2470
2865	4	2470
2896	4	2470
2943	4	2470
3014	4	2470
3044	4	2470
3068	4	2470
3077	4	2470
3124	4	2470
3143	4	2470
1303	5	2470
1469	5	2470
1834	5	2470
2264	5	2470
2470	5	2470
2470	5	2470
2470	5	2470


************************



Fen-An Axiomatic Basis for Program Semantics

A formal system is presented which abstracts
the notions of data item, function, and relation. 
 It is argued that the system is more suitable than set
theory (or its derivatives) for the concise and 
accurate description of program semantics.  It is shown
how the system can be used to build composite 
data types out of simper ones with the operations of rowing,
structuring, and uniting.  It is also demonstrated 
that completely new primitive types can be introduced
into languages through the mechanism of singleton 
data types.  Both deterministic and nondeterministic
functions are shown to be definable <B>in the</B> system. 
 It is described how the local environment can be modeled
as a data item and how imperative statements 
can be considered functions on the environment.  The
nature of recursive functions is briefly discussed, 
and a technique is presented by which they can be introduced
into the system.  The technique is contrasted 
with the use of the paradoxical combinator, Y.  The
questions of local and global environments and of 
various modes of function calling and parameter passing
are touched upon. The theory is applied to the 
proof of several elementary theorems concerning the semantics
of the assignment, conditional, and iterative 
statements.  An appendix is included which presents in
detail the formal system governing webs and fen, 
the abstractions used informally in the body of the paper.

CACM August, 1973

MacLennan, B. J.

semantics, formal systems, lambda-calculus, extensible
languages, data types, modes, axioms, correctness, 
formal language definition, formal description, data structures,
description languages, models of computation

4.22 5.21 5.24 5.26

CA730804 JB January 23, 1978  11:01 AM

1469	4	2470
1486	4	2470
1491	4	2470
1781	4	2470
2021	4	2470
2060	4	2470
2178	4	2470
2222	4	2470
2227	4	2470
2294	4	2470
2315	4	2470
2326	4	2470
2326	4	2470
2470	4	2470
2470	4	2470
2470	4	2470
2470	4	2470
2684	4	2470
2732	4	2470
2865	4	2470
2896	4	2470
2943	4	2470
3014	4	2470
3044	4	2470
3068	4	2470
3077	4	2470
3124	4	2470
3143	4	2470
1303	5	2470
1469	5	2470
1834	5	2470
2264	5	2470
2470	5	2470
2470	5	2470
2470	5	2470


************************

************************
Document:  CACM-2060.html
************************


GEDANKEN-A Simple Typeless Language Based on the
Principle of Completeness and the Reference Concept

GEDANKEN is an experimental programming language with <B>the following</B> 
characteristics.  (1) Any value which is permitted in some context of the 
language is permissible in any other meaningful context.  In particular,
functions and labels are permissible  results of functions and values
of variables.  (2) Assignment and indirect addressing are formalized
by introducing values, called reference, which in turn possess
other values.  The assignment operation always affects the relation
between some reference and its value,  (3) All compound data
structures are treated as functions.  (4) Type declarations are
not permitted.  The functional approach to data structures and the
use of references insure that any process which accepts some data
structure will accept any logically equivalent structure, regardless
of its internal representation.  More generally, any data structure
may be implicit; i.e. it may be specified by giving an arbitrary
algorithm for computing or accessing its components.  The existence of 
label variables permits the construction of coroutines,
quasi-parallel processes, and other unorthodox control mechanisms.
A variety of programming examples illustrates the generality of the language.
Limitations and possible extensions are discussed briefly.

CACM May, 1970

Reynolds, J. C.

programming language, data structure, reference, assignment, coroutine,
quasi-parallel process, typeless language, applicative language,
lambda calculus, list processing, nondeterministic algorithm

4.20 4.22 5.23 5.24

CA700506 JB February 13, 1978  1:43 PM

1024	4	2060
1051	4	2060
1102	4	2060
1132	4	2060
1379	4	2060
1380	4	2060
1390	4	2060
1486	4	2060
1541	4	2060
1542	4	2060
1549	4	2060
1552	4	2060
1683	4	2060
1693	4	2060
1693	4	2060
1693	4	2060
1706	4	2060
1781	4	2060
1781	4	2060
1781	4	2060
1787	4	2060
1826	4	2060
1836	4	2060
1836	4	2060
1846	4	2060
1854	4	2060
1860	4	2060
1878	4	2060
1945	4	2060
1945	4	2060
1989	4	2060
378	4	2060
2015	4	2060
2060	4	2060
2060	4	2060
2060	4	2060
2060	4	2060
2060	4	2060
2060	4	2060
2060	4	2060
2060	4	2060
2061	4	2060
2061	4	2060
2082	4	2060
2091	4	2060
2091	4	2060
2155	4	2060
2152	4	2060
2168	4	2060
2179	4	2060
2179	4	2060
2179	4	2060
2218	4	2060
2294	4	2060
2340	4	2060
2356	4	2060
2470	4	2060
2546	4	2060
2546	4	2060
2603	4	2060
2698	4	2060
2698	4	2060
2698	4	2060
2708	4	2060
2708	4	2060
2719	4	2060
2723	4	2060
2770	4	2060
2824	4	2060
2838	4	2060
2842	4	2060
2855	4	2060
2879	4	2060
2921	4	2060
2982	4	2060
2986	4	2060
557	4	2060
3045	4	2060
3045	4	2060
3077	4	2060
3080	4	2060
3093	4	2060
3106	4	2060
3112	4	2060
3124	4	2060
3154	4	2060
627	4	2060
106	4	2060
210	5	2060
1380	5	2060
1421	5	2060
1469	5	2060
1477	5	2060
1491	5	2060
1869	5	2060
2060	5	2060
2060	5	2060
2060	5	2060
2110	5	2060
2155	5	2060
2294	5	2060
2558	5	2060
2842	5	2060
3077	5	2060
3150	5	2060
1389	6	2060
1469	6	2060
1471	6	2060
210	6	2060
210	6	2060
210	6	2060
1834	6	2060
378	6	2060
2046	6	2060
2060	6	2060
2060	6	2060
2060	6	2060
2060	6	2060
2060	6	2060
2060	6	2060
2148	6	2060
2192	6	2060
2457	6	2060
2704	6	2060
2842	6	2060
2939	6	2060
2940	6	2060
2941	6	2060
2943	6	2060
3073	6	2060
3148	6	2060
3184	6	2060


************************



GEDANKEN-A Simple Typeless Language Based <B>on the</B>
Principle of Completeness and the Reference Concept

GEDANKEN is an experimental programming language with the following 
characteristics.  (1) Any value which is permitted in some context of the 
language is permissible in any other meaningful context.  In particular,
functions and labels are permissible  results of functions and values
of variables.  (2) Assignment and indirect addressing are formalized
by introducing values, called reference, which in turn possess
other values.  The assignment operation always affects the relation
between some reference and its value,  (3) All compound data
structures are treated as functions.  (4) Type declarations are
not permitted.  The functional approach to data structures and the
use of references insure that any process which accepts some data
structure will accept any logically equivalent structure, regardless
of its internal representation.  More generally, any data structure
may be implicit; i.e. it may be specified by giving an arbitrary
algorithm for computing or accessing its components.  The existence of 
label variables permits the construction of coroutines,
quasi-parallel processes, and other unorthodox control mechanisms.
A variety of programming examples illustrates the generality of the language.
Limitations and possible extensions are discussed briefly.

CACM May, 1970

Reynolds, J. C.

programming language, data structure, reference, assignment, coroutine,
quasi-parallel process, typeless language, applicative language,
lambda calculus, list processing, nondeterministic algorithm

4.20 4.22 5.23 5.24

CA700506 JB February 13, 1978  1:43 PM

1024	4	2060
1051	4	2060
1102	4	2060
1132	4	2060
1379	4	2060
1380	4	2060
1390	4	2060
1486	4	2060
1541	4	2060
1542	4	2060
1549	4	2060
1552	4	2060
1683	4	2060
1693	4	2060
1693	4	2060
1693	4	2060
1706	4	2060
1781	4	2060
1781	4	2060
1781	4	2060
1787	4	2060
1826	4	2060
1836	4	2060
1836	4	2060
1846	4	2060
1854	4	2060
1860	4	2060
1878	4	2060
1945	4	2060
1945	4	2060
1989	4	2060
378	4	2060
2015	4	2060
2060	4	2060
2060	4	2060
2060	4	2060
2060	4	2060
2060	4	2060
2060	4	2060
2060	4	2060
2060	4	2060
2061	4	2060
2061	4	2060
2082	4	2060
2091	4	2060
2091	4	2060
2155	4	2060
2152	4	2060
2168	4	2060
2179	4	2060
2179	4	2060
2179	4	2060
2218	4	2060
2294	4	2060
2340	4	2060
2356	4	2060
2470	4	2060
2546	4	2060
2546	4	2060
2603	4	2060
2698	4	2060
2698	4	2060
2698	4	2060
2708	4	2060
2708	4	2060
2719	4	2060
2723	4	2060
2770	4	2060
2824	4	2060
2838	4	2060
2842	4	2060
2855	4	2060
2879	4	2060
2921	4	2060
2982	4	2060
2986	4	2060
557	4	2060
3045	4	2060
3045	4	2060
3077	4	2060
3080	4	2060
3093	4	2060
3106	4	2060
3112	4	2060
3124	4	2060
3154	4	2060
627	4	2060
106	4	2060
210	5	2060
1380	5	2060
1421	5	2060
1469	5	2060
1477	5	2060
1491	5	2060
1869	5	2060
2060	5	2060
2060	5	2060
2060	5	2060
2110	5	2060
2155	5	2060
2294	5	2060
2558	5	2060
2842	5	2060
3077	5	2060
3150	5	2060
1389	6	2060
1469	6	2060
1471	6	2060
210	6	2060
210	6	2060
210	6	2060
1834	6	2060
378	6	2060
2046	6	2060
2060	6	2060
2060	6	2060
2060	6	2060
2060	6	2060
2060	6	2060
2060	6	2060
2148	6	2060
2192	6	2060
2457	6	2060
2704	6	2060
2842	6	2060
2939	6	2060
2940	6	2060
2941	6	2060
2943	6	2060
3073	6	2060
3148	6	2060
3184	6	2060


************************

************************
Document:  CACM-2184.html
************************


On the Meaning of Names in Programming Systems

It is assumed that there is a similarity of
function between the data names of a programming 
language and the file names of an operating system.
 The two functions are discussed in terms of the 
same basic concepts in order to identify the extent
to which they overlap. It is suggested that there 
is some similarity between the idea of a file directory
and a storable object of type context.  Manipulations 
with contexts are then discussed at length.  It is noted
that there is a simple extension of Church's 
Lambda notation that deals nicely with these ideas of
context manipulation.  Whereas a function can be 
regarded as the abstraction based upon the first two terms of
the expression Lambda(name list)(expression)(value list), 
it is found that a context can be viewed as an abstraction
based upon the first two terms <B>in the</B> equivalent 
expression Mu(name list)(value list)(expression).

CACM July, 1971

Fraser, A. G.

file, operating system, programming language, functions,
names, context, file directory, file dictionary, 
lambda calculus, theory of programming

3.73 4.22 4.39 5.23 5.24

CA710606 JB February 3, 1978  9:58 AM

2184	5	2184
2184	5	2184
2184	5	2184


************************



On the Meaning of Names in Programming Systems

It is assumed that there is a similarity of
function between the data names of a programming 
language and the file names of an operating system.
 The two functions are discussed in terms of the 
same basic concepts in order to identify the extent
to which they overlap. It is suggested that there 
is some similarity between the idea of a file directory
and a storable object of type context.  Manipulations 
with contexts are then discussed at length.  It is noted
that there is a simple extension of Church's 
Lambda notation that deals nicely with these ideas of
context manipulation.  Whereas a function can be 
regarded as the abstraction based up<B>on the</B> first two terms of
the expression Lambda(name list)(expression)(value list), 
it is found that a context can be viewed as an abstraction
based upon the first two terms in the equivalent 
expression Mu(name list)(value list)(expression).

CACM July, 1971

Fraser, A. G.

file, operating system, programming language, functions,
names, context, file directory, file dictionary, 
lambda calculus, theory of programming

3.73 4.22 4.39 5.23 5.24

CA710606 JB February 3, 1978  9:58 AM

2184	5	2184
2184	5	2184
2184	5	2184


************************

************************
Document:  CACM-3132.html
************************


Experiments with Some Algorithms that Find
Central Solutions for Pattern Classification

In two-class pattern recognition, it is a standard
technique to have an algorithm finding hyperplanes
which separates the two classes in a linearly separable training
set.  The traditional methods find a hyperplane which separates all
points <B>in the</B> other, but such a hyperplane is not necessarily centered
in the empty space between the two classes.  Since a central
hyperplane does not favor one class or the other, it should have
a lower error rate in classifying new points and is therefore better
than a noncentral hyperplane.  Six algorithms for finding central
hyperplanes are tested on three data sets.  Although frequently
used practice, the modified relaxation algorithm is very poor. 
Three algorithms which are defined in the paper are found to be
quite good.

CACM March, 1979

Slagle, J.

Pattern recognition, pattern classification, linear discriminants, central
hyperplanes, centering, centrality criteria, dead zone, hyperplane,
linearly separable, relaxation algorithm, accelerated relaxation

3.62 3.63

CA790303 DH April 12, 1979  3:20 PM

3132	4	3132
2215	5	3132
3132	5	3132
3132	5	3132
3132	5	3132


************************

************************
Document:  CACM-2450.html
************************


Empirical Working Set Behavior

The working set model for program behavior
has been proposed in recent years as a basis for 
the design of scheduling and paging algorithms.  Although
the words "working set" are now commonly encountered 
<B>in the</B> literature dealing with resource allocation, there
is a dearth of published data on program measurements, 
in the hope that workers in the field might find experimental
evidence upon which to substantiate and 
base theoretical work.

CACM September, 1973

Rodriguez-Rosell, J.

virtual memory, paging, working set,
software measurement, program behavior

4.3

CA730905 JB January 23, 1978  9:22 AM

2373	4	2450
2374	4	2450
2380	4	2450
2450	4	2450
2450	4	2450
2595	4	2450
2996	4	2450
3006	4	2450
3006	4	2450
3067	4	2450
3067	4	2450
2373	5	2450
2374	5	2450
2450	5	2450
2450	5	2450
2450	5	2450


************************



Empirical Working Set Behavior

The working set model for program behavior
has been proposed in recent years as a basis for 
the design of scheduling and paging algorithms.  Although
the words "working set" are now commonly encountered 
in the literature <B>dealing with</B> resource allocation, there
is a dearth of published data on program measurements, 
in the hope that workers in the field might find experimental
evidence upon which to substantiate and 
base theoretical work.

CACM September, 1973

Rodriguez-Rosell, J.

virtual memory, paging, working set,
software measurement, program behavior

4.3

CA730905 JB January 23, 1978  9:22 AM

2373	4	2450
2374	4	2450
2380	4	2450
2450	4	2450
2450	4	2450
2595	4	2450
2996	4	2450
3006	4	2450
3006	4	2450
3067	4	2450
3067	4	2450
2373	5	2450
2374	5	2450
2450	5	2450
2450	5	2450
2450	5	2450


************************

************************
Document:  CACM-3125.html
************************


Global Optimization by Suppression of Partial Redundancies

The elimination of redundant computations and the moving of invariant
computations out of loops are often done separately, with invariants 
moved outward loop by loop.  We propose to do both at once and
to move each expression directly to the entrance of the outermost
loop in which it is invariant.  This is done by solving a more
general problem, i.e. the elimination of computations performed
twice on a given execution path.  Such computations are termed partially
redundant.  Moreover, the algorithm does not require any graphical
information or restrictions <B>on the</B> shape of the program graph.
Testing this algorithm has shown that its execution cost is nearly
linear with the size of the program, and that it leads
to a smaller optimizer that requires less execution time.

CACM February, 1979

Morel, E.
Renvoise, C.

Optimizer, optimization, compiler, compilation,
redundancy elimination, invariant
 computation elimination, partial redundancy,
data flow analysis, Boolean systems

4.12 5.21 5.24

CA790204 DH April 10, 1979  4:19 PM

3125	5	3125
3125	5	3125
3125	5	3125


************************

************************
Document:  CACM-2002.html
************************


AMESPLOT-A Higher Level Data Plotting Software System

AMESPLOT is an extensible software system designed to make the display of 
data as simple, painless, and neat as possible.  The system described is 
hardware-independent and has been implemented on a variety of installations,
of different manufacturers, having diverse configurations.  The elements 
common to all types of data plots are outlined and the way in which these 
elements may be combined into a system based on simple modules is demonstrated.
These modules are specified independently and are independent of the axis
systems or other attributes of the plot.  This enables plots of any
complexity to be constructed by adding or replacing modules.  The
basic syntax of AMESPLOT is outlined, and a brief description is given
of its current utility software, consisting of "macros" to produce
self-scaled plots, formal tablets of text-interspersed with subplots,
map coastlines, and 3-D plots.  The system was formulate
d in a way such that the user could supply the minimum of information,
and it should be fully integrable with user's program written
in most conventional higher languages.  The functions of positioning,
locating, and scaling (<B>in the</B> layout of multiple subplots) of
axes, labels, and all other elements of the plot are handled automatically
by the software system unless the user specifies otherwise.  The structuring 
of plots from multiple, independent, self-contained subplots is described.
Transformation, projection, scaling, rotation, or shifting of entire plots or 
subplots by the action of one or more simple modules is possible.  The user 
may interact freely with AMESPLOT at three levels, enabling him to construct 
his own data markers, alphabetic characters, and transformations, and
to produce a variety of artistic and other effects.

CACM September, 1970

Hirschsoln, I.

computer graphics, data potting, data display
syntax, hardware independent software,
display device independent software, plot elements, self-scaled plots,
user interaction, tablet organization, map display, projection

4.13 4.29 4.49 4.9

CA700903 JB February 10, 1978 2:08 PM

2003	4	2002
2002	4	2002
2002	4	2002
2152	4	2002
1767	5	2002
1937	5	2002
2002	5	2002
2002	5	2002
2002	5	2002


************************

************************
Document:  CACM-2651.html
************************


The Treatment of Data Types in EL1

In constructing a general purpose programming
language, a key issue is providing a sufficient 
set of data types and associated operations in a manner
that permits both natural problem-oriented notation 
and efficient implementation.  The EL1 language contains
a number of features specifically designed to 
simultaneously satisfy both requirements.  The resulting
treatment of data <B>types in</B>cludes provision for 
programmer-defined data types data types and generic
routines, programmer control over type conversion, 
and very flexible data type behavior, in a context that
allows efficient compiled code and compact data 
representation.

CACM May, 1974

Wegbreit, B.

data types, modes, mode unions, type conversion,
coercion, generic functions, extensible languages, 
data type definition, data description language, compilation

4.12 4.13 4.22

CA740502 JB January 17, 1978  4:32 PM

2651	5	2651
2651	5	2651
2651	5	2651
2723	5	2651
2941	5	2651
2956	5	2651
3030	5	2651
1379	6	2651
1471	6	2651
1549	6	2651
1749	6	2651
1826	6	2651
210	6	2651
2247	6	2651
2356	6	2651
2356	6	2651
2457	6	2651
2558	6	2651
2651	6	2651
2651	6	2651
2651	6	2651
2651	6	2651
2958	6	2651
2972	6	2651
627	6	2651
731	6	2651


************************



The Treatment of Data Types in EL1

In constructing a general purpose programming
language, a key issue is providing a sufficient 
set of <B>data types</B> and associated operations in a manner
that permits both natural problem-oriented notation 
and efficient implementation.  The EL1 language contains
a number of features specifically designed to 
simultaneously satisfy both requirements.  The resulting
treatment of data types includes provision for 
programmer-defined data types data types and generic
routines, programmer control over type conversion, 
and very flexible data type behavior, in a context that
allows efficient compiled code and compact data 
representation.

CACM May, 1974

Wegbreit, B.

data types, modes, mode unions, type conversion,
coercion, generic functions, extensible languages, 
data type definition, data description language, compilation

4.12 4.13 4.22

CA740502 JB January 17, 1978  4:32 PM

2651	5	2651
2651	5	2651
2651	5	2651
2723	5	2651
2941	5	2651
2956	5	2651
3030	5	2651
1379	6	2651
1471	6	2651
1549	6	2651
1749	6	2651
1826	6	2651
210	6	2651
2247	6	2651
2356	6	2651
2356	6	2651
2457	6	2651
2558	6	2651
2651	6	2651
2651	6	2651
2651	6	2651
2651	6	2651
2958	6	2651
2972	6	2651
627	6	2651
731	6	2651


************************

************************
Document:  CACM-0867.html
************************


Least Squares Fitting of Planes to Surfaces Using Dynamic Programming

Dynamic programming has recently been used
by Stone, by Bellman and by Gluss to determine the 
closet fit of broken line segments to a curve in an
interval under the constraint that the number of 
segments is fixed.  In the present paper successive
models are developed to extend the method to the 
fitting of broken plane segments to surfaces z=g(x,y) defined
over certain types of subareas of the (x,y)-space. 
 The first model considers a rectangular area, with
the constraint that the plane segments are defined 
over a grid <B>in the</B> (x,y)-space.  It is then shown how
this model may be incorporated into an algorithm 
that provides successive approximations to optimal fits
for any type of closed area.  Finally, applications 
are briefly described.

CACM April, 1963

Gluss, B.

CA630424 JB March 14, 1978  11:43 AM

497	4	867
867	4	867
867	4	867
317	5	867
497	5	867
867	5	867
867	5	867
867	5	867


************************

************************
Document:  CACM-1143.html
************************


Analysis of Decay-Type Data*

A comparative study has been made of a variety
of numerical techniques for fitting experimental 
data of the decay type by forms involving the sums of
exponentials.  Statistical errors of the fitted 
parameters are also calculated.  These methods have been
applied to artificially-generated sets of data 
as well as to the results of experiments with radioactive
tracers on both human and animal subjects. 
 Results show that the values of the fitted parameters
are very sensitive to variations <B>in the</B> fitting 
procedure.  Therefore great care very sensitive to variations
in the fitting procedure.  Therefore great 
care must be exercised in identifying such values with
physical constants.  Although the values of functions 
derived from these fitted parameters which can definitely
be associated with physical entities are generally 
more stable under variations in the fitting techniques,
error bounds can be so large that no great confidence 
can be placed even in them.  It would therefore appear
best to select a uniform technique both for running 
the experiments and for analyzing the data, and then
to consider as significant only relative results 
between one subject and the next.

CACM January, 1964

Worsley, B. H.

CA640112 JB March 10, 1978 5:11 AM

1143	5	1143
1143	5	1143
1143	5	1143


************************

************************
Document:  CACM-1476.html
************************


Control Procedures for Data Communication-An ASA Progress Report

Sectional Committee X.3 of the American Standards
Association, has charged one of its task 
groups, X3.3.4, with the responsibility to "Define and specify
functional control requirements and characteristics 
governing the operation of digital data generating and
receiving systems interconnected by communication 
system."  This effort is primarily directed toward systems
employing the American Standard Code for Information 
Interchange (ASCII).  This paper represents a progress
report on the work of this group toward a proposal 
for national and international standardization <B>in the</B>
field of control procedures.  It describes both 
the old and new work of the task group.  The new work
is presented in detail, while the work that has 
been presented in earlier papers ["Control Procedures for
Data Communication," Task Group document X3.3.4/44, 
May 1964: "Transparent-Mode Control Procedures for Data
Communication," Task Group document X3.3.4/58, 
December, 1964: Comm. ACM 8 (Apr. 1965), 203-206; "Control
Procedures for Data Communications," Task 
Group document X3.3.4/60, March, 1965] is retained here
in summary form.  Many of the concepts and principles 
described herein have been submitted to the International
Organization for Standardization via earlier 
papers and are now embodied in working papers of that organization. 

CACM February, 1966

CA660208JB March 3, 1978  3:04 PM

1476	5	1476
1476	5	1476
1476	5	1476


************************



Control Procedures for Data Communication-An ASA Progress Report

Sectional Committee X.3 of the American Standards
Association, has charged one of its task 
groups, X3.3.4, with the responsibility to "Define and specify
functional control requirements and characteristics 
governing the operation of digital data generating and
receiving systems interconnected by communication 
system."  This effort is primarily directed toward systems
employing the American Standard Code for Information 
Interchange (ASCII).  This paper represents a progress
report <B>on the</B> work of this group toward a proposal 
for national and international standardization in the
field of control procedures.  It describes both 
the old and new work of the task group.  The new work
is presented in detail, while the work that has 
been presented in earlier papers ["Control Procedures for
Data Communication," Task Group document X3.3.4/44, 
May 1964: "Transparent-Mode Control Procedures for Data
Communication," Task Group document X3.3.4/58, 
December, 1964: Comm. ACM 8 (Apr. 1965), 203-206; "Control
Procedures for Data Communications," Task 
Group document X3.3.4/60, March, 1965] is retained here
in summary form.  Many of the concepts and principles 
described herein have been submitted to the International
Organization for Standardization via earlier 
papers and are now embodied in working papers of that organization. 

CACM February, 1966

CA660208JB March 3, 1978  3:04 PM

1476	5	1476
1476	5	1476
1476	5	1476


************************

************************
Document:  CACM-2717.html
************************


CONVERT: A High Level Translation
Definition Language for Data Conversion

This paper describes a high level and nonprocedural
translation definition language, CONVERT, 
which provides very powerful and highly flexible data
restructuring capabilities. Its design is based 
<B>on the</B> simple underlying concept of a form which enables
the users to visualize the translation processes, 
and thus makes data translation a much simpler task. 
"CONVERT" has been chosen for conveying the purpose 
of the language and should not be confused with any
other language or program bearing the same name.

CACM October, 1975

Shu, N. C.
Housel, B. C.
Lum, V. Y.

data conversion, data restructuring, data translation,
database reorganization, translation definition, 
utility program, programming languages, nonprocedural languages

3.50 3.75 4.29 4.4 4.9

CA751002 JB January 6, 1978  1:45 PM

2155	4	2717
2406	4	2717
2710	4	2717
2715	4	2717
2716	4	2717
2717	4	2717
2717	4	2717
2718	4	2717
2765	4	2717
2817	4	2717
2888	4	2717
2901	4	2717
2957	4	2717
2959	4	2717
2965	4	2717
3087	4	2717
3154	4	2717
2046	5	2717
2406	5	2717
2717	5	2717
2717	5	2717
2717	5	2717


************************

************************
Document:  CACM-2051.html
************************


A PL/I Program to Assist the Comparative Linguist

A practical PL/I program is described which
can assist comparative linguists to determine
the regular sound correspondences between genetically related languages.
The investigator must arrange data for input by aligning pairs
of suspected cognates.  The program tabulates the correspondences,
and uses list processing techniques to sort and count them.
Each pair of words is then assigned a relative value that is a function
of the total frequency <B>in the</B> data of each correspondence found
in that pair of words.  The output is a list of all correspondence
types with their frequency of occurrence in the data, and a
separate listing of each correspondence with all word-pairs showing
that correspondence (unless their relative value is below an arbitrarily 
chosen cutoff point).  The article explains the usefulness,
as well as the limitations, of the programs, and illustrates its
use with a small portion of hypothetical data.

CACM June, 1970

Frantz, D. G.

comparative linguistics, natural
language processing, comparative method, historical linguistics, diachronic
linguistics, genetic relationship, sound change, sound
correspondence, regular correspondence, list processing

3.42

CA700604 JB February 13, 1978  11:51 AM

2051	5	2051
2051	5	2051
2051	5	2051


************************

************************
Document:  CACM-3164.html
************************


Progressive Acyclic Digraphs-A Tool for Database Integrity

A progressive acyclic digraph (PAD) algorithm accepts are requests and
maintains a graph in an acyclic state.  When a request creates a cycle,
nodes are, "detached" until the new are can be entered acyclically
This process is important in certain areas of database implementation
in which there are constraints <B>on the</B> permissible sequences
of actions. Two PAD algorithms are presented; one uses a simple
path matrix representation and the other uses a list with an
"artificial gradient."  Experiments suggest that for large N the second
is considerably faster, though both are asymptotically O(NR),
where N is the number of nodes and R is the expected number
of nodes reachable along paths from any given node.

CACM September, 1979

Hansen, W.

List processing, data structures, topological sort,
acyclic digraph, database integrity, network, deadlock

4.34 5.32 4.33

CA790905 DB January 14, 1980  11:56 AM

3164	4	3164
1712	5	3164
3164	5	3164
3164	5	3164
3164	5	3164


************************

************************
Document:  CACM-2106.html
************************


Computer Education in a Graduate School of Management

Several years of experience have led to the belief that the creative
design and evaluation of management information systems requires
a thorough understanding of the related computer technology.  Concepts
such as paging and priority interrupt systems can best be explained at the 
machine language level.  Any machine used for exposition
should fulfill several criteria.  It should: (1) raise as few
spurious issues as possible; (2) allow, without undue effort, the
solution of interesting problems; (3) be capable of exposing all
outstanding issues of significance, capable of exposing all outstanding
issues of significance, with<B>in the</B> chosen machine; (4) be
seful for pursuing issues in great depth when appropriate; (5) not
be committed to the equipment provided by any manufacturer; (6) be able to 
provide the student with diagnostic aids to a great depth;
(7) allow the student ready access to the machine; (8) be capable
of extension to expose new issues as they come along.  We have
constructed a simulated machine and its associated software which
meets these criteria.  This system, called the PRISM system,
is documented by a primer and a reference manual.

CACM February, 1970

Ness, D. N.
Green, R. S.
Martin, W. A.
Moulton, G. A.

education, simulation, machine language,
management information systems, interpreters

1.52 3.51 4.13 4.21

CA700209 JB February 14, 1978  10:15 AM

2106	5	2106
2106	5	2106
2106	5	2106


************************

************************
Document:  CACM-1066.html
************************


Growing Applications of Linear Programming

Use of linear programming models has grown so
extensively in recent years that the whole concept 
for organizing a computer code has undergone a radical
change.  It no longer is adequate merely to reduce 
a mathematical algorithm (i.e. the simplex method) to
a computer code.  An advanced code must cope with 
such a variety of situations that the respective computer
subprograms must be organized into an integrated 
system.  Emphasis in this paper is devoted to the underlying
principles upon which future linear programming 
systems must be based.  These viewpoints are influenced
by the new demands that applications within the 
petroleum industry are placing on such systems.  Some
of the components of such a system are: translation 
of problem statement in terms of basic data to linear
programming matrix coefficients, data transmission 
for direct computer entry, data file at the computer center,
data processing and editing prior to solving 
the simplex algorithm, an efficient and reliable code
for solving <B>the above</B>-mentioned algorithm, and 
flexible means for summarizing the results.

CACM June, 1964

Aronofsky, J. S.

CA640601 JB March 9, 1978  9:55 PM

1066	5	1066
1066	5	1066
1066	5	1066


************************



Growing Applications of Linear Programming

Use of linear programming models has grown so
extensively in recent years that the whole concept 
for organizing a computer code has undergone a radical
change.  It no longer is adequate merely to reduce 
a mathematical algorithm (i.e. the simplex method) to
a computer code.  An advanced code must cope with 
such a variety of situations that the respective computer
subprograms must be organized into an integrated 
system.  Emphasis in this paper is devoted to the underlying
principles upon which future linear programming 
systems must be based.  These viewpoints are influenced
by the new demands that applications with<B>in the</B> 
petroleum industry are placing on such systems.  Some
of the components of such a system are: translation 
of problem statement in terms of basic data to linear
programming matrix coefficients, data transmission 
for direct computer entry, data file at the computer center,
data processing and editing prior to solving 
the simplex algorithm, an efficient and reliable code
for solving the above-mentioned algorithm, and 
flexible means for summarizing the results.

CACM June, 1964

Aronofsky, J. S.

CA640601 JB March 9, 1978  9:55 PM

1066	5	1066
1066	5	1066
1066	5	1066


************************

************************
Document:  CACM-2036.html
************************


An Interactive Command Generating Facility

A facility to permit conversationally controlled tasks
to be executed in a noninteractive environment is proposed.
A means by which programs can generate interactive time-sharing commands
and receive the corresponding output response is presented.  The commands 
will be invoked as if they had been typed at a console keyboard.  It is 
argued that this facility will help overcome some of the current limitations 
in man-computer communication. A set of functions to accomplish <B>the above</B> 
which could be embedded into any string processing language is suggested, 
and necessary information pertinent to implementation of the facility on 
existing time-sharing systems is given.

CACM July, 1970

Grant, C. A.

time-sharing, command languages, pseudo-teletype, interaction,
conditional job control, operating systems

3.80 3.81 4.29 4.39

CA700701 JB February 13, 1978  9:43 AM

1530	4	2036
1531	4	2036
1565	4	2036
1703	4	2036
1945	4	2036
2036	4	2036
1455	5	2036
2036	5	2036
2036	5	2036
2036	5	2036


************************

************************
Document:  CACM-2939.html
************************


Abstraction Mechanisms in CLU

CLU is a new programming language designed to support
the use of abstractions in program construction. 
 Work in programming methodology has led to the realization
that three kinds of abstractions-procedural, 
control, and especially data abstractions-are useful
in the programming process.  Of these, only the 
procedural abstraction is supported well by conventional
languages, through the procedure or subroutine. 
 CLU provides, in addition to procedures, novel linguistic
mechanisms that support the use of data and 
control abstractions.  This paper provides an in troduction
to the abstraction mechanisms in CLU.  By 
means of programming examples, the utility of the three
kinds of abstractions in program construction 
is illustrated, and it is shown how CLU programs may
be written to use and implement abstractions.  The 
CLU library, which permits incremental program development
with complete type checking performed at compile 
time, is also discussed.

CACM August, 1977

Liskov, B.
Snyder, A.
Atkinson, R.
Schaffert, C.

programming languages, <B>data types</B>, data abstractions,
control abstractions, programming methodology, 
separate compilation

4.0 4.12 4.20 4.22

CA770804 JB December 28, 1977  7:49 AM

2319	4	2939
2480	4	2939
2594	4	2939
2709	4	2939
2868	4	2939
2939	4	2939
2939	4	2939
2941	4	2939
2972	4	2939
3155	4	2939
2204	5	2939
2558	5	2939
2939	5	2939
2939	5	2939
2939	5	2939
3031	5	2939
3105	5	2939
3148	5	2939
3150	5	2939
1471	6	2939
1860	6	2939
2060	6	2939
2625	6	2939
2632	6	2939
2704	6	2939
2817	6	2939
2842	6	2939
2865	6	2939
2868	6	2939
2939	6	2939
2939	6	2939
2939	6	2939
2939	6	2939
2940	6	2939
2941	6	2939
2943	6	2939
2958	6	2939
3068	6	2939
3073	6	2939
3073	6	2939
3148	6	2939


************************



Abstraction Mechanisms in CLU

CLU is a new programming language designed to support
the use of abstractions in program construction. 
 Work in programming methodology has led to the realization
that three kinds of abstractions-procedural, 
control, and especially data abstractions-are useful
<B>in the</B> programming process.  Of these, only the 
procedural abstraction is supported well by conventional
languages, through the procedure or subroutine. 
 CLU provides, in addition to procedures, novel linguistic
mechanisms that support the use of data and 
control abstractions.  This paper provides an in troduction
to the abstraction mechanisms in CLU.  By 
means of programming examples, the utility of the three
kinds of abstractions in program construction 
is illustrated, and it is shown how CLU programs may
be written to use and implement abstractions.  The 
CLU library, which permits incremental program development
with complete type checking performed at compile 
time, is also discussed.

CACM August, 1977

Liskov, B.
Snyder, A.
Atkinson, R.
Schaffert, C.

programming languages, data types, data abstractions,
control abstractions, programming methodology, 
separate compilation

4.0 4.12 4.20 4.22

CA770804 JB December 28, 1977  7:49 AM

2319	4	2939
2480	4	2939
2594	4	2939
2709	4	2939
2868	4	2939
2939	4	2939
2939	4	2939
2941	4	2939
2972	4	2939
3155	4	2939
2204	5	2939
2558	5	2939
2939	5	2939
2939	5	2939
2939	5	2939
3031	5	2939
3105	5	2939
3148	5	2939
3150	5	2939
1471	6	2939
1860	6	2939
2060	6	2939
2625	6	2939
2632	6	2939
2704	6	2939
2817	6	2939
2842	6	2939
2865	6	2939
2868	6	2939
2939	6	2939
2939	6	2939
2939	6	2939
2939	6	2939
2940	6	2939
2941	6	2939
2943	6	2939
2958	6	2939
3068	6	2939
3073	6	2939
3073	6	2939
3148	6	2939


************************

************************
Document:  CACM-2265.html
************************


A Model for Type Checking

Most current programming languages treat computation
over different classes of objects (e.g. 
numbers, strings, labels and functions).  For correct
compilation and execution, the following question 
then arises: is a program properly constructed so that
its operations and operands are compatible?  The 
activity of answering this question is usually called
type checking.  This paper attempts to isolate 
the notion of type checking and presents a partial
solution to the type checking problem based on the 
notions of abstraction and application of functions. 
In particular, a program is mapped into an expression 
within a decidable subset of the Lambda calculus, which
characterizes the type relations with<B>in the</B> program 
and eliminates all other information.  The determination
of the type-wise correctness or incorrectness 
of the program is resolved by reducing its corresponding
Lambda calculus expression to one of two normal 
forms, the constant "correct" for a type-wise correct
program or the constant "error".  An application 
to type checking in Algol 60 is made, and the attendant
problems faced for any notion of type checking 
are discussed.

CACM November, 1972

Ledgard, H. F.

type checking, types, Lambda calculus, models for
programming languages, syntax, semantics, compiler 
writing, language implementation, formal definition

4.12 4.22 5.2 5.21 5.23

CA721104 JB January 27, 1978  2:30 PM

2265	5	2265
2265	5	2265
2265	5	2265


************************



A Model for Type Checking

Most current programming languages treat computation
over different classes of objects (e.g. 
numbers, strings, labels and functions).  For correct
compilation and execution, the following question 
then arises: is a program properly constructed so that
its operations and operands are compatible?  The 
activity of answering this question is usually called
type checking.  This paper attempts to isolate 
the notion of type checking and presents a partial
solution to the type checking problem based <B>on the</B> 
notions of abstraction and application of functions. 
In particular, a program is mapped into an expression 
within a decidable subset of the Lambda calculus, which
characterizes the type relations within the program 
and eliminates all other information.  The determination
of the type-wise correctness or incorrectness 
of the program is resolved by reducing its corresponding
Lambda calculus expression to one of two normal 
forms, the constant "correct" for a type-wise correct
program or the constant "error".  An application 
to type checking in Algol 60 is made, and the attendant
problems faced for any notion of type checking 
are discussed.

CACM November, 1972

Ledgard, H. F.

type checking, types, Lambda calculus, models for
programming languages, syntax, semantics, compiler 
writing, language implementation, formal definition

4.12 4.22 5.2 5.21 5.23

CA721104 JB January 27, 1978  2:30 PM

2265	5	2265
2265	5	2265
2265	5	2265


************************



A Model for Type Checking

Most current programming languages treat computation
over different classes of objects (e.g. 
numbers, strings, labels and functions).  For correct
compilation and execution, <B>the following</B> question 
then arises: is a program properly constructed so that
its operations and operands are compatible?  The 
activity of answering this question is usually called
type checking.  This paper attempts to isolate 
the notion of type checking and presents a partial
solution to the type checking problem based on the 
notions of abstraction and application of functions. 
In particular, a program is mapped into an expression 
within a decidable subset of the Lambda calculus, which
characterizes the type relations within the program 
and eliminates all other information.  The determination
of the type-wise correctness or incorrectness 
of the program is resolved by reducing its corresponding
Lambda calculus expression to one of two normal 
forms, the constant "correct" for a type-wise correct
program or the constant "error".  An application 
to type checking in Algol 60 is made, and the attendant
problems faced for any notion of type checking 
are discussed.

CACM November, 1972

Ledgard, H. F.

type checking, types, Lambda calculus, models for
programming languages, syntax, semantics, compiler 
writing, language implementation, formal definition

4.12 4.22 5.2 5.21 5.23

CA721104 JB January 27, 1978  2:30 PM

2265	5	2265
2265	5	2265
2265	5	2265


************************

************************
Document:  CACM-2897.html
************************


A Case Study of a New Code Generation Technique for Compilers

Recent developments in optimizing techniques
have allowed a new design for compilers to emerge. 
 Such a compiler translates the parsed source code into
lower level code by a sequence of steps.  Each 
step expands higher level statements into blocks of
lower level code and then performs optimizations 
<B>on the</B> result.  Each statement has only one possible
expansion-the task of tailoring this code to take 
advantage of any special cases is done by the optimizations.
 This paper provides evidence that this 
strategy can indeed result in good object code.  The
traditionally difficult PL/I concatenate statement 
was investigated as a detailed example.  A set of fairly
simple optimizations was identified which allow 
the compiler to produce good code. More elaborate optimizations
can further improve the object code. 
 For most contexts of the concatenate statement, the code
produced by a compiler using the expansion-optimization 
strategy described above compares favorably with the
code produced by a conventional PL/I optimizing 
compiler.

CACM December, 1977

Carter, J. L.

compiler structure, optimizing compiler, code
generation, PL/I compiler, concatenation, program 
optimization, optimization techniques, data flow analysis

4.12 4.13 4.22

CA771203 JB February 1, 1980  3:54 AM

2897	5	2897
2897	5	2897
2897	5	2897


************************

************************
Document:  CACM-1459.html
************************


Requirements for Real-Time Languages

Real-time languages have different requirements
from other programming languages because of 
the special nature of their applications, the environment
in which their object programs are executed 
and the environment in which they may be compiled.  It
may not be the language extensions that ultimately 
advance developments <B>in the</B> field.  Progress may be made
by attacking the special compiling and executing 
system problems that must be solved.

CACM March, 1966

Opler, A.

CA660313 JB March 3, 1978  11:48 AM

1459	5	1459
1459	5	1459
1459	5	1459


************************

************************
Document:  CACM-2561.html
************************


A Heuristic Approach to Inductive Inference in Fact Retrieval Systems

Heuristic procedures are presented which have
been developed to perform inferences by generalizing 
from available information.  The procedures make use
of a similarity structure which is imposed on the 
data base using nonnumerical clustering algorithms.  They
are implemented in a model fact retrieval system 
which uses a formal query language and a property-list data
structure.  A program of experiments is described 
where<B>in the</B> procedures are used with test data bases
which are altered by deleting part of the data and 
by purposely introducing false data.  It is found that
the system can infer the correct response under 
a variety of conditions involving incomplete and inconsistent data.

CACM December, 1974

Skinner, C. W.

inference, inductive inference, clustering, fact retrieval, heuristics

3.61 3.71 3.79

CA741213 JB January 13, 1978  3:40 PM

2178	4	2561
2396	4	2561
2561	4	2561
2127	5	2561
2561	5	2561
2561	5	2561
2561	5	2561


************************



A Heuristic Approach to Inductive Inference in Fact Retrieval Systems

Heuristic procedures are presented which have
been developed to perform inferences by generalizing 
from available information.  The procedures make use
of a similarity structure which is imposed <B>on the</B> 
data base using nonnumerical clustering algorithms.  They
are implemented in a model fact retrieval system 
which uses a formal query language and a property-list data
structure.  A program of experiments is described 
wherein the procedures are used with test data bases
which are altered by deleting part of the data and 
by purposely introducing false data.  It is found that
the system can infer the correct response under 
a variety of conditions involving incomplete and inconsistent data.

CACM December, 1974

Skinner, C. W.

inference, inductive inference, clustering, fact retrieval, heuristics

3.61 3.71 3.79

CA741213 JB January 13, 1978  3:40 PM

2178	4	2561
2396	4	2561
2561	4	2561
2127	5	2561
2561	5	2561
2561	5	2561
2561	5	2561


************************

************************
Document:  CACM-1457.html
************************


Data Manipulation and Programming Problems
in Automatic Information Retrieval

Automatic information retrieval programs require
the manipulation of a variety of different 
data structures, including linear text, sparse matrices,
and tree or list structures.  The main data 
manipulations to be performed in automatic information
systems are first briefly reviewed.  A variety 
of data representations which have been used to describe
structured information are then examined, and 
the characteristics of various processing languages are
outlined <B>in the</B> light of the procedures requiring 
implementation.  Advantages of these programming languages
for the retrieval application are examined, 
and suggestions are made for the design of programming
facilities to aid in information retrieval.

CACM March, 1966

Salton, G.

CA660315 JB March 3, 1978  11:35 AM

1457	4	1457
1236	5	1457
1457	5	1457
1457	5	1457
1457	5	1457


************************

************************
Document:  CACM-1324.html
************************


Answering English questions by Computer: A Survey

Fifteen experimental English language question-answering
systems which are programmed and operating 
are described and reviewed.  The systems range from a conversation
machine to programs which make sentences 
about pictures and systems which translate from English
into logical calculi.  Systems are classified 
as list-structured data-based, graphic data-based, text-based
and inferential.  Principles and methods 
of operations are detailed and discussed.  It is concluded
that the data-base question-answer has passed 
from initial research into the early developmental
phase.  The most difficult and important research 
questions for the advancement of general-purpose language
processors are seen to be concerned with measuring, 
<B>dealing with</B> ambiguities, translating into formal
languages and searching large tree structures.

CACM January, 1965

Simmons, R. F.

CA650113 JB March 8, 1978  2:21 PM

1324	4	1324
1324	4	1324
1324	4	1324
892	4	1324
931	4	1324
1155	5	1324
1324	5	1324
1324	5	1324
1324	5	1324
1456	5	1324
1468	5	1324
1515	5	1324
1699	5	1324
1856	5	1324
2127	5	1324
634	5	1324
652	5	1324
653	5	1324
1155	6	1324
1155	6	1324
1194	6	1324
1225	6	1324
1324	6	1324
1324	6	1324
1324	6	1324
1324	6	1324
1324	6	1324
1324	6	1324
1324	6	1324
1487	6	1324
1527	6	1324
1553	6	1324
1681	6	1324
1781	6	1324
1856	6	1324


************************

************************
Document:  CACM-1612.html
************************


Top-to-bottom Parsing Rehabilitated?

This note is concerned with the efficiency
of the Top-to-Bottom parsing algorithm as used in 
connection with programming language grammars.  It is
shown, for instance, that retracing of unprofitable 
paths can often be eliminated by a suitable rearrangement
of the productions defining the grammar.  The 
essential weakness of the method is in <B>dealing with</B> complicated
syntactic structures which are in practice 
only sparsely occupied, e.g., arithmetic expressions.

CACM April, 1967

Brooker, R. A.

CA670403 JB February 28, 1978  11:32 AM

1612	4	1612
1781	4	1612
1945	4	1612
1139	5	1612
1612	5	1612
1612	5	1612
1612	5	1612


************************

************************
Document:  CACM-2081.html
************************


Some Complete Calculi for Matrices

A matrix calculus is introduced with the intention of developing data structures
suitable for a high level algorithmic language for mathematical programming.  
The paper investigates how the special structure of matrices can be described
and utilized for efficient computing by saving memory space and
superfluous operations.  Sequences of Matrices (and sequences of sequences
of matrices) are considered, and matrix operators areext
ended to sequence operators and cumulative operators.  Algorithms
are given which use symbol manipulation of matrix expressions so
as to find the forms best suited for computation.  These forms are
called normal forms.  Several completeness results are obtained
<B>in the</B> sense that for each expression an equivalent expression
in normal form can be found within a specified calculus.

CACM April, 1970

Bayer, R.
Witzgall, C.

complete calculus, data structures, linear
programming, matrix, matrix concatenation,
matrix sequences, programming languages,
sequence operations, symbol manipulation

4.12 4.22 5.14 5.41

CA700403 JB February 13, 1978  3:18 PM

2081	5	2081
2081	5	2081
2081	5	2081
2253	5	2081
2254	5	2081
2081	6	2081
2081	6	2081
437	6	2081


************************

************************
Document:  CACM-2937.html
************************


An Experimental Evaluation of Data Type Conventions

The language in which programs are written
can have a substantial effect on the reliability 
of the resulting programs.  This paper discusses an experiment
that compares the programming reliability 
of subjects using a statically typed language and a "typeless"
language.  Analysis of the number of errors 
and the number of runs containing errors shows that, at
least in one environment, the use of a statically 
typed language can increase programming reliability. 
Detailed analysis of the errors made by the subjects 
in programming solutions to reasonably small problems
shows that the subjects had difficulty manipulating 
the representation of data.

CACM August, 1977

Gannon, J. D.

<B>data types</B>, experimentation, language
design, redundancy, reliable software

4.22

CA770806JB December 28, 1977  7:32 AM

2411	4	2937
2709	4	2937
2889	4	2937
2937	4	2937
2989	4	2937
3005	4	2937
3025	4	2937
3101	4	2937
2138	5	2937
2937	5	2937
2937	5	2937
2937	5	2937


************************



An Experimental Evaluation of Data Type Conventions

The language in which programs are written
can have a substantial effect <B>on the</B> reliability 
of the resulting programs.  This paper discusses an experiment
that compares the programming reliability 
of subjects using a statically typed language and a "typeless"
language.  Analysis of the number of errors 
and the number of runs containing errors shows that, at
least in one environment, the use of a statically 
typed language can increase programming reliability. 
Detailed analysis of the errors made by the subjects 
in programming solutions to reasonably small problems
shows that the subjects had difficulty manipulating 
the representation of data.

CACM August, 1977

Gannon, J. D.

data types, experimentation, language
design, redundancy, reliable software

4.22

CA770806JB December 28, 1977  7:32 AM

2411	4	2937
2709	4	2937
2889	4	2937
2937	4	2937
2989	4	2937
3005	4	2937
3025	4	2937
3101	4	2937
2138	5	2937
2937	5	2937
2937	5	2937
2937	5	2937


************************

************************
Document:  CACM-2254.html
************************


Dynamic Partitioning for Array Languages

The classical process of partitioning an array
into subarrays is extended to a more useful 
array language operation.  Various modes of partitioning
are defined for different types of arrays, so 
that subarrays may vary over the original array in
a nearly arbitrary manner.  These definitions are 
motivated with several realistic examples to illustrate
the value of partitioning for array languages. 
 Of general interest is the data structure for partitioning.
 This consists of dynamic tree structures 
which are used to derive and mainta<B>in the</B> array control
information.  These are described in sufficient 
detail to be of value in the design of other array languages.
 The description presented in this paper 
is implemented in a new array language, OL/2, currently
under development at the University of Illinois.

CACM December, 1972

Phillips, J. R.
Adams, H. C.

dynamic partitioning, array partitioning array language,
data structure, tree structure, programming 
language design, array control blocks, partition control blocks

4.12 4.2 4.22

CA721201 JB January 27, 1978  1:20 PM

2253	4	2254
2254	4	2254
2081	5	2254
2254	5	2254
2254	5	2254
2254	5	2254


************************

************************
Document:  CACM-2390.html
************************


A Proposal for a Computer-Based Interactive Scientific Community

Because of the problems created by the explosion
of papers <B>in the</B> mathematical sciences and 
the drawbacks that this places on research, it is suggested
that a tree of all mathematical results and 
terminology be maintained in a multiterminal computer system.
 Users of the system can store in the computer 
an updated file of their current knowledge, and on selecting
a paper to read, they can obtain from the 
computer the minimum subtree of theorems required to bring
them from what they already know to the background 
knowledge which the paper assumes.  Under certain conditions,
means are also provided for the contribution 
of useful comments by the readers of a work and for interaction
between commentators and with the author. 
 This paper describes how the system can be organized
and the role required of readers, writers, and 
commentators. 

CACM February, 1972

Pager, D.

interactive system, organization of scientific community,
readers, writers, commentators, computer 
utility, information retrieval, trees, data structures

1.0 1.1 1.59 2.10 3.15 3.32 3.50 3.51 3.70 3.71 3.74 3.9

CA720201 JB February 1, 1978  8:51 AM

2390	5	2390
2390	5	2390
2390	5	2390
2519	5	2390
2390	6	2390


************************

************************
Document:  CACM-1710.html
************************


ASP-A Ring Implemented Associative Structure Package

ASP is a general purpose Associative Data
Structure Package in which an arbitrary number of 
data items and an arbitrary number of the relationships
between these data items may be represented. 
 A special picture language is described which has proved
very useful for drawing ASP structures on paper. 
 ASP structures are built and manipulated by means
of a series of macro calls, which are outlined in 
the Appendix.  Emphasis is <B>on the</B> philosophy of the system
rather than a particular implementation, though 
sufficient information is included to enable the
reader to produce his own implementation of ASP.

CACM August, 1968

Lang, C. A.
Gray, J. C.

associative, data structure, ring structure lists,
list structure, set languages, modeling, graphics

4.20 4.22

CA680804 JB February 22, 1978  11:02 AM

1710	5	1710
1710	5	1710
1710	5	1710
1853	5	1710
2003	5	1710
1710	6	1710
1710	6	1710
1767	6	1710
2105	6	1710


************************

************************
Document:  CACM-3197.html
************************


   Structures of Standards-Processing Organizations <B>in the</B> Computer Area

   In line with the ACM's policy statement [Comm. ACM 5 (Nov. 1962), 547-549],
the following organizational descriptions have been provided in order to
describe standardization activities pertinent to computers and information
processing.

CACM June, 1966

Gorn, S.
Bemer, R. W.
Green, J.

CA630626 ES March 17, 1982 10:10 AM

3197	5	3197
3197	5	3197
3197	5	3197
689	5	3197
217	6	3197
323	6	3197
3197	6	3197


************************



   Structures of Standards-Processing Organizations in the Computer Area

   In line with the ACM's policy statement [Comm. ACM 5 (Nov. 1962), 547-549],
<B>the following</B> organizational descriptions have been provided in order to
describe standardization activities pertinent to computers and information
processing.

CACM June, 1966

Gorn, S.
Bemer, R. W.
Green, J.

CA630626 ES March 17, 1982 10:10 AM

3197	5	3197
3197	5	3197
3197	5	3197
689	5	3197
217	6	3197
323	6	3197
3197	6	3197


************************

************************
Document:  CACM-1264.html
************************


BLNSYS-A 1401 Operating System with Braille Capabilities

BLNSYS is an operating system designed for
a 4K 1401 with common optional features and two 
attached tape drives.  Printed output of this system
or of executing programs may be in either English 
or braille.  Even though this system was written for
a small machine with minimal peripheral equipment, 
jobs may be batched, so that card handling and lost
processing time is at a minimum.  This system will 
perform any or all of the following users specified
functions: assemble SPS source decks, post list, 
produce condensed or uncondensed object decks, execute
user's program, list card input to a program, 
list punched output, provide a storage dump, execute
a program submitted for execution as an uncondensed 
object deck under debugging trace control, card-to-braille
conversion, brailled listings of 7040 IBSYS 
batch output, and update or duplicate the system tape
itself.  Input-ouput subroutines are also included 
<B>in the</B> system.

CACM May, 1965

Landwehr, J. B.
McLaughlin, C.
Mueller, H.
Lichstein, M.
Pollack, S. V.

CA650507 JB March 7, 1978  2:30 PM

1264	4	1264
1740	4	1264
1099	5	1264
1264	5	1264
1264	5	1264
1264	5	1264


************************



BLNSYS-A 1401 Operating System with Braille Capabilities

BLNSYS is an operating system designed for
a 4K 1401 with common optional features and two 
attached tape drives.  Printed output of this system
or of executing programs may be in either English 
or braille.  Even though this system was written for
a small machine with minimal peripheral equipment, 
jobs may be batched, so that card handling and lost
processing time is at a minimum.  This system will 
perform any or all of <B>the following</B> users specified
functions: assemble SPS source decks, post list, 
produce condensed or uncondensed object decks, execute
user's program, list card input to a program, 
list punched output, provide a storage dump, execute
a program submitted for execution as an uncondensed 
object deck under debugging trace control, card-to-braille
conversion, brailled listings of 7040 IBSYS 
batch output, and update or duplicate the system tape
itself.  Input-ouput subroutines are also included 
in the system.

CACM May, 1965

Landwehr, J. B.
McLaughlin, C.
Mueller, H.
Lichstein, M.
Pollack, S. V.

CA650507 JB March 7, 1978  2:30 PM

1264	4	1264
1740	4	1264
1099	5	1264
1264	5	1264
1264	5	1264
1264	5	1264


************************

************************
Document:  CACM-3173.html
************************


A Psychology of Learning BASIC

This paper addresses the question: What does a person know
following learning of BASIC programming?  Several underlying conceptual
structures are identified: (1) a transaction is an event that
occurs <B>in the</B> computer and involves some operation on some object
at some location, (2) a prestatement is a set of transactions corresponding
to a line of code, (3) chunks are frequently occurring
 configurations of prestatements corresponding to several lines of code.

CACM November, 1979

Mayer, R.

BASIC, Learning, instruction

1.50 3.36 4.22

CA791101 DB January 17, 1980  10:38 AM

3173	5	3173
3173	5	3173
3173	5	3173


************************

************************
Document:  CACM-2341.html
************************


Blocks-A New Data type for SNOBOL4

A new data type, called a block, has been implemented
for SNOBOL4.  A block is a three-dimensional 
aggregate of characters in the form of a right parallelepiped,
best thought of as a three-dimensional 
extension to a string.  (The third dimension is used for
overstriking.)  Blocks may be printed, concatenated 
in any of three dimensions, and merged on the basis
of program-defined connection points.  Some blocks 
adapt in size and shape to their environment.  Blocks
and their operations are mainly used for composing 
printable output.  A variety of graphical problems (including
flowcharting, bargraphs, logic diagrams, 
mathematical-equation formation, and text justification
and preparation) have been programmed on a printer 
in what appears to be an easy and natural way.  In addition
to these somewhat specialized applications, 
blocks appear to be a good general purpose device-independent
output formation mechanism especially suitable 
for nonnumerical work.  The concept of a block is largely
language independenthat is, blocks require 
little in the way of specialized syntax and could readily
be absorbed into the external structure of 
most programming languages.

CACM June, 1972

Gimpel, J. F.

character manipulation, output formatting, string
processing, graphics, nonnumerical programming, 
SNOBOL4, <B>data types</B>, two-dimensional mathematics, test processing, flowcharting

4.22 4.41

CA720604 JB January 30, 1978  4:38 PM

1086	4	2341
1132	4	2341
1234	4	2341
1263	4	2341
1265	4	2341
1270	4	2341
1323	4	2341
1358	4	2341
1379	4	2341
1380	4	2341
1453	4	2341
1464	4	2341
1484	4	2341
1491	4	2341
1498	4	2341
1613	4	2341
1614	4	2341
1767	4	2341
1781	4	2341
1781	4	2341
1781	4	2341
1825	4	2341
1860	4	2341
1945	4	2341
2083	4	2341
2178	4	2341
2179	4	2341
2252	4	2341
2325	4	2341
2341	4	2341
2341	4	2341
2341	4	2341
2341	4	2341
2546	4	2341
2645	4	2341
2652	4	2341
2684	4	2341
2842	4	2341
2929	4	2341
2934	4	2341
3069	4	2341
669	4	2341
679	4	2341
691	4	2341
761	4	2341
949	4	2341
989	4	2341
990	5	2341
1466	5	2341
1468	5	2341
2341	5	2341
2341	5	2341
2341	5	2341
2545	5	2341
3184	5	2341
1739	6	2341
1781	6	2341
2341	6	2341


************************



Blocks-A New Data type for SNOBOL4

A new data type, called a block, has been implemented
for SNOBOL4.  A block is a three-dimensional 
aggregate of characters <B>in the</B> form of a right parallelepiped,
best thought of as a three-dimensional 
extension to a string.  (The third dimension is used for
overstriking.)  Blocks may be printed, concatenated 
in any of three dimensions, and merged on the basis
of program-defined connection points.  Some blocks 
adapt in size and shape to their environment.  Blocks
and their operations are mainly used for composing 
printable output.  A variety of graphical problems (including
flowcharting, bargraphs, logic diagrams, 
mathematical-equation formation, and text justification
and preparation) have been programmed on a printer 
in what appears to be an easy and natural way.  In addition
to these somewhat specialized applications, 
blocks appear to be a good general purpose device-independent
output formation mechanism especially suitable 
for nonnumerical work.  The concept of a block is largely
language independenthat is, blocks require 
little in the way of specialized syntax and could readily
be absorbed into the external structure of 
most programming languages.

CACM June, 1972

Gimpel, J. F.

character manipulation, output formatting, string
processing, graphics, nonnumerical programming, 
SNOBOL4, data types, two-dimensional mathematics, test processing, flowcharting

4.22 4.41

CA720604 JB January 30, 1978  4:38 PM

1086	4	2341
1132	4	2341
1234	4	2341
1263	4	2341
1265	4	2341
1270	4	2341
1323	4	2341
1358	4	2341
1379	4	2341
1380	4	2341
1453	4	2341
1464	4	2341
1484	4	2341
1491	4	2341
1498	4	2341
1613	4	2341
1614	4	2341
1767	4	2341
1781	4	2341
1781	4	2341
1781	4	2341
1825	4	2341
1860	4	2341
1945	4	2341
2083	4	2341
2178	4	2341
2179	4	2341
2252	4	2341
2325	4	2341
2341	4	2341
2341	4	2341
2341	4	2341
2341	4	2341
2546	4	2341
2645	4	2341
2652	4	2341
2684	4	2341
2842	4	2341
2929	4	2341
2934	4	2341
3069	4	2341
669	4	2341
679	4	2341
691	4	2341
761	4	2341
949	4	2341
989	4	2341
990	5	2341
1466	5	2341
1468	5	2341
2341	5	2341
2341	5	2341
2341	5	2341
2545	5	2341
3184	5	2341
1739	6	2341
1781	6	2341
2341	6	2341


************************



Blocks-A New Data type for SNOBOL4

A new data type, called a block, has been implemented
for SNOBOL4.  A block is a three-dimensional 
aggregate of characters in the form of a right parallelepiped,
best thought of as a three-dimensional 
extension to a string.  (The third dimension is used for
overstriking.)  Blocks may be printed, concatenated 
in any of three dimensions, and merged <B>on the</B> basis
of program-defined connection points.  Some blocks 
adapt in size and shape to their environment.  Blocks
and their operations are mainly used for composing 
printable output.  A variety of graphical problems (including
flowcharting, bargraphs, logic diagrams, 
mathematical-equation formation, and text justification
and preparation) have been programmed on a printer 
in what appears to be an easy and natural way.  In addition
to these somewhat specialized applications, 
blocks appear to be a good general purpose device-independent
output formation mechanism especially suitable 
for nonnumerical work.  The concept of a block is largely
language independenthat is, blocks require 
little in the way of specialized syntax and could readily
be absorbed into the external structure of 
most programming languages.

CACM June, 1972

Gimpel, J. F.

character manipulation, output formatting, string
processing, graphics, nonnumerical programming, 
SNOBOL4, data types, two-dimensional mathematics, test processing, flowcharting

4.22 4.41

CA720604 JB January 30, 1978  4:38 PM

1086	4	2341
1132	4	2341
1234	4	2341
1263	4	2341
1265	4	2341
1270	4	2341
1323	4	2341
1358	4	2341
1379	4	2341
1380	4	2341
1453	4	2341
1464	4	2341
1484	4	2341
1491	4	2341
1498	4	2341
1613	4	2341
1614	4	2341
1767	4	2341
1781	4	2341
1781	4	2341
1781	4	2341
1825	4	2341
1860	4	2341
1945	4	2341
2083	4	2341
2178	4	2341
2179	4	2341
2252	4	2341
2325	4	2341
2341	4	2341
2341	4	2341
2341	4	2341
2341	4	2341
2546	4	2341
2645	4	2341
2652	4	2341
2684	4	2341
2842	4	2341
2929	4	2341
2934	4	2341
3069	4	2341
669	4	2341
679	4	2341
691	4	2341
761	4	2341
949	4	2341
989	4	2341
990	5	2341
1466	5	2341
1468	5	2341
2341	5	2341
2341	5	2341
2341	5	2341
2545	5	2341
3184	5	2341
1739	6	2341
1781	6	2341
2341	6	2341


************************

************************
Document:  CACM-2295.html
************************


Comment <B>on the</B> Composition of Semantics in Algol 68

CACM August, 1972

van der Poel, W. L.

programming primitives, programming languages,
Algol, semantics, recursive composition, design 
of programming languages, data structures

1.3 4.2 4.22 5.23 5.24

CA720807 JB January 30, 1978  9:29 AM

2295	5	2295
2295	5	2295
2295	5	2295


************************

************************
Document:  CACM-1936.html
************************


Variable Length Tree Structures Having Minimum Average Search Time

Sussenguth suggests in a paper (1963) that a
file should be organized as a doubly-chained tree 
structure if it is necessary both to search and to update
frequently.  Such a structure provides a compromise 
between the fast search/slow update characteristics of
binary searching and the slow search/fast update 
characteristics of serial searching.  His method, however,
contains the limiting restriction that all 
terminal nodes lie <B>on the</B> same level of the tree.  This paper
considers the effect of relaxing this restriction. 
 First, trees which have the property that a priori the
filial set of each node is well defined are studied. 
 It is proved that coding the nodes within each filial
set with respect to the number of terminal nodes 
reachable from each is necessary and sufficient to guarantee
minimum average search time.  Then the more 
general case (that is, where the entire structure of
the tree is changeable) is treated.  A procedure 
is developed for constructing a tree with a minimum
average search time.  A simple closed expression 
for this minimum average search time is obtained as
a function of the number of terminal nodes.  The 
storage capacity required to implement the doubly-chained
tree structure on a digital computer is also 
determined.  Finally, the total cost of the structure,
using Sussenguth's cost criterion, is computed. 
 It is shown that significant improvements in both
the average search time and the total cost can be 
obtained by relaxing Sussenguth's restriction that all
terminal nodes lie on the same level of the tree.

CACM February, 1969

Patt, Y. N.

information retrieval, file searching, tree structures, double chaining

3.70 3.73 3.74

CA690202 JB February 20, 1978  11:25 AM

1050	4	1936
1935	4	1936
1936	4	1936
2017	4	1936
2032	4	1936
2257	4	1936
2360	4	1936
2451	4	1936
2452	4	1936
1936	5	1936
1936	5	1936
1936	5	1936
2257	5	1936
2360	5	1936
2451	5	1936
2452	5	1936
2556	5	1936
2765	5	1936
849	5	1936
830	6	1936
849	6	1936
849	6	1936
849	6	1936
849	6	1936
944	6	1936
1831	6	1936
1831	6	1936
1935	6	1936
1935	6	1936
1936	6	1936
1936	6	1936
1936	6	1936
1936	6	1936
1936	6	1936
1936	6	1936
1976	6	1936
1976	6	1936
2046	6	1936
2111	6	1936
2198	6	1936
2360	6	1936
2451	6	1936
2452	6	1936
616	6	1936


************************

************************
Document:  CACM-1678.html
************************


Automata, Formal Languages, Abstract Switching,
and Computability in a Ph. Computer Science 
Program

A number of courses are listed <B>in the</B> area
describe as automata, formal languages, abstract 
switching, and computability, that might be available
to a Ph. student in computer science.  A brief 
catalog description of each course is applied and the
role of each of the courses in the graduate program 
is discussed.

CACM November, 1968

McNaughton, R.

Ph. computer-science curriculum, Ph. computer
science program, automata, formal languages, 
switching theory, theory of computability

1.5 5.2 6.1

CA681101 JB February 21, 1978  3:16 PM

1678	5	1678
1678	5	1678
1678	5	1678
3003	5	1678
1659	6	1678
1678	6	1678
1927	6	1678
1945	6	1678
2097	6	1678
2147	6	1678
2163	6	1678
2187	6	1678
2329	6	1678
2345	6	1678
2367	6	1678
2407	6	1678
2478	6	1678
2479	6	1678
2480	6	1678
2538	6	1678


************************

************************
Document:  CACM-1456.html
************************


Storage and Retrieval of Aspects of Meaning in Directed Graph Structures

An experimental system that uses LISP to make
a conceptual dictionary is described.  The dictionary 
associates with each English word the syntactic information,
definitional material, and references to 
the contexts in which it has been used to define other words.
 Such relations as class inclusion, possession, 
and active or passive actions are used as definitional
material.  The resulting structure serves as a 
powerful vehicle for research <B>on the</B> logic of question answering.
 Examples of methods of inputting information 
and answering simple English questions are given.  An
important conclusion is that, although LISP and 
other list processing languages are ideally suited for
producing complex associative structures, they 
are inadequate vehicles for language processing on any
large scale-at east until they can use auxiliary 
memory as a continuous extension of core memory.

CACM March, 1966

Simmons, R. F.

CA660316 JB March 3, 1978  11:25 AM

1155	4	1456
1456	4	1456
1468	4	1456
1515	4	1456
1699	4	1456
1856	4	1456
2127	4	1456
1324	5	1456
1456	5	1456
1456	5	1456
1456	5	1456


************************

************************
Document:  CACM-1051.html
************************


Multiword List Items

The list concept as originally proposed by
Newell, Simon and Shaw specified single computer 
words as elements of a list.  This report describes the
use of two or more consecutive words as one element. 
 Such use results in a considerable saving in both the
space required to hold a given amount of data, 
and <B>in the</B> execution time required to perform a given
process on the data.  Following a brief description 
of standard list structures with single-word items, the
multiword items are introduced.  Then variable-length 
items are described, along with the corresponding space-utilization
problems.  Finally, several examples 
are given to illustrate the use of multiword lists. This
paper attempts to draw together various recent 
papers which have applied some of these concepts in different
ways, and indicate how they relate to the 
more general problems.

CACM June, 1964

Comfort, W. T.

CA640616 JB March 9, 1978  9:15 PM

1024	4	1051
1024	4	1051
1051	4	1051
1051	4	1051
1051	4	1051
1051	4	1051
1051	4	1051
1051	4	1051
1062	4	1051
1098	4	1051
1102	4	1051
1102	4	1051
1132	4	1051
1214	4	1051
1380	4	1051
1388	4	1051
1390	4	1051
1393	4	1051
1485	4	1051
1486	4	1051
1487	4	1051
1549	4	1051
1549	4	1051
1549	4	1051
1552	4	1051
1570	4	1051
1665	4	1051
1706	4	1051
1826	4	1051
1860	4	1051
1878	4	1051
1878	4	1051
1946	4	1051
1957	4	1051
378	4	1051
2060	4	1051
2155	4	1051
2155	4	1051
2168	4	1051
2168	4	1051
2719	4	1051
2723	4	1051
2723	4	1051
2838	4	1051
2842	4	1051
2855	4	1051
2857	4	1051
2879	4	1051
3077	4	1051
3080	4	1051
3106	4	1051
3112	4	1051
627	4	1051
106	4	1051
1051	5	1051
1051	5	1051
1051	5	1051
1211	5	1051
210	5	1051
1549	5	1051
1906	5	1051
378	5	1051
2902	5	1051
406	5	1051
731	5	1051
793	5	1051
794	5	1051
106	6	1051
1051	6	1051
1051	6	1051
1051	6	1051
1051	6	1051
1062	6	1051
1062	6	1051
1184	6	1051
1211	6	1051
1552	6	1051
210	6	1051
1879	6	1051
2435	6	1051
2596	6	1051
2734	6	1051
2747	6	1051
2768	6	1051
406	6	1051
627	6	1051
731	6	1051
753	6	1051


************************



Multiword List Items

The list concept as originally proposed by
Newell, Simon and Shaw specified single computer 
words as elements of a list.  This report describes the
use of two or more consecutive words as one element. 
 Such use results in a considerable saving in both the
space required to hold a given amount of data, 
and in the execution time required to perform a given
process <B>on the</B> data.  Following a brief description 
of standard list structures with single-word items, the
multiword items are introduced.  Then variable-length 
items are described, along with the corresponding space-utilization
problems.  Finally, several examples 
are given to illustrate the use of multiword lists. This
paper attempts to draw together various recent 
papers which have applied some of these concepts in different
ways, and indicate how they relate to the 
more general problems.

CACM June, 1964

Comfort, W. T.

CA640616 JB March 9, 1978  9:15 PM

1024	4	1051
1024	4	1051
1051	4	1051
1051	4	1051
1051	4	1051
1051	4	1051
1051	4	1051
1051	4	1051
1062	4	1051
1098	4	1051
1102	4	1051
1102	4	1051
1132	4	1051
1214	4	1051
1380	4	1051
1388	4	1051
1390	4	1051
1393	4	1051
1485	4	1051
1486	4	1051
1487	4	1051
1549	4	1051
1549	4	1051
1549	4	1051
1552	4	1051
1570	4	1051
1665	4	1051
1706	4	1051
1826	4	1051
1860	4	1051
1878	4	1051
1878	4	1051
1946	4	1051
1957	4	1051
378	4	1051
2060	4	1051
2155	4	1051
2155	4	1051
2168	4	1051
2168	4	1051
2719	4	1051
2723	4	1051
2723	4	1051
2838	4	1051
2842	4	1051
2855	4	1051
2857	4	1051
2879	4	1051
3077	4	1051
3080	4	1051
3106	4	1051
3112	4	1051
627	4	1051
106	4	1051
1051	5	1051
1051	5	1051
1051	5	1051
1211	5	1051
210	5	1051
1549	5	1051
1906	5	1051
378	5	1051
2902	5	1051
406	5	1051
731	5	1051
793	5	1051
794	5	1051
106	6	1051
1051	6	1051
1051	6	1051
1051	6	1051
1051	6	1051
1062	6	1051
1062	6	1051
1184	6	1051
1211	6	1051
1552	6	1051
210	6	1051
1879	6	1051
2435	6	1051
2596	6	1051
2734	6	1051
2747	6	1051
2768	6	1051
406	6	1051
627	6	1051
731	6	1051
753	6	1051


************************

