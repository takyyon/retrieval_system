Snippets for the query:  I'm interested in mechanisms for communicating between disjoint processes, possibly, but not exclusively, in a distributed environment. I would rather see descriptions of complete mechanisms, with or without implementations, as opposed to theoretical work on the abstract problem. Remote procedure calls and message-passing are examples of my interests.
************************
Total Hits:  97
************************

************************
Document:  CACM-2406.html
************************


A Data Definition and Mapping Language

A data definition language i sa declarative
computer language for specifying data structures. 
 Most data definition languages concentrate <B>on the</B> declaration
of logical data structures with little 
concern for how these structures are physically realized
on a computer system.  However, the need for 
data definition languages which describe both the logical
and physical aspects of data is increasingly 
apparent.  Such languages will be a key systems, as well
as in advanced data management systems and distributed 
data bases.  This paper reviews past work in the data
definition language for describing both logical 
and physical aspects of data.  Applications of these
"generalized" data definition languages are also 
discussed.

CACM December, 1973

Sibley, E. H.
Taylor, R. W.

data definition language, data and storage structure,
data translation, data base management systems, 
file translation

3.51 3.70 3.73 4.29 4.82

CA731202 JB January 19, 1978  2:58 PM

2155	4	2406
2406	4	2406
2710	4	2406
2715	4	2406
2716	4	2406
2717	4	2406
2718	4	2406
2765	4	2406
2817	4	2406
2888	4	2406
2901	4	2406
2957	4	2406
2959	4	2406
2965	4	2406
3087	4	2406
3154	4	2406
2046	5	2406
2406	5	2406
2406	5	2406
2406	5	2406
2717	5	2406
2046	6	2406
2406	6	2406


************************



A Data Definition and Mapping Language

A data definition language i sa declarative
computer language for specifying data structures. 
 Most data definition languages concentrate on the declaration
of logical data structures with little 
concern for how these structures are physically realized
on a computer system.  However, the need for 
data definition languages which describe both the logical
and physical aspects of data is increasingly 
apparent.  Such languages will be a key systems, as well
as <B>in a</B>dvanced data management systems and distributed 
data bases.  This paper reviews past work in the data
definition language for describing both logical 
and physical aspects of data.  Applications of these
"generalized" data definition languages are also 
discussed.

CACM December, 1973

Sibley, E. H.
Taylor, R. W.

data definition language, data and storage structure,
data translation, data base management systems, 
file translation

3.51 3.70 3.73 4.29 4.82

CA731202 JB January 19, 1978  2:58 PM

2155	4	2406
2406	4	2406
2710	4	2406
2715	4	2406
2716	4	2406
2717	4	2406
2718	4	2406
2765	4	2406
2817	4	2406
2888	4	2406
2901	4	2406
2957	4	2406
2959	4	2406
2965	4	2406
3087	4	2406
3154	4	2406
2046	5	2406
2406	5	2406
2406	5	2406
2406	5	2406
2717	5	2406
2046	6	2406
2406	6	2406


************************

************************
Document:  CACM-2890.html
************************


On Quadratic Adaptive Routing Algorithms

Two analytic models of a store-and-forward communications
network are constructed, one to find 
the optimal message routing and the other to illustrate
the equilibrium (stationary state) maintained 
by an adaptive routing algorithm.  These models show that
adaptive routing does not satisfy the necessary 
conditions for an optimal routing,  Adaptive routing tends
to overuse the direct path and underuse alternate 
routes because it does not consider the impact of its
current routing decision <B>on the</B> future state of 
the network.  The form of the optimality conditions suggests
that a modification of the adaptive algorithm 
will result in optimality.  The modification requires
the substitution of a quadratic bias term instead 
of a linear one in the routing table maintained at each
network node.  Simulation results are presented 
which confirm the theoretical analysis for a simple network.

CACM January, 1976

Agnew, C. E.

routing algorithms, adaptive routing, quadratic routing,
alternate routing, store-and-forward network, 
distributed network, computer network, message switching

3.81 8.0 8.1 8.3

CA760103 JB January 5, 1978  10:37 AM

2890	5	2890
2890	5	2890
2890	5	2890


************************

************************
Document:  CACM-0040.html
************************


Fingers or Fists? (The Choice of Decimal or Binary Representation)

The binary number system offers many advantages
over a decimal representation for a high-performance, 
general-purpose computer.  The greater simplicity of
a binary arithmetic unit and the greater compactness 
of binary numbers both contribute directly to arithmetic
speed.  Less obvious and perhaps more important 
is the way binary addressing and instruction formats can
increase the overall performance.  Binary addresses 
are also essential to certain powerful operations which
are not practical with decimal instruction formats. 
 On the other hand, decimal numbers are essential for
<B>communicating between</B> man and the computer.  In 
applications requiring the processing of a large volume
of inherently decimal input and output data, 
the time for decimal-binary conversion needed by a purely
binary computer may be significant.  A slower 
decimal adder may take less time than a fast binary adder
doing an addition and two conversions.  A careful 
review of the significance of decimal and binary addressing
and both binary and decimal data arithmetic, 
supplemented by efficient conversion instructions.

CACM December, 1959

Buchholz, W.

CA591202 JB March 22, 1978  3:47 PM

40	5	40
40	5	40
40	5	40


************************

************************
Document:  CACM-2684.html
************************


Production Systems: or Can We Do Better than BNF?

Since the development of BNF, the definition
of the syntax of programming languages has been 
almost universally associated with context-free requirements.
 Yet numerous interesting and difficult 
issues in syntax stem from the context-sensitive requirements,
notably the compatibility between the 
declaration of an identifier and its uses, the correspondence
between actual and formal parameters, and 
issues arising from block structure.  This paper explores
the use of a formal notation called Production 
Systems in providing a readable and complete formal definition
of syntax.  As a practical illustration, 
a small but significant subset of PL/I is considered.  A
more detailed presentation, as well as the application 
to define abstract syntax and translations between languages,
is given <B>in a</B> previous paper by the author.

CACM February, 1974

Ledgard, H. F.

syntax, translation, context-sensitive grammars,
compilers, formal definition, PL/I standards

4.2 5.21 5.23

CA740205 JB January 18, 1978  1:07 PM

1086	4	2684
1132	4	2684
1234	4	2684
1263	4	2684
1265	4	2684
1270	4	2684
1323	4	2684
1358	4	2684
1379	4	2684
1380	4	2684
1453	4	2684
1464	4	2684
1469	4	2684
1484	4	2684
1486	4	2684
1491	4	2684
1491	4	2684
1498	4	2684
1613	4	2684
1614	4	2684
1781	4	2684
1781	4	2684
1781	4	2684
1825	4	2684
1860	4	2684
2083	4	2684
2178	4	2684
2178	4	2684
2178	4	2684
2179	4	2684
2252	4	2684
2325	4	2684
2326	4	2684
2326	4	2684
2341	4	2684
2470	4	2684
2546	4	2684
2645	4	2684
2652	4	2684
2684	4	2684
2684	4	2684
2684	4	2684
2842	4	2684
2929	4	2684
2934	4	2684
3044	4	2684
3069	4	2684
669	4	2684
679	4	2684
691	4	2684
761	4	2684
949	4	2684
989	4	2684
1303	5	2684
1323	5	2684
2684	5	2684
2684	5	2684
2684	5	2684
3184	5	2684


************************

************************
Document:  CACM-1180.html
************************


AXLE: An Axiomatic Language for String Transformations

AXLE is a language designed for data manipulation.
 Data arranged <B>in a</B> linear form in a workspace 
is transformed according to a table of axioms, called imperatives.
 A transformation consists of a matching 
procedure, which decides where an imperative is applicable,
and a replacement procedure that modifies 
that part of the workspace.  Imperatives are applied
in accordance with definitions of symbolic terms, 
presented systematically in an assertion table.  The
process of definition includes the special case 
of recursive assertions.  Several complete programs
of imperatives are given to show a few applications
of the language.

CACM November, 1965

Cohen, I.
Wegstein, J. H.

CA651101 JB March 6, 1978  6:22 PM

1180	5	1180
1180	5	1180
1180	5	1180
1395	5	1180
1706	5	1180
1180	6	1180
1180	6	1180
1395	6	1180
210	6	1180


************************

************************
Document:  CACM-2622.html
************************


A User Authentication Scheme Not Requiring Secrecy in the Computer

In many computer operating systems a user authenticates
himself by entering a secret password 
known solely to himself and the system.  The system compares
this password with one recorded <B>in a</B> Password 
Table which is available to only the authentication
program.  The integrity of the system depends on 
keeping the table secret.  In this paper a password
scheme is presented which does not require secrecy 
in the computer.    All aspects of the system, including
all relevant code and data bases, may be known 
by anyone attempting to intrude.  The scheme is based
on using a function H which the would-be intruder 
is unable to invert.  This function is applied to the
user's password and the result compared to a table 
entry, a match being interpreted as authentication of
the user.  The intruder may know all about H and 
have access to the table, but he can penetrate the system
only if he can invert H to determine an input 
that produces a given output.  This paper discusses
issues surrounding selection of a suitable H.  Two 
different plausible arguments are given that penetration
would be exceedingly difficult, and it is then 
argued that more rigorous results are unlikely.  Finally,
some human engineering problems relating to 
the scheme are discussed.

CACM August, 1974

Evans, A. Jr.
Kantrowitz, W.
Weiss, E.

operating system security, security, authentication,
passwords, one-way encryption, cryptology

4.39 5.39

CA740802 JB January 17, 1978  10:19 AM

2622	5	2622
2622	5	2622
2622	5	2622


************************

************************
Document:  CACM-1588.html
************************


PL/I List Processing

The concepts of list processing have been introduced
into the PL/I language.  With these new 
facilities, it is possible to write PL/I procedures that
operate on simple and complex data list organizations. 
 Most list-processing languages have suffered from their
inability to deal directly with complex data 
structures and/or from their inability to perform the
complete range of programming language operations 
up<B>on the</B> data list structures.  These two problems have
been eliminated in the list-processing facilities 
of PL/I.  The basic concepts of list processing and
the philosophy of the PL/I language extensions are 
discussed.  In addition, several detailed list-processing examples are provided.

CACM June, 1967

Lawson Jr., H. W.

CA670604 JB February 28, 1978  9:30 AM

1588	5	1588
1588	5	1588
1588	5	1588


************************

************************
Document:  CACM-3141.html
************************


An Improved Algorithm for Decentralized Extrema-Finding
in Circular Configurations of Processes

This note presents an improvement to LeLann's
algorithm for finding the largest (or smallest) of a set of uniquely
numbered processes arranged <B>in a</B> circle, in which no central
controller exists and the number of processes is not known a priori.
This decentralized algorithm uses a technique of selective
message extinction in order to achieve an average number of
message passes of order (n log n) rather than O(n2).  

CACM May, 1979

Chang, E.
Roberts, R.

Decentralized algorithms, distributed systems, operating systems

4.32 4.35 5.25 5.32

CA790502 DH June 5, 1979  2:35 PM

3141	5	3141
3141	5	3141
3141	5	3141


************************

************************
Document:  CACM-2344.html
************************


On the Optimization of Performance of Time-Sharing Systems by Simulation

A simulation model of a time-sharing system
with a finite noncontiguous store and an infinite 
auxiliary store is used to study the variation of system
parameters such as store size, number of jobs 
allowed to execute simultaneously, job-scheduling algorithm,
etc.  The effects of these variations on 
a measure of system performance is used to ascertain which
of the parameters controllable by the job-scheduling 
algorithm, including the scheduling itself, require optimization,
and which of the parameters not normally 
controllable by the scheduling algorithm have a marked
effect on system performance.  System performance 
is based up<B>on the</B> mean cost of delay to all jobs processed.
 It is shown that significant improvements 
in the measure of system performance can be obtained by
using variable time-slice techniques and by selecting 
the optimum round-robin cycle time.  It appears that these
features would benefit from optimization whereas 
other parameters controllable by the scheduling algorithm
affect system performance in a predictable 
manner and would not benefit from optimization.  Features
not normally under the control of the scheduling 
algorithm can also have a marked effect on the measure
of performance; in particular, supervisor overheads, 
the size of the store, and the speed of the CPU.  A comparison
is made between the results of the simulation 
model and two analytical equations for quantum-oriented
nonpreemptive time-sharing systems.  The comparison 
is found to be very favorable.

CACM June, 1972

Blatny, J.
Clark, S. R.
Rourke, T. A.

time-sharing, simulation studies, optimization,
measure of performance, scheduling algorithms

3.80 4.30 4.32

CA720601 JB January 31, 1978  9:19 AM

2219	4	2344
2344	4	2344
1938	5	2344
2344	5	2344
2344	5	2344
2344	5	2344


************************



On the Optimization of Performance of Time-Sharing Systems by Simulation

A simulation model of a time-sharing system
with a finite noncontiguous store and an infinite 
auxiliary store is used to study the variation of system
parameters such as store size, number of jobs 
allowed to execute simultaneously, job-scheduling algorithm,
etc.  The effects of these variations on 
a measure of system performance is used to ascertain which
of the parameters controllable by the job-scheduling 
algorithm, including the scheduling itself, require optimization,
and which of the parameters not normally 
controllable by the scheduling algorithm have a marked
effect on system performance.  System performance 
is based upon the mean cost of delay to all jobs processed.
 It is shown that significant improvements 
in the measure of system performance can be obtained by
using variable time-slice techniques and by selecting 
the optimum round-robin cycle time.  It appears that these
features would benefit from optimization whereas 
other parameters controllable by the scheduling algorithm
affect system performance <B>in a</B> predictable 
manner and would not benefit from optimization.  Features
not normally under the control of the scheduling 
algorithm can also have a marked effect on the measure
of performance; in particular, supervisor overheads, 
the size of the store, and the speed of the CPU.  A comparison
is made between the results of the simulation 
model and two analytical equations for quantum-oriented
nonpreemptive time-sharing systems.  The comparison 
is found to be very favorable.

CACM June, 1972

Blatny, J.
Clark, S. R.
Rourke, T. A.

time-sharing, simulation studies, optimization,
measure of performance, scheduling algorithms

3.80 4.30 4.32

CA720601 JB January 31, 1978  9:19 AM

2219	4	2344
2344	4	2344
1938	5	2344
2344	5	2344
2344	5	2344
2344	5	2344


************************

************************
Document:  CACM-2940.html
************************


Abstraction and Verification in Alphard: Defining
and Specifying Iteration and Generators

The Alphard "form" provides the programmer with
a great deal of control over the implementation 
of abstract data types.  In this paper <B>the abstract</B>ion techniques
are extended from simple data representation 
and function definition to the iteration statement, the
most important poin t of interaction between data 
and the control structure of the language itself.  A
means of specializing Alphard's loops to operate 
on abstract entities without explicit dependence on the
representation of those entities is in troduced. 
 Specification and verification techniques that allow
the properties of the generators for such iterations 
to be expressed in the form of proof rules are developed.
 Results are obtained that for common special 
cases of these loops are essentially identical to the
corresponding constructs in other languages.  A 
means of showing that a generator will terminate is also provided.

CACM August, 1977

Shaw, M.
Wulf, W. A.

abstraction and representation, abstract data types,
assertions, control specialization, correctness, 
generators,invariants, iteration statements, modular
decomposition, program specifications, programming 
languages, programming methodology, proofs of correctness, types, verification

4.20 5.24

CA770803 JB December 28, 1977  7:59 AM

2940	5	2940
2940	5	2940
2940	5	2940
3150	5	2940
2060	6	2940
2704	6	2940
2842	6	2940
2939	6	2940
2940	6	2940
2941	6	2940
2943	6	2940
3073	6	2940
3148	6	2940


************************



Abstraction and Verification in Alphard: Defining
and Specifying Iteration and Generators

The Alphard "form" provides the programmer with
a great deal of control over the implementation 
of abstract data types.  In this paper the abstraction techniques
are extended from simple data representation 
and function definition to the iteration statement, the
most important poin t of interaction between data 
and the control structure of the language itself.  A
means of specializing Alphard's loops to operate 
on abstract entities without explicit dependence <B>on the</B>
representation of those entities is in troduced. 
 Specification and verification techniques that allow
the properties of the generators for such iterations 
to be expressed in the form of proof rules are developed.
 Results are obtained that for common special 
cases of these loops are essentially identical to the
corresponding constructs in other languages.  A 
means of showing that a generator will terminate is also provided.

CACM August, 1977

Shaw, M.
Wulf, W. A.

abstraction and representation, abstract data types,
assertions, control specialization, correctness, 
generators,invariants, iteration statements, modular
decomposition, program specifications, programming 
languages, programming methodology, proofs of correctness, types, verification

4.20 5.24

CA770803 JB December 28, 1977  7:59 AM

2940	5	2940
2940	5	2940
2940	5	2940
3150	5	2940
2060	6	2940
2704	6	2940
2842	6	2940
2939	6	2940
2940	6	2940
2941	6	2940
2943	6	2940
3073	6	2940
3148	6	2940


************************

************************
Document:  CACM-2989.html
************************


Empirical Evaluation of Some Features
of Instruction Set Processor Architectures

This paper presents methods for empirical evaluation
of features of Instruction Set Processors 
(ISPs).  ISP features are evaluated in terms of the time
used or saved by having or not having the feature. 
 The methods are based on analysis of traces of program
executions.  The concept of a register life is 
in troduced, and used to answer questions like: How many
registers are used simultaneously? How many would 
be sufficient all of the time? Most of the time? What
would the overhead be if the number of registers 
were reduced? What are registers used for during their
lives? The paper also discusses the problem of 
detecting desirable but non-existing instructions. Other
problems are briefly discussed.  Experimental 
results are presented, obtained by analyzing 41
programs running <B>on the</B> DEC system 10 ISP.

CACM March, 1977

Lunde, A.

computer architecture, program behavior, instruction
sets, op code utilization, register structures, 
register utilization, simultaneous register
lives, instruction tracing, execution time

6.20 6.21 6.33

CA770303 JB December 30, 1977  1:00 AM

1653	4	2989
2411	4	2989
2709	4	2989
2889	4	2989
2937	4	2989
2989	4	2989
2989	4	2989
3005	4	2989
3025	4	2989
3101	4	2989
1069	5	2989
2138	5	2989
2989	5	2989
2989	5	2989
2989	5	2989
3025	5	2989
2138	6	2989
2989	6	2989


************************

************************
Document:  CACM-1506.html
************************


The LACONIQ Monitor: Time Sharing for Online Dialogues

The LACONIQ (Laboratory Computer Online Inquiry)
Monitor was developed primarily to support 
non-numerical applications such as retrieval from very
large files by means of a "dialogue" between a 
system user and a retrieval application.  The monitor
was designed so that it could work with a small 
computer (an IBM System 360/30).  Therefore techniques
for resource allocation were important.  For this 
reas<B>on the</B> use of core storage, computational facilities,
and input-output were all scheduled.  An unusual 
feature of the system is that it is event-driven rather
than clock-driven.  The program segments called 
into execution by the remote CRT consoles are invariably
run to completion rather than "rolled-out" to 
be brought back at a later time.

CACM December, 1967

Drew, D. L.

CA671202 JB February 26, 1978  2:45 PM

1506	5	1506
1506	5	1506
1506	5	1506


************************

************************
Document:  CACM-2931.html
************************


Logic and Programming Languages

Logic has been long in terested in whether answers
to certain questions are computable in principle, 
since the outcome puts bounds on the possibilities of
formalization.  More recently, precise comparisons 
in the efficiency of decision methods have become available
through the developments in complexity theory. 
 These, however, are applications to logic, and a big question
is whether methods of logic have significance 
in the other direction for the more applied parts of
computability theory.  Programming languages offer 
an obvious opportunity as their syntactic formalization
is well advanced; however, the semantical theory 
can hardly be said to be complete.  Though we have
many examples, we have still to give wide-ranging 
mathematical answers to these queries:  What is a machine?
 What is a computable process?  How (or how 
well) does a machine simulate a process?  Programs naturally
enter in giving <B>descriptions of</B> processes. 
 The definition of the precise meaning of a program
then requires us to explain what are the objects 
of computation (in a way, the statics of the problem)
and how they are to be transformed (the dynamics). 
 So far the theories of automata and of nets, though
most in teresting for dynamics, have formalized only 
a portion of the field, and there has been perhaps too
much concentration on the finite-state and algebraic 
aspects.  It would seem that the understanding of higher-level
program features involves us with infinite 
objects and forces us to pass through several levels
of explanation to go from the conceptual ideas to 
the final simulation on a real machine.  These levels
can be made mathematically exact if we can find 
the right abstractions to represent the necessary structures.
 The experience of many independent workers 
with the method of data types as lattices (or partial
orderings) under an information content ordering, 
and with their continuous mappings, has demonstrated the
flexibility of this approach in providing definitions 
and proofs, which are clean and without undue dependence
on implementations.  Nevertheless much remains 
to be done in showing how abstract conceptualizations
can (or cannot) be actualized before we can say 
we have a unified theory.

CACM September, 1977

Scott, D. S.

logic, programming languages, automata, denotational
semantics, a-calculus models, computability, 
partial functions, approximation, function spaces

1.2 4.20 5.21 5.24 5.27

CA770902 JB December 28, 1977  6:49 AM

2931	5	2931
2931	5	2931
2931	5	2931


************************



Logic and Programming Languages

Logic has been long in terested in whether answers
to certain questions are computable in principle, 
since the outcome puts bounds on the possibilities of
formalization.  More recently, precise comparisons 
in the efficiency of decision methods have become available
through the developments in complexity theory. 
 These, however, are applications to logic, and a big question
is whether methods of logic have significance 
in the other direction for the more applied parts of
computability theory.  Programming languages offer 
an obvious opportunity as their syntactic formalization
is well advanced; however, the semantical theory 
can hardly be said to be complete.  Though we have
many examples, we have still to give wide-ranging 
mathematical answers to these queries:  What is a machine?
 What is a computable process?  How (or how 
well) does a machine simulate a process?  Programs naturally
enter in giving descriptions of processes. 
 The definition of the precise meaning of a program
then requires us to explain what are the objects 
of computation (<B>in a</B> way, the statics of the problem)
and how they are to be transformed (the dynamics). 
 So far the theories of automata and of nets, though
most in teresting for dynamics, have formalized only 
a portion of the field, and there has been perhaps too
much concentration on the finite-state and algebraic 
aspects.  It would seem that the understanding of higher-level
program features involves us with infinite 
objects and forces us to pass through several levels
of explanation to go from the conceptual ideas to 
the final simulation on a real machine.  These levels
can be made mathematically exact if we can find 
the right abstractions to represent the necessary structures.
 The experience of many independent workers 
with the method of data types as lattices (or partial
orderings) under an information content ordering, 
and with their continuous mappings, has demonstrated the
flexibility of this approach in providing definitions 
and proofs, which are clean and without undue dependence
on implementations.  Nevertheless much remains 
to be done in showing how abstract conceptualizations
can (or cannot) be actualized before we can say 
we have a unified theory.

CACM September, 1977

Scott, D. S.

logic, programming languages, automata, denotational
semantics, a-calculus models, computability, 
partial functions, approximation, function spaces

1.2 4.20 5.21 5.24 5.27

CA770902 JB December 28, 1977  6:49 AM

2931	5	2931
2931	5	2931
2931	5	2931


************************



Logic and Programming Languages

Logic has been long in terested in whether answers
to certain questions are computable in principle, 
since the outcome puts bounds <B>on the</B> possibilities of
formalization.  More recently, precise comparisons 
in the efficiency of decision methods have become available
through the developments in complexity theory. 
 These, however, are applications to logic, and a big question
is whether methods of logic have significance 
in the other direction for the more applied parts of
computability theory.  Programming languages offer 
an obvious opportunity as their syntactic formalization
is well advanced; however, the semantical theory 
can hardly be said to be complete.  Though we have
many examples, we have still to give wide-ranging 
mathematical answers to these queries:  What is a machine?
 What is a computable process?  How (or how 
well) does a machine simulate a process?  Programs naturally
enter in giving descriptions of processes. 
 The definition of the precise meaning of a program
then requires us to explain what are the objects 
of computation (in a way, the statics of the problem)
and how they are to be transformed (the dynamics). 
 So far the theories of automata and of nets, though
most in teresting for dynamics, have formalized only 
a portion of the field, and there has been perhaps too
much concentration on the finite-state and algebraic 
aspects.  It would seem that the understanding of higher-level
program features involves us with infinite 
objects and forces us to pass through several levels
of explanation to go from the conceptual ideas to 
the final simulation on a real machine.  These levels
can be made mathematically exact if we can find 
the right abstractions to represent the necessary structures.
 The experience of many independent workers 
with the method of data types as lattices (or partial
orderings) under an information content ordering, 
and with their continuous mappings, has demonstrated the
flexibility of this approach in providing definitions 
and proofs, which are clean and without undue dependence
on implementations.  Nevertheless much remains 
to be done in showing how abstract conceptualizations
can (or cannot) be actualized before we can say 
we have a unified theory.

CACM September, 1977

Scott, D. S.

logic, programming languages, automata, denotational
semantics, a-calculus models, computability, 
partial functions, approximation, function spaces

1.2 4.20 5.21 5.24 5.27

CA770902 JB December 28, 1977  6:49 AM

2931	5	2931
2931	5	2931
2931	5	2931


************************

************************
Document:  CACM-3018.html
************************


Covering Edges by Cliques with Regard to
Keyword Conflicts and Intersection Graphs

Kellerman has presented a method for determining
keyword conflicts and described a heuristic 
algorithm which solves a certain combinatorial optimization
problem in connection with this method.  
This optimization problem is here shown to be equivalent
to the problem of covering the edges of a graph 
by complete subgraphs with the objective of minimizing
the number of complete subgraphs.  A relationship 
between this edge-clique-cover problem and the graph coloring
problem is established which allows algorithms 
for either one of these problems to be constructed
from algorithm for the other.  As consequences of 
this relationship, the keyword conflict problem and the
edge-clique-cover problem are shown to be NP-complete, 
and if P=/NP then they do not admit polynomial-time approximation
algorithms which always produce solutions 
with<B>in a</B> factor less than 2 from the optimum.

CACM February, 1978

Kou, L.
Stockmeyer, L.
Wong, C.
Watson, T.

keyword conflicts, intersection graphs, node clique
cover, edge clique cover, computational complexity, 
NP-complete problems, polynomial-time heuristics

4.12 5.25 5.32

CA780205 JB March 28, 1978  4:18 PM

3018	5	3018
3018	5	3018
3018	5	3018


************************



Covering Edges by Cliques with Regard to
Keyword Conflicts and Intersection Graphs

Kellerman has presented a method for determining
keyword conflicts and described a heuristic 
algorithm which solves a certain combinatorial optimization
problem in connection with this method.  
This optimization problem is here shown to be equivalent
to the problem of covering the edges of a graph 
by complete subgraphs with the objective of minimizing
the number <B>of complete</B> subgraphs.  A relationship 
between this edge-clique-cover problem and the graph coloring
problem is established which allows algorithms 
for either one of these problems to be constructed
from algorithm for the other.  As consequences of 
this relationship, the keyword conflict problem and the
edge-clique-cover problem are shown to be NP-complete, 
and if P=/NP then they do not admit polynomial-time approximation
algorithms which always produce solutions 
within a factor less than 2 from the optimum.

CACM February, 1978

Kou, L.
Stockmeyer, L.
Wong, C.
Watson, T.

keyword conflicts, intersection graphs, node clique
cover, edge clique cover, computational complexity, 
NP-complete problems, polynomial-time heuristics

4.12 5.25 5.32

CA780205 JB March 28, 1978  4:18 PM

3018	5	3018
3018	5	3018
3018	5	3018


************************

************************
Document:  CACM-1727.html
************************


One Way of Estimating Frequencies of Jumps <B>in a</B> Program

For the segmentation of a program it is useful
to have a reasonable estimation of the values 
of S(ij), where S(ij) is the mean value of the number
of jumps from the i-th instruction on to the j-th 
instruction in the run time.  In the cases where the
S(ij) are estimated directly, the structure of the 
whole program must be generally taken into account;
therefore it is very difficult for the programmer 
and/or the translator to obtain a good estimation of
the S(ij).  It is easier to estimate not S(ij) but 
the quantities P(ij)=S(ij)*C(i)/SUM[S(ij), j=1,N], where
C(i) is an arbitrary positive constant for each 
i.  Although the P(ij) are, for each i, proportional to
S(ij), the estimation of P(ij) is easier, because 
we must estimate only the "probabilities" of events
where instruction i is executed after instruction 
I(i).  This estimation can often be done without considering
the structure of the whole program.  In 
the first part of the paper, using the theory of the
Markov chains, an algorithm for the computation 
of the S(ij) from the P(ij) is found, and some ways
of obtaining estimates of the P(ij) are given.  In 
the second part a variant of this algorithm is derived,
avoiding the necessity of computation involving 
large matrices.

CACM July, 1968

Kral, J.

object program reduction, supervisor calls decreasing,
jump frequencies estimation, control transfers 
estimation, optimal program segmentation, Markov chain
program correspondence, program graph, one-entry 
subgraph, locally estimated jump frequencies, supervisor
overhead decreasing, program segmentation algorithm, 
jump frequencies, program segmentation problem

4.11 4.19 4.39 4.49

CA680702 JB February 22, 1978  3:05 PM

1727	5	1727
1727	5	1727
1727	5	1727


************************

************************
Document:  CACM-2767.html
************************


A Comparison of Simulation Event List Algorithms

Four algorithms are considered which can be used
to schedule events <B>in a</B> general purpose discrete 
simulation system.  Two of the algorithms are new, one
is based on an end-order tree structure for event 
notices, and another uses an indexed linear list. The algorithms
are tested with a set of typical stochastic 
scheduling distributions especially chosen to show
the advantages and limitations of the algorithms. 
 The end-order tree algorithm is shown to be an advantageous,
immediate replacement for the algorithm 
in use with current simulation languages.  The most
promising algorithm uses the indexed list concept. 
 It will require an adaptive routine before it can
be employed in general purpose simulators,but its 
performance is such that further study would be fruitful.

CACM April, 1975

Vaucher, J. G.
Duval, P.

simulation, time flow mechanisms, event list algorithm,
simulation, time flow mechanisms, event 
list algorithm, simulation executive, event scheduling
routine, discrete system simulation, sorting

3.74 4.22 8.1

CA750410 JB January 9, 1978  3:43 PM

2767	4	2767
3064	4	2767
1939	5	2767
2767	5	2767
2767	5	2767
2767	5	2767
2844	5	2767
2936	5	2767
3051	5	2767
3064	5	2767
3109	5	2767
970	6	2767
1059	6	2767
1846	6	2767
1939	6	2767
2742	6	2767
2742	6	2767
2742	6	2767
2767	6	2767
2767	6	2767
2767	6	2767
2767	6	2767
2767	6	2767
2844	6	2767
2844	6	2767
2936	6	2767


************************

************************
Document:  CACM-2276.html
************************


Computer Methods for Sampling from
the Exponential and Normal Distributions

Various methods are known for transforming uniformly
distributed random numbers into exponentially
and normally distributed quantities.  The most efficient
ones are compared, in terms of memory requirements 
and speed, with some new algorithms.  A number of procedures
convert Taylor series expansions directly 
into sampling steps, an approach which may be used for
sampling from any continuous distribution.  For 
the exponential distribution a definite recommendation
can be made, whereas in the case of the normal 
distributi<B>on the</B>re remains a choice between slower and
shorter algorithms and faster but space consuming 
methods.

CACM October, 1972

Ahrens, J. H.
Dieter, U.

random numbers, pseudorandom, normal distribution,
exponential distribution, exponential distribution, 
simulation, numerical analysis

3.29 3.57 5.11 5.5

CA721002 JB January 27, 1978  3:55 PM

1073	4	2276
2137	4	2276
2276	4	2276
2276	4	2276
1073	5	2276
1153	5	2276
2276	5	2276
2276	5	2276
2276	5	2276
2565	5	2276
1716	6	2276
2276	6	2276


************************

************************
Document:  CACM-1253.html
************************


QUIKSCRIPT-A SIMSCRIPT- Like Language for the G-20

QUIKSCRIPT is a simulation language based on
SIMSCRIPT and programmed entirely <B>in a</B>n algebraic 
language, 20-GATE.  The QUIKSCRIPT language, its internal
implementation, and major differences between 
QUIKSCRIPT and SIMSCRIPT are presented.  This paper is
not a programming guide to the language, but rather 
an attempt to present its flavor.  A brief description of
SIMSCRIPT is included, as is a sufficient description 
of 20-GATE to render this material understandable
to the reader familiar with algebraic languages.

CACM June, 1965

Tonge, F. M.
Keller, P.
Newell, A.

CA650602 JB March 7, 1978  12:45 PM

1253	5	1253
1253	5	1253
1253	5	1253


************************

************************
Document:  CACM-2514.html
************************


An Array Grammar Programming System

A package of Fortran programs has been developed
that permits a user to interactively design 
and test array grammars.  The user can control the rule
selection procedure <B>in a</B> derivation or parse, 
using weighted programming matrices; he also has a choice
of instance selection schemes (raster,random, 
parallel).  Examples are given involving array languages
consisting of simple geometrical patterns, as 
well as a language of "neuron pictures."

CACM May, 1973

Mercer, A.
Rosenfeld, A.

picture grammars, array grammars

3.63 5.23 8.2

CA730506 JB January 23, 1978  4:49 PM

2514	5	2514
2514	5	2514
2514	5	2514


************************

************************
Document:  CACM-2233.html
************************


Signature Simulation and Certain Cryptographic Codes

Three cyphers allegedly authored by Thomas
Jefferson Beale in 1822 have been the subject of 
intensive study for over 100 years.  Generations of
cryptanalysts have expended untold man-years, thus 
far without success, attempting tode code them; vast armies
of fortune hunters and treasure seekers have 
devoted Herculean labors to digging up the rolling hills
of Virginia trying to locate the promised bonanza. 
 The history of pertinent activities would fill volumes,
yet serious students of cryptography have always 
had nagging doubts about the cyphers' authenticity.
 It has been alleged that the "known solution" to 
Cypher Number Two: 115, 73, 24, 818, 37, 52, 49,...("I
have deposited in the County of Bedford about 
four miles from Buford's <B>in a</B>n excavation or vault...")
with the aid of an unsanitized version of the 
Declaration of Independence was merely a superb, imaginative,
and grandiose hoax perpetrated ages ago 
for whatever reasons.  Modern computer technology could
obviously perform signature analyses the process 
of encoding itself so as to yield new clues and deeper
insights into their construction.  For the benefit 
of the uninitiated, the encoding method used in the
second cypher employs a specified document whose 
words are simply numbered consecutively, and first letters
of these words are sought out at random to 
match the letters of these words are sought out at random
to match the letters of the clear text or message. 
 The sequence of numbers corresponding to these matches
is then written down as the final code.  While 
primitive, the process has the advantage of relative
security until the source document becomes known; 
at that moment the cypher can be decoded even by second
graders.  The work now completed with the help 
of our UNIVAC 1108 includes numerous analytical studies
of the Beale cyphers and various types of simulations. 
 For example, we have turned the entire process of
simulated encoding by various schemes over to the 
machine and analyzed the signatures of these synthetic
codes; we have also encoded various messages by 
hand, using different texts and a variety of methods to
obtain their signatures. These simulations provide 
convincing evidence that the signatures are both process
and data dependent; they indicate also very 
strongly that Mr. Beale's cyphers are for real and that
it is merely a matter of time before someone 
finds the correct source document and locates the
right vault in the common-wealth of Virginia.

CACM January, 1971

Hammer, C.

Thomas Jefferson Beale, codes, cryptanalysis, cyphers,
decoding, Declaration of Independence, encoding, 
Magna Carta, pseudotext, signature, simulation

3.42 3.63 3.65 3.71

CA710101 JB February 8, 1978  1:15 PM

2233	5	2233
2233	5	2233
2233	5	2233


************************

************************
Document:  CACM-0409.html
************************


CL-1, An Environment for a Compiler

A flexible, large-scale programming system to
facilitate the solution of information processing 
problems and to provide intercommunication between programs
and/or programmers has been developed and 
realized on the IBM 709/7090 computer.  The system is
based on a master file concept and has provisions 
for accepting, storing, and retrieving both descriptions
and instances of large and complex data sets, 
as well as algorithms defined on these data sets.  Both
data and algorithms may be expressed <B>in a</B> family 
of command and descriptive languages.  The concept
of distinct data descriptions and the content and 
use of such descriptions are discussed in some detail.

CACM January, 1961

Cheatham Jr., T. E.
Collins Jr., G. O.
Leonard, G. F.

CA610105 JB March 17, 1978  1:26 AM

409	5	409
409	5	409
409	5	409
657	5	409
279	6	409
409	6	409


************************



CL-1, An Environment for a Compiler

A flexible, large-scale programming system to
facilitate the solution of information processing 
problems and to provide intercommunication between programs
and/or programmers has been developed and 
realized <B>on the</B> IBM 709/7090 computer.  The system is
based on a master file concept and has provisions 
for accepting, storing, and retrieving both descriptions
and instances of large and complex data sets, 
as well as algorithms defined on these data sets.  Both
data and algorithms may be expressed in a family 
of command and descriptive languages.  The concept
of distinct data descriptions and the content and 
use of such descriptions are discussed in some detail.

CACM January, 1961

Cheatham Jr., T. E.
Collins Jr., G. O.
Leonard, G. F.

CA610105 JB March 17, 1978  1:26 AM

409	5	409
409	5	409
409	5	409
657	5	409
279	6	409
409	6	409


************************

************************
Document:  CACM-2092.html
************************


A Deductive Question-Answer for Natural Language Inference

The question-answering aspects of the Protosynthex III pro
totype language processing system are described and exemplified in
detail.  The system is written in LISP 1.5 and operates <B>on the</B> Q-32
time-sharing system.  The system's data structures and their semantic
organization, the deductive question-answering formalism of
relational properties and complex-relation-forming operators, and
the question-answering procedures which employ these features in
their operation are all described and illustrated.  Examples of the
system's performance and of the limitations of its question-answering 
capability are presented and discussed.  It is shown that the
use of semantic information in deductive question answering greatly 
facilitates the process, and that a top-down procedure which works
from question to answer enables effective use to be made of this
information.  It is concluded that the development of Protosynthex
III into a practically useful system to work with large data
bases is possible but will require changes in both the data
structures and the algorithms used for question answering.

CACM March, 1970

Schwarcz, R. M.
Burger, J. F.
Simmons, R. F.

question answering, natural language, Protosynthex III, LISP,
semantics, artificial intelligence, computational
linguistics, language processing, fact retrieval

3.42 3.61

CA700306 JB February 13, 1978  4:30 PM

2092	4	2092
2127	4	2092
1527	5	2092
2092	5	2092
2092	5	2092
2092	5	2092
2396	5	2092
1487	6	2092
1856	6	2092
2092	6	2092
2127	6	2092


************************

************************
Document:  CACM-1135.html
************************


A General Business-Oriented Language Based on Decision Expressions*

The structure of a digital compute programming
language which covers a wide class of business 
and file processing applications is presented.  Such
a structure, based on identifying and incorporating 
into a compiler the aspects common to all processes
of such class, permits writing extremely compact 
programs, even for comparatively complex applications,
in terms of tables of control expressions which 
express only information characteristic of the particular
application.  Furthermore,local changes of 
a process (e.g. changes affecting only one of the output
files involved) can be effected by local modifications 
in the program (e.g. modification of only one entry of the
tables).  This structure also allows for inexpensive 
preparation of loading-speed compilers which translate the
source programs into efficient machine codes. 
 The approach adopted here departs from conventional mechanical
language design philosophies.  It stresses 
the structural analysis of the class of processes to be represented
in the languages, as <B>opposed to</B> emphasizing 
formal (i.e., contents-independent) syntactical definitions.
 It relies exclusively on nonprocedural 
representation of process as sets (tables) of relations
between data and results (there are no control 
statements such as GO TO, etc.), instead of using procedure
descriptions (which are one-to-one translations 
of flowcharts).  Here an invariant pattern of procedure
is identified as characteristic of the class 
of all batch file processes.  This new philosophy has
the potential to overcome well-known deficiencies 
of other business-oriented languages and fully meets
the requirements set by CODASYL for such languages, 
including machine-independence.

CACM February, 1964

Lombardi, L. A.

CA640208 JB March 10, 1978  4:08 AM

1135	4	1135
1136	4	1135
493	4	1135
2710	4	1135
2765	4	1135
2888	4	1135
2906	4	1135
729	4	1135
1135	5	1135
1135	5	1135
1135	5	1135
1959	5	1135
616	5	1135
1135	6	1135


************************



A General Business-Oriented Language Based on Decision Expressions*

The structure of a digital compute programming
language which covers a wide class of business 
and file processing applications is presented.  Such
a structure, based on identifying and incorporating 
into a compiler the aspects common to all processes
of such class, permits writing extremely compact 
programs, even for comparatively complex applications,
in terms of tables of control expressions which 
express only information characteristic of the particular
application.  Furthermore,local changes of 
a process (e.g. changes affecting only one of the output
files involved) can be effected by local modifications 
in the program (e.g. modification of only one entry of the
tables).  This structure also allows for inexpensive 
preparation of loading-speed compilers which translate the
source programs into efficient machine codes. 
 The approach adopted here departs from conventional mechanical
language design philosophies.  It stresses 
the structural analysis of the class of processes to be represented
in the languages, <B>as opposed</B> to emphasizing 
formal (i.e., contents-independent) syntactical definitions.
 It relies exclusively on nonprocedural 
representation of process as sets (tables) of relations
between data and results (there are no control 
statements such as GO TO, etc.), instead of using procedure
descriptions (which are one-to-one translations 
of flowcharts).  Here an invariant pattern of procedure
is identified as characteristic of the class 
of all batch file processes.  This new philosophy has
the potential to overcome well-known deficiencies 
of other business-oriented languages and fully meets
the requirements set by CODASYL for such languages, 
including machine-independence.

CACM February, 1964

Lombardi, L. A.

CA640208 JB March 10, 1978  4:08 AM

1135	4	1135
1136	4	1135
493	4	1135
2710	4	1135
2765	4	1135
2888	4	1135
2906	4	1135
729	4	1135
1135	5	1135
1135	5	1135
1135	5	1135
1959	5	1135
616	5	1135
1135	6	1135


************************

************************
Document:  CACM-2096.html
************************


Experiments with the M & N Tree-Searching Program

The M & N procedure is an improvement to the mini-max
backing-up procedure widely used in computer program for game-playing
and other purposes.  It is based <B>on the</B> principle that it is
desirable to have many options when making decisions in the face of
uncertainty.  The mini-max procedure assigns to a MAX (MIN) node
the value of the highest (lowest) valued successor to that node. 
The M & N procedure assigns to a MAX (MIN) node some function of
the M (N) highest (lowest) valued successors.  An M & N procedure was
written in LISP to play the game of kalah, and it was demonstrated that 
the M & N procedure is significantly superior to the mini-max
procedure.  The statistical significance of important conclusions is given. 
Since information on statistical significance has often been lacking in papers 
on computer experiments in the artificial intelligence field, these experiments 
can perhaps serve as a model for future work.

CACM March, 1970

Slagle, J. R.
Dixon, J. K.

artificial intelligence, heuristic program, tree searching,
LISP, kalah, game playing, decision theory, 
mini-max backing-up procedure, backing-up procedures

3.60 3.64 3.66

CA700302 JB February 14, 1978  8:34 AM

1515	4	2096
2096	4	2096
2127	4	2096
2210	4	2096
1155	5	2096
2096	5	2096
2096	5	2096
2096	5	2096
2215	5	2096
2096	6	2096


************************

************************
Document:  CACM-2916.html
************************


A Fast String Searching Algorithm

An algorithm is presented that searches for
the location, "i," of the first occurrence of a 
character string, "pat," <B>in a</B>nother string, "string."
 During the search operation, the characters of 
pat are matched starting with the last character of
pat.  The information gained by starting the match 
at the end of the pattern often allows the algorithm
to proceed in large jumps through the text being 
searched.  Thus the algorithm has the unusual property that,
in most cases, not all of the first i characters 
of string are inspected.  The number of characters actually
inspected (on the average) decreases as a 
function of the length of pat.  For a random English
pattern of length 5, the algorithm will typically 
inspect i/4 characters of string before finding a match at
i.  Furthermore, the algorithm has been implemented 
so that (on the average) fewer than i+patlen machine
instructions are executed.  These conclusions are 
supported with empirical evidence and a theoretical
analysis of the average behavior of the algorithm. 
 The worst case behavior of the algorithm is linear in
i+patlen, assuming the availability of array space 
for tables linear in patlen plus the size of the alphabet.

CACM October, 1977

Boyer, R. S.

bibliographic search, computational complexity,
information retrieval, linear time bound, pattern 
matching, text editing

3.74 4.40 5.25

CA771010 JB December 27, 1977  9:43 AM

2916	4	2916
2746	5	2916
2916	5	2916
2916	5	2916
2916	5	2916
3162	5	2916
2916	6	2916


************************



A Fast String Searching Algorithm

An algorithm is presented that searches for
the location, "i," of the first occurrence of a 
character string, "pat," in another string, "string."
 During the search operation, the characters of 
pat are matched starting with the last character of
pat.  The information gained by starting the match 
at the end of the pattern often allows the algorithm
to proceed in large jumps through the text being 
searched.  Thus the algorithm has the unusual property that,
in most cases, not all of the first i characters 
of string are inspected.  The number of characters actually
inspected (<B>on the</B> average) decreases as a 
function of the length of pat.  For a random English
pattern of length 5, the algorithm will typically 
inspect i/4 characters of string before finding a match at
i.  Furthermore, the algorithm has been implemented 
so that (on the average) fewer than i+patlen machine
instructions are executed.  These conclusions are 
supported with empirical evidence and a theoretical
analysis of the average behavior of the algorithm. 
 The worst case behavior of the algorithm is linear in
i+patlen, assuming the availability of array space 
for tables linear in patlen plus the size of the alphabet.

CACM October, 1977

Boyer, R. S.

bibliographic search, computational complexity,
information retrieval, linear time bound, pattern 
matching, text editing

3.74 4.40 5.25

CA771010 JB December 27, 1977  9:43 AM

2916	4	2916
2746	5	2916
2916	5	2916
2916	5	2916
2916	5	2916
3162	5	2916
2916	6	2916


************************

************************
Document:  CACM-2683.html
************************


The Synthesis of Loop Predicates

Current methods for mechanical program verification
require a complete predicate specification 
on each loop.  Because this is tedious and error prone,
producing a program with complete, correct predicates 
is reasonably difficult and would be facilitated by machine
assistance.  This paper discusses techniques 
for mechanically synthesizing loop predicates.  Two classes
of techniques are considered: (1) heuristic 
methods which derive loop predicates from boundary conditions
and/or partially specified inductive assertions: 
(2) extraction methods which use input predicates and
appropriate weak interpretations to obtain certain 
classes of loop predicates by an evaluation <B>on the</B> weak interpretation.

CACM March, 1974

Wegbreit, B.

program verification, loop predicates, inductive
assertions, synthesis of loop predicates, weak 
interpretations, well-founded sets, property extraction, theorem proving

3.64 4.19 4.22 5.24

CA740206 JB January 18, 1978  12:55 PM 

2683	5	2683
2683	5	2683
2683	5	2683
2874	5	2683
3104	5	2683
1682	6	2683
2227	6	2683
2317	6	2683
2457	6	2683
2683	6	2683
2683	6	2683
2871	6	2683
521	6	2683


************************

************************
Document:  CACM-1681.html
************************


Easy English,a Language for Information
Retrieval Through a Remote Typewriter Console

Easy English is a natural command language
designed to simplify communication between man and 
machine through remote typewriter console.  It has been developed
for retrieval of documents from a computerized 
data base, the Moore School Information Systems Laboratory
files.  Requests are formulated in a standardized 
syntactical form (<B>examples of</B> which are presented), and
this form is then transformed into an equivalent 
query expressed in the retrieval system's original Symbolic
Command Language, which is briefly described. 
 Operation of easy English is detailed by illustration
of the transformations performed upon a sample 
request up to the point at which the request string
is sent to the system.  A macro flowchart of Easy 
English is included, and an Appendix provides
the printout of a retrieval demonstration.

CACM October, 1968

Rubinoff, M.
Bergman, S.
Cautin, H.
Rapp, F.

natural language communication, on-line searching,
remote console communication, information retrieval, 
man-machine communication, remote terminal communication,
translator, document retrieval, conversational 
mode, information retrieval language, symbolic command language

3.74 3.81 4.19

CA681006 JB February 21, 1978  3:59 PM

1681	4	1681
1699	4	1681
1194	5	1681
1681	5	1681
1681	5	1681
1681	5	1681
1699	5	1681
1194	6	1681
1324	6	1681
1681	6	1681


************************



Easy English,a Language for Information
Retrieval Through a Remote Typewriter Console

Easy English is a natural command language
designed to simplify communication between man and 
machine through remote typewriter console.  It has been developed
for retrieval of documents from a computerized 
data base, the Moore School Information Systems Laboratory
files.  Requests are formulated <B>in a</B> standardized 
syntactical form (examples of which are presented), and
this form is then transformed into an equivalent 
query expressed in the retrieval system's original Symbolic
Command Language, which is briefly described. 
 Operation of easy English is detailed by illustration
of the transformations performed upon a sample 
request up to the point at which the request string
is sent to the system.  A macro flowchart of Easy 
English is included, and an Appendix provides
the printout of a retrieval demonstration.

CACM October, 1968

Rubinoff, M.
Bergman, S.
Cautin, H.
Rapp, F.

natural language communication, on-line searching,
remote console communication, information retrieval, 
man-machine communication, remote terminal communication,
translator, document retrieval, conversational 
mode, information retrieval language, symbolic command language

3.74 3.81 4.19

CA681006 JB February 21, 1978  3:59 PM

1681	4	1681
1699	4	1681
1194	5	1681
1681	5	1681
1681	5	1681
1681	5	1681
1699	5	1681
1194	6	1681
1324	6	1681
1681	6	1681


************************

************************
Document:  CACM-2273.html
************************


Conversion of Decision Tables By Rule Mask Method Without Rule Mask

Two algorithms for generating computer programs
from decision tables are described.  The algorithms 
allow handling limited entry, extended entry, and mixed
entry tables.  The algorithms are based <B>on the</B> 
rule mask method but need not have the masks at execution
time.  They perform the logical operations 
immediately rather than at the end of the interpreting
process.  Execution time can be considerably reduced 
by instantly marking rules which are not applicable (Algorithms
1 and 2) or conditions which are already 
tested (Algorithm 2).  The new algorithms combine to a
certain degree the advantages of mask methods with 
those of tree methods.

CACM October, 1972

Dathe, G.

decision tables, rule mask, rule mask method,
rule mask technique, program generator

3.50 4.12 4.19 4.29

CA721005 JB January 27, 1978  3:02 PM

1354	4	2273
1354	4	2273
1354	4	2273
1488	4	2273
1488	4	2273
1684	4	2273
1994	4	2273
2053	4	2273
2053	4	2273
2053	4	2273
2053	4	2273
2220	4	2273
2220	4	2273
2220	4	2273
2220	4	2273
2221	4	2273
2273	4	2273
2273	4	2273
2273	4	2273
2273	4	2273
2273	4	2273
2273	4	2273
2453	4	2273
2453	4	2273
2453	4	2273
2453	4	2273
2517	4	2273
2598	4	2273
2598	4	2273
2726	4	2273
2726	4	2273
2726	4	2273
2726	4	2273
2856	4	2273
2856	4	2273
2856	4	2273
2856	4	2273
2856	4	2273
3034	4	2273
3113	4	2273
1172	5	2273
1237	5	2273
1327	5	2273
1354	5	2273
2053	5	2273
2220	5	2273
2273	5	2273
2273	5	2273
2273	5	2273


************************

************************
Document:  CACM-1931.html
************************


Interval Arithmetic Determinant Evaluation
and Its Use in Testing for a Chebyshev System

Two recent papers, one by Hansen and one by
Hansen and R. R. Smith, have shown how Interval 
Arithmetic (I.) can be used effectively to bound errors
in matrix computations.  In the present paper 
a method proposed by Hasen and R. R. Smith is compared
with straightforward use of I. in determinant 
evaluation.  Computational results show the accuracy
and running times that can be expected when using 
I. for determinant evaluation.  An application using
I. determinants <B>in a</B> program to test a set of 
functions to see if they form a Chebyshev system is then presented.

CACM February, 1969

Smith, L. B.

interval arithmetic, range arithmetic, error bounds,
determinant evaluation, Chebyshev system, 
mathematical proof by computer

5.11 5.13 5.14

CA690207 JB February 20, 1978  10:49 AM

1524	4	1931
1931	4	1931
1931	4	1931
1946	4	1931
2214	4	1931
2544	4	1931
1177	5	1931
1931	5	1931
1931	5	1931
1931	5	1931
311	5	1931


************************

************************
Document:  CACM-3132.html
************************


Experiments with Some Algorithms that Find
Central Solutions for Pattern Classification

In two-class pattern recognition, it is a standard
technique to have an algorithm finding hyperplanes
which separates the two classes <B>in a</B> linearly separable training
set.  The traditional methods find a hyperplane which separates all
points in the other, but such a hyperplane is not necessarily centered
in the empty space between the two classes.  Since a central
hyperplane does not favor one class or the other, it should have
a lower error rate in classifying new points and is therefore better
than a noncentral hyperplane.  Six algorithms for finding central
hyperplanes are tested on three data sets.  Although frequently
used practice, the modified relaxation algorithm is very poor. 
Three algorithms which are defined in the paper are found to be
quite good.

CACM March, 1979

Slagle, J.

Pattern recognition, pattern classification, linear discriminants, central
hyperplanes, centering, centrality criteria, dead zone, hyperplane,
linearly separable, relaxation algorithm, accelerated relaxation

3.62 3.63

CA790303 DH April 12, 1979  3:20 PM

3132	4	3132
2215	5	3132
3132	5	3132
3132	5	3132
3132	5	3132


************************

************************
Document:  CACM-2848.html
************************


Synthesis of Decision Rules

Decision tables can be used as an effective
tool during an interview to record the logic of 
processes to be automated.  The result of such an interview
is not a structure <B>of complete</B> decision tables 
but rather sets of decision rules.  The purpose of this
paper is to provide a procedure for synthesizing 
the decision rules and thus provide an aid in developing
a structure of complete decision tables.

CACM July, 1976

Cheng, C.
Rabin, J.

decision rules, decision tables, logical tables,
logical design, system design, specification language

3.50 4.33

CA760705 JB January 4, 1978  12:39 PM

2848	5	2848
2848	5	2848
2848	5	2848


************************

************************
Document:  CACM-0527.html
************************


The Description List of Concepts

A concept is defined as a class of objects
whose members can be distinguished by processing 
its properties.  Property is defined to mean a partition
of the set of all objects into disjoint classes. 
 The formal definition of a concept is recursive in nature.
 A concept is described by a list structure. 
 A one-to-one correspondence is established between the
recursive definition of a concept and its description 
list structure.  Like the definition, the description
list structure of a concept is also built up from 
elementary list structures by a recursive process. 
The list structures obtained this way are compared 
with the description list structure discussed
by the author <B>in a</B> previous publication.

CACM August, 1962

Banerji, R. B.

CA620801 JB March 17, 1978  7:39 PM

527	5	527
527	5	527
527	5	527


************************

************************
Document:  CACM-2620.html
************************


Execution Time Requirements for Encipherment Programs

Although encipherment has often been discussed
as a means to protect computer data, its costs 
are not well established.  Five experiments were conducted
to measure the cpu time on a CDC 6400 required 
by additive ciphers programmed both <B>in a</B>ssembly language
and in Fortran: a "null transformation" to measure 
the time to move data without encipherment; encipherment
with one-word key; encipherment with a 125-word 
key; double key encipherment; and encipherment using
a pseudo random key.  The results were analyzed 
for consistency over 100 runs, and the effects of constant
and intermittent errors were considered.  
Timing rates for assembly language encipherment ranged
from 498,800 characters per second for a pseudo 
random key cipher to 2,092,000 characters per second
for a constant one-word key cipher.  The latter 
is almost equivalent to the rate required simply to move
data without encipherment.  Fortran tests required 
over four times as much cpu time.  This paper introduces
the idea on enciphering time coefficient the 
ratio of enciphering time to the time taken to
fetch and store data without encipherment.

CACM August, 1974

Friedman, T. D.
offman, L. J.

encipherment, ciphers, security, privacy transformations,
protection, cryptography, cryptology

2.12 2.43 3.70 3.81 4.32 4.39

CA740804 JB January 17, 1978  10:05 AM

2620	5	2620
2620	5	2620
2620	5	2620


************************

************************
Document:  CACM-2900.html
************************


Some Theorems to Aid in Solving the File Allocation Problem

The file allocation problem-i.e. the problem
of finding the optimal set of network sites at 
which to locate copies of a file-is known to be, in general,
polynomial complete.  Heuristics and other 
aids to finding optimal, or near-optimal, solutions are
therefore much needed.  In this paper we present 
three theorems which can be applied a priori to indicate
that certain sites should (or should not) be 
included <B>in a</B>n optimal allocation.

CACM November, 1977

Grapa, E.
Belford, G. G.

File allocation, computer networks, distributed data management

4.33

CA771116 JB December 27, 1977  8:45 AM

2900	5	2900
2900	5	2900
2900	5	2900


************************

************************
Document:  CACM-2232.html
************************


Pattern Width at a Given Angle

That the pattern feature "width as a function
of angle" possesses several possible interpretations 
is demonstrated in this paper, which is a review of
the width concept in pattern recognition and the 
geometrical concept itself.  The object of the work
is to clarify how the word description can be made 
precise so that computer algorithms for feature extraction
may be obtained; the focus is <B>on the</B> theoretical 
subject matter.  The results consist of a set-theoretic
definition of width-at-angle, a theorem relating 
it to the pattern boundary radius vector, and descriptions
of alternate widths.  All widths are calculated 
for an illustrative example; graphical and tabular comparisons
are given.  Substantial variation in width-at-angle 
magnitude is found.  The principal conclusion is that
the set-theoretic width-at-angle is a useful pattern 
feature when it can be easily computed.  Further investigation
of the information contained in only part 
of a width function is recommended for cases where
computation of width-at-angle is difficult.

CACM January, 1971

Klinger, A.

feature extraction, pattern recognition,figure
properties, picture processing, integral geometry, 
width-at-angle, extent, integral projections,
linear pattern measures, width functions

3.60 3.62 3.63 5.12

CA710102 JB February 8, 1978  12:49 PM

2232	5	2232
2232	5	2232
2232	5	2232


************************

************************
Document:  CACM-2851.html
************************


Formal Verification of Parallel Programs

Two formal models for parallel computation
are presented: an abstract conceptual model and 
a parallel-program model.  The former model does not
distinguish between control and data states.  The 
latter model includes the capability for the representation
of an infinite set of control states by allowing 
there to be arbitrarily many instruction pointers (or
processes) executing the program.  An induction 
principle is presented which treats the control and
data state sets on the same ground.  Through the 
use of "place variables," it is observed that certain
correctness conditions can be expressed without 
enumeration of the set of all possible control states.
 Examples are presented in which the induction 
principle is used to demonstrate proofs of mutual exclusion.
 It is shown that assertions-oriented proof 
methods are special cases of the induction principle.
A special case of the assertions method, which 
is called parallel place assertions, is shown to be
incomplete.  A formalization of "deadlock" is then 
presented. The concept of a "norm" is introduced, which
yields an extension, to the deadlock problem, 
of Floyd's technique for proving termination.  Also discussed
is an extension of the program model which 
allows each process to have its own local variables
and permits shared global variables.  Correctness 
of certain forms of implementation is also discussed.
 An Appendix is included which relates this work 
to previous <B>work on</B> the satisfiability of certain logical formulas.

CACM July, 1976

Keller, R. M.

parallel program, correctness, verification,
assertions, deadlock, mutual exclusion, Petrinet

4.6 5.2 6.9 8.1

CA760702 JB January 4, 1978  1:20 PM

2228	4	2851
2280	4	2851
2379	4	2851
2320	4	2851
2482	4	2851
2597	4	2851
2740	4	2851
2777	4	2851
2851	4	2851
2851	4	2851
2895	4	2851
2912	4	2851
2920	4	2851
2946	4	2851
3128	4	2851
1877	5	2851
2150	5	2851
2851	5	2851
2851	5	2851
2851	5	2851


************************



Formal Verification of Parallel Programs

Two formal models for parallel computation
are presented: an abstract conceptual model and 
a parallel-program model.  The former model does not
distinguish between control and data states.  The 
latter model includes the capability for the representation
of an infinite set of control states by allowing 
there to be arbitrarily many instruction pointers (or
processes) executing the program.  An induction 
principle is presented which treats the control and
data state sets <B>on the</B> same ground.  Through the 
use of "place variables," it is observed that certain
correctness conditions can be expressed without 
enumeration of the set of all possible control states.
 Examples are presented in which the induction 
principle is used to demonstrate proofs of mutual exclusion.
 It is shown that assertions-oriented proof 
methods are special cases of the induction principle.
A special case of the assertions method, which 
is called parallel place assertions, is shown to be
incomplete.  A formalization of "deadlock" is then 
presented. The concept of a "norm" is introduced, which
yields an extension, to the deadlock problem, 
of Floyd's technique for proving termination.  Also discussed
is an extension of the program model which 
allows each process to have its own local variables
and permits shared global variables.  Correctness 
of certain forms of implementation is also discussed.
 An Appendix is included which relates this work 
to previous work on the satisfiability of certain logical formulas.

CACM July, 1976

Keller, R. M.

parallel program, correctness, verification,
assertions, deadlock, mutual exclusion, Petrinet

4.6 5.2 6.9 8.1

CA760702 JB January 4, 1978  1:20 PM

2228	4	2851
2280	4	2851
2379	4	2851
2320	4	2851
2482	4	2851
2597	4	2851
2740	4	2851
2777	4	2851
2851	4	2851
2851	4	2851
2895	4	2851
2912	4	2851
2920	4	2851
2946	4	2851
3128	4	2851
1877	5	2851
2150	5	2851
2851	5	2851
2851	5	2851
2851	5	2851


************************

************************
Document:  CACM-2969.html
************************


Optimal Program and Data Locations in Computer Networks

An optimization procedure for the allocation
of program and data files <B>in a</B> computer network 
is presented.  This algorithm takes into account the
dependencies between files and programs such as 
occur in real heterogeneous computer networks.  Insights
into whether or not to convert programs from 
one computer to another can also be gained from the
model.  A search procedure for the file location 
problem is described, along with an example
and a possible application of the model.

CACM May, 1977

Morgan, H. L.
Levin, K. D.

computer networks, databases, distributed
databases, optimal file location

3.81 3.51 4.33

CA770503 JB December 29, 1977  2:22 AM

2969	5	2969
2969	5	2969
2969	5	2969


************************

************************
Document:  CACM-1677.html
************************


Storage Organization in Programming Systems

The system of program and data representation
that has been in use <B>on the</B> Rice University computer 
for five years is described.  Each logical entity in storage
occupies a block of consecutive memory locations. 
 Each block is labeled by a codeword and may contain
a program, a data vector, or codewords which in 
turn label blocks to form arrays.  This storage arrangement
is discussed with its realized advantages 
or programming systems: simplicity of programmed addressing,
flexibility of data structures, efficiency 
of memory utilization, variability of system composition
during execution, means of linkage between programs 
and from programs to data, and basis for storage protection.
 The application of labeled blocks may be 
extended to areas of time-sharing and multimedia storage
control.  On the basis of experience at rice, 
some ideas on such extensions are presented.

CACM November, 1968

Jodeit, J. G.

storage allocation, storage organization, storage
control, codewords, data representation, program 
representation, data structures, storage protection,
addressing mechanisms, paging, segmentation, file 
handling

4.30 4.40 6.20

CA681102 JB February 21, 1978  3:11 PM

1677	5	1677
1677	5	1677
1677	5	1677
2064	5	1677
1677	6	1677


************************

************************
Document:  CACM-2314.html
************************


Requirements for Advanced Programming Systems for List Processing

List processing systems should be designed to
facilitate production of large programs to manipulate 
large complex symbolic data stores.  This paper presents
an overview of a number of system features which 
the author feels are important to improve the productivity
of programmers working in such domains.  A 
system view it taken, rather than focusing just on language
features, since algorithms must be not only 
coded <B>in a</B> language form, but debugged, modified, made
efficient, and run on data.  Because of this general 
framework,the requirements specified are applicable
to the design of advanced programming systems for 
a wide range of applications.  Three aspects of programming
systems are highlighted: good interactive 
facilities, programmable control structures, and sophisticated
data communication mechanisms.  Interactive 
features are described to facilitate program composition,
entry, testing, debugging, editing, optimization, 
and packaging.  Implementation of a generalized environment
structure model specified would allow programming 
of various control regimes including multiprocesses,
coroutines and backtracking.  Alternative methods 
of procedure invocation required include invocation
by pattern and by monitoring condition.  The  need 
for extended data forms, storage management, and extensibility
are stressed, as is the duality of data 
retrieval and function evaluation.  Syntax directed
input and output of data would facilitate use of 
complex data stores.

CACM July, 1972

Bobrow, D. G.

list processing, programming languages, design of
programming languages, interactive systems, control 
structures, data structures, programming primitives,
semantics, advanced programming systems

1.3 4.2 4.22 4.3 4.32 5.23 5.24

CA720714 JB January 30, 1978  1:30 PM

1570	4	2314
1708	4	2314
1781	4	2314
1826	4	2314
1860	4	2314
1945	4	2314
2156	4	2314
2168	4	2314
2249	4	2314
2314	4	2314
2314	4	2314
2314	4	2314
2314	4	2314
2317	4	2314
2719	4	2314
2736	4	2314
2833	4	2314
2842	4	2314
1098	5	2314
1626	5	2314
2082	5	2314
2148	5	2314
2314	5	2314
2314	5	2314
2314	5	2314
2438	5	2314
1826	6	2314
2314	6	2314


************************

************************
Document:  CACM-3013.html
************************


Some New Methods of Detecting Step Edges in Digital Pictures

This note describes two operators that respond
to step edges, <B>but not</B> to ramps.  The first 
is similar to the digital Laplacian, but uses the max, rather
than the sum, of the x and y second differences. 
 The second uses the difference between the mean and
median gray levels in a neighborhood.  The outputs 
obtained from these operators applied to a set of test
pictures are compared with each other and with 
the standard digital Laplacian and gradient.  A third
operator, which uses the distance between the center 
and centroid of a neighborhood as an edge value, is also
briefly considered; it turns out to be equivalent 
to one of the standard digital approximations to the gradient.

CACM February,1978

Schachter, B.
Rosenfeld, A.

image processing, pattern recognition, edge detection

3.63

CA780210 JB March 28, 1978  1:56 PM

3013	5	3013
3013	5	3013
3013	5	3013


************************



Some New Methods of Detecting Step Edges in Digital Pictures

This note describes two operators that respond
to step edges, but not to ramps.  The first 
is similar to the digital Laplacian, but uses the max, rather
than the sum, of the x and y second differences. 
 The second uses the difference between the mean and
median gray levels <B>in a</B> neighborhood.  The outputs 
obtained from these operators applied to a set of test
pictures are compared with each other and with 
the standard digital Laplacian and gradient.  A third
operator, which uses the distance between the center 
and centroid of a neighborhood as an edge value, is also
briefly considered; it turns out to be equivalent 
to one of the standard digital approximations to the gradient.

CACM February,1978

Schachter, B.
Rosenfeld, A.

image processing, pattern recognition, edge detection

3.63

CA780210 JB March 28, 1978  1:56 PM

3013	5	3013
3013	5	3013
3013	5	3013


************************

************************
Document:  CACM-1978.html
************************


The Use of Interactive Graphics To Solve Numerical Problems

With the advent of on-line (time-sharing) computer systems
and graphic terminals, we have available a new dimension
in numerical problem solving capabilities.  Rather than simply use
the new power to achieve fast turnaround, we can develop interactive
routines which are easy to use and also take advantage of the
insight and visual capabilities of the human problem solver.  Several
on-line systems for general purpose mathematical problem solving
have already been implemented as well as some special purpose
systems for solving problems <B>in a</B> particular area such as ordinary
differential equations.  The advantage of restricting the problem
area is that the interface with a user can be greatly simplified.
In this paper we discuss some of the advantages accrued by such
systems and design considerations for interactive routines.  Furthermore,
an implementation of an on-line least squares data-fitting
program, PEG, is presented with results obtained from empirical
data.  In conclusion, area for future work in this field are discussed.

CACM October, 1970

Smith, L. B.

interactive graphics, computer graphics, graphics, least squares,
data-fitting, interactive computing, on-line mathematics

1.3 3.1 5.13 5.5

CA701012 JB February 10, 1978  9:14 AM

1978	4	1978
1978	4	1978
1978	4	1978
1307	5	1978
1589	5	1978
1813	5	1978
1978	5	1978
1978	5	1978
1978	5	1978


************************

************************
Document:  CACM-2721.html
************************


The Digital Simulation of River Plankton Population Dynamics

This paper deals with the development of a
mathematical model for and the digital simulation 
in Fortran IV of phytoplankton and zooplankton population
densities <B>in a</B> river using previously developed 
rate expressions.  In order to study the relationships
between the ecological mechanisms involved, the 
simulation parameters were varied illustrating the
response of the ecosystem to different conditions, 
including those corresponding to certain types of chemical
and thermal pollution.  As an investigation 
of the accuracy of the simulation methods, a simulation
of the actual population dynamics of Asterionella 
in the Columbia River was made based on approximations
of conditions in that river. Although not totally 
accurate, the simulation was found to predict the general
annual pattern of plankton growth fairly well 
and, specifically, revealed the importance of the annual
velocity cycle in determining such patterns. 
 In addition, the study demonstrates the usefulness of
digital simulations in the examinations of certain 
aquatic ecosystems, as well as in environmental
planning involving such examinations.

CACM September, 1975

Claudson, R. M.

digital simulation, mathematical modeling, plankton
population dynamics, phytoplankton, zooplankton, 
river ecosystems, ecological mechanisms, environmental simulation,
modeling ecosystems, pollution, environmental 
impact, environmental planning

3.12 3.19

CA750903 JB January 6, 1978  2:55 PM

2721	5	2721
2721	5	2721
2721	5	2721


************************

************************
Document:  CACM-2816.html
************************


Optimal Reorganization of Distributed Space Disk Files

In most database organizations, the cost of accessing
the database will increase due to structural 
changes caused by updates and insertions.  By reorganizing
the database,the access costs can be reduced. 
 A basic problem is to establish the proper tradeoff between
performance, storage costs, and reorganization 
costs.  This paper considers the optimum points at which
to reorganize a database.  A disk file organization 
which allows for distributed free space is described.
 A cost function describing the excess costs due 
to physical disorganization is defined, and this function
is minimized to obtain the optimum reorganization 
points.  Numerical examples based <B>on the</B> characteristics
of existing disk storage devices are given.

CACM November, 1976

Maruyama, K.
Smith, S. E.

disk file, free space,retrieval, insertion, deterioration, reorganization

3.70 3.73

CA761107 JB January 3, 1978  2:59 PM

2816	4	2816
2816	4	2816
2816	4	2816
2828	4	2816
2827	4	2816
2913	4	2816
3047	4	2816
3047	4	2816
3129	4	2816
2493	5	2816
2751	5	2816
2816	5	2816
2816	5	2816
2816	5	2816
2829	5	2816
3129	5	2816
2493	6	2816
2816	6	2816


************************

************************
Document:  CACM-0435.html
************************


A Decision Matrix as the Basis for a Simple Data Input Routine

Currently a great deal of time and effort is
being spent <B>on the</B> development of bigger and better 
compiler languages, multiprogram executive systems,
etc.  Since the implementation of  of new methods 
and procedures is not instantaneous, but rather occurs
by an evolutionary process, we should be concerned 
also with the problem of maintaining, improving and
incorporating new ideas into existing systems.  It 
is with this somewhat neglected area that the author is
interested.  A method employing a decision matrix 
is presented for the handling of a standard systems
programming problem,that of providing a data input 
routine.

CACM December, 1962

Vasilakos, G. J.

CA621204 JB March 17, 1978  5:15 PM

249	4	435
254	4	435
272	4	435
1102	4	435
1109	4	435
1140	4	435
1188	4	435
1306	4	435
1464	4	435
1491	4	435
1767	4	435
1781	4	435
1787	4	435
1949	4	435
321	4	435
2059	4	435
2126	4	435
435	4	435
435	4	435
437	4	435
463	4	435
483	4	435
491	4	435
2732	4	435
560	4	435
583	4	435
3073	4	435
627	4	435
631	4	435
632	4	435
642	4	435
644	4	435
653	4	435
680	4	435
761	4	435
762	4	435
763	4	435
849	4	435
123	4	435
140	4	435
919	4	435
989	4	435
196	5	435
1053	5	435
435	5	435
435	5	435
435	5	435
615	5	435
435	6	435
474	6	435
718	6	435
720	6	435


************************

************************
Document:  CACM-2905.html
************************


Perfect Hashing Functions: A Single
Probe Retrieving Method for Static Sets

A refinement of hashing which allows retrieval
of an item <B>in a</B> static table with a single probe 
is considered.  Given a set I of identifiers, two methods
are presented for building, in a mechanical 
way, perfect hashing functions, i.e. functions transforming
the elements of I into unique addresses. 
 The first method, the "quotient reduction" method, is
shown to be complete in the sense that for every 
set I the smallest table in which the elements of I
can be stored and from which they can be retrieved 
by using a perfect hashing function constructed by this
method can be found.  However, for nonuniformly 
distributed sets, this method can give rather sparse tables.
 The second method, the "remainder reduction" 
method, is not complete in the above sense, but it seems
to give minimal (or almost minimal) tables for 
every kind of set.  The two techniques are applicable
directly to small sets.  Some methods to extend 
these results to larger sets are also presented.  A rough
comparison with ordinary hashing is given which 
shows that this method can be used conveniently
in several practical applications.

CACM November, 1977

Sprugnoli, R.

hashing, hashing methods, hash coding, direct addressing,
identifier-to-address transformations, 
perfect hashing functions, perfect hash coding, reduction, scatter storage

3.7 3.74 4.34

CA771111 JB December 27, 1977  6:45 AM

2905	4	2905
2905	5	2905
2905	5	2905
2905	5	2905
3041	5	2905
3126	5	2905
3176	5	2905
829	5	2905
2846	6	2905
2905	6	2905
2905	6	2905
2905	6	2905


************************



Perfect Hashing Functions: A Single
Probe Retrieving Method for Static Sets

A refinement of hashing which allows retrieval
of an item in a static table with a single probe 
is considered.  Given a set I of identifiers, two methods
are presented for building, in a mechanical 
way, perfect hashing functions, i.e. functions transforming
the elements of I into unique addresses. 
 The first method, the "quotient reduction" method, is
shown to be complete in the sense that for every 
set I the smallest table in which the elements of I
can be stored and from which they can be retrieved 
by using a perfect hashing function constructed by this
method can be found.  However, for nonuniformly 
distributed sets, this method can give rather sparse tables.
 The second method, the "remainder reduction" 
method, is not complete in the above sense, but it seems
to give minimal (or almost minimal) tables for 
every kind of set.  The two techniques are applicable
directly to small sets.  Some methods to extend 
these results to larger sets are also presented.  A rough
comparison <B>with or</B>dinary hashing is given which 
shows that this method can be used conveniently
in several practical applications.

CACM November, 1977

Sprugnoli, R.

hashing, hashing methods, hash coding, direct addressing,
identifier-to-address transformations, 
perfect hashing functions, perfect hash coding, reduction, scatter storage

3.7 3.74 4.34

CA771111 JB December 27, 1977  6:45 AM

2905	4	2905
2905	5	2905
2905	5	2905
2905	5	2905
3041	5	2905
3126	5	2905
3176	5	2905
829	5	2905
2846	6	2905
2905	6	2905
2905	6	2905
2905	6	2905


************************

************************
Document:  CACM-2939.html
************************


Abstraction Mechanisms in CLU

CLU is a new programming language designed to support
the use of abstractions in program construction. 
 Work in programming methodology has led to the realization
that three kinds of abstractions-procedural, 
control, and especially data abstractions-are useful
in the programming process.  Of these, only the 
procedural abstraction is supported well by conventional
languages, through the procedure or subroutine. 
 CLU provides, <B>in a</B>ddition to procedures, novel linguistic
mechanisms that support the use of data and 
control abstractions.  This paper provides an in troduction
to the abstraction mechanisms in CLU.  By 
means of programming examples, the utility of the three
kinds of abstractions in program construction 
is illustrated, and it is shown how CLU programs may
be written to use and implement abstractions.  The 
CLU library, which permits incremental program development
with complete type checking performed at compile 
time, is also discussed.

CACM August, 1977

Liskov, B.
Snyder, A.
Atkinson, R.
Schaffert, C.

programming languages, data types, data abstractions,
control abstractions, programming methodology, 
separate compilation

4.0 4.12 4.20 4.22

CA770804 JB December 28, 1977  7:49 AM

2319	4	2939
2480	4	2939
2594	4	2939
2709	4	2939
2868	4	2939
2939	4	2939
2939	4	2939
2941	4	2939
2972	4	2939
3155	4	2939
2204	5	2939
2558	5	2939
2939	5	2939
2939	5	2939
2939	5	2939
3031	5	2939
3105	5	2939
3148	5	2939
3150	5	2939
1471	6	2939
1860	6	2939
2060	6	2939
2625	6	2939
2632	6	2939
2704	6	2939
2817	6	2939
2842	6	2939
2865	6	2939
2868	6	2939
2939	6	2939
2939	6	2939
2939	6	2939
2939	6	2939
2940	6	2939
2941	6	2939
2943	6	2939
2958	6	2939
3068	6	2939
3073	6	2939
3073	6	2939
3148	6	2939


************************



Abstraction Mechanisms in CLU

CLU is a new programming language designed to support
the use of abstractions in program construction. 
 Work in programming methodology has led to the realization
that three kinds of abstractions-procedural, 
control, and especially data abstractions-are useful
in the programming process.  Of these, only the 
procedural abstraction is supported well by conventional
languages, through the procedure or subroutine. 
 CLU provides, in addition to procedures, novel linguistic
mechanisms that support the use of data and 
control abstractions.  This paper provides an in troduction
to <B>the abstract</B>ion mechanisms in CLU.  By 
means of programming examples, the utility of the three
kinds of abstractions in program construction 
is illustrated, and it is shown how CLU programs may
be written to use and implement abstractions.  The 
CLU library, which permits incremental program development
with complete type checking performed at compile 
time, is also discussed.

CACM August, 1977

Liskov, B.
Snyder, A.
Atkinson, R.
Schaffert, C.

programming languages, data types, data abstractions,
control abstractions, programming methodology, 
separate compilation

4.0 4.12 4.20 4.22

CA770804 JB December 28, 1977  7:49 AM

2319	4	2939
2480	4	2939
2594	4	2939
2709	4	2939
2868	4	2939
2939	4	2939
2939	4	2939
2941	4	2939
2972	4	2939
3155	4	2939
2204	5	2939
2558	5	2939
2939	5	2939
2939	5	2939
2939	5	2939
3031	5	2939
3105	5	2939
3148	5	2939
3150	5	2939
1471	6	2939
1860	6	2939
2060	6	2939
2625	6	2939
2632	6	2939
2704	6	2939
2817	6	2939
2842	6	2939
2865	6	2939
2868	6	2939
2939	6	2939
2939	6	2939
2939	6	2939
2939	6	2939
2940	6	2939
2941	6	2939
2943	6	2939
2958	6	2939
3068	6	2939
3073	6	2939
3073	6	2939
3148	6	2939


************************

************************
Document:  CACM-1165.html
************************


The Spectra 70/45 Emulator for the RCA 301

The RCA 301 Emulator System is supplied with
the Spectra 70/45 as a reprogramming aid.  It 
allows an RCA 301 object program to be run <B>on the</B> Spectra
70/45 without necessitating changes in the 
RCA 301 object code.  Execution rates are considerably
better than traditional simulation.  The Emulator 
provides an increase in throughput capacity for the
301 user on the Spectra 70/45.  The Emulator makes 
use of both hardware micro-program routines and
software routines to accomplish its function.

CACM December, 1965

Benjamin, R. I.

CA651204 JB March 6, 1978  4:15 PM

1165	5	1165
1165	5	1165
1165	5	1165


************************

************************
Document:  CACM-2359.html
************************


An Improved Index Sequential Access Method Using Hashed Overflow

The Index Sequential Access Method (ISAM) is
one of the most important file management systems 
used with moveable head disk devices.  This study investigates
the use of an unconventional method of 
treating overflow records.  The method is to use hashing
techniques to allocate space for such records. 
 If certain conditions are satisfied, this is superior
to the conventional ISAM method of chaining the 
overflow records via linked list techniques.  These conditions are:
long overflow chains with significant 
overflow; lack of tight disk space constraints; record
keys which are small compared to the total record 
size; and significant use of the file in the index as opposed
to the sequential mode.  Using hashed overflow, 
the time to locate a record is dependent not <B>on the</B> total
volume of overflow records as in conventional 
ISAM, but on the percentage use of space dedicated to overflow records.

CACM May, 1972

Mullin, J. K.

ISAM, index sequential, hashing, scatter
storage, disk, cylinder, overflow

3.72 3.73 3.74

CA720501 JB January 31, 1978  12:29 PM

1676	4	2359
1682	4	2359
1728	4	2359
1860	4	2359
1973	4	2359
2018	4	2359
2032	4	2359
2033	4	2359
2107	4	2359
2109	4	2359
2203	4	2359
2251	4	2359
2258	4	2359
2319	4	2359
2313	4	2359
2359	4	2359
2359	4	2359
2437	4	2359
2524	4	2359
2543	4	2359
2552	4	2359
2552	4	2359
2559	4	2359
2781	4	2359
2860	4	2359
2991	4	2359
2991	4	2359
3053	4	2359
1785	5	2359
2203	5	2359
2359	5	2359
2359	5	2359
2359	5	2359


************************



An Improved Index Sequential Access Method Using Hashed Overflow

The Index Sequential Access Method (ISAM) is
one of the most important file management systems 
used with moveable head disk devices.  This study investigates
the use of an unconventional method of 
treating overflow records.  The method is to use hashing
techniques to allocate space for such records. 
 If certain conditions are satisfied, this is superior
to the conventional ISAM method of chaining the 
overflow records via linked list techniques.  These conditions are:
long overflow chains with significant 
overflow; lack of tight disk space constraints; record
keys which are small compared to the total record 
size; and significant use of the file in the index <B>as opposed</B>
to the sequential mode.  Using hashed overflow, 
the time to locate a record is dependent not on the total
volume of overflow records as in conventional 
ISAM, but on the percentage use of space dedicated to overflow records.

CACM May, 1972

Mullin, J. K.

ISAM, index sequential, hashing, scatter
storage, disk, cylinder, overflow

3.72 3.73 3.74

CA720501 JB January 31, 1978  12:29 PM

1676	4	2359
1682	4	2359
1728	4	2359
1860	4	2359
1973	4	2359
2018	4	2359
2032	4	2359
2033	4	2359
2107	4	2359
2109	4	2359
2203	4	2359
2251	4	2359
2258	4	2359
2319	4	2359
2313	4	2359
2359	4	2359
2359	4	2359
2437	4	2359
2524	4	2359
2543	4	2359
2552	4	2359
2552	4	2359
2559	4	2359
2781	4	2359
2860	4	2359
2991	4	2359
2991	4	2359
3053	4	2359
1785	5	2359
2203	5	2359
2359	5	2359
2359	5	2359
2359	5	2359


************************

************************
Document:  CACM-3043.html
************************


Distributed Processes: A Concurrent Programming Concept

A language concept for concurrent processes
without common variables is introduced.  These 
processes communicate and synchronize by means of procedure
calls and guarded regions.  This concept 
is proposed for real-time applications controlled by
microcomputer networks with distributed storage. 
 The paper gives several <B>examples of</B> distributed processes
and shows that they include procedures, coroutines, 
classes, monitors, processes, semaphores, buffers, path
expressions, and input/output as special cases.

CACM November, 1978

Hansen, P.

Concurrent programming, distributed processes,
microprocessor networks, nondeterminism, guarded 
regions, programming languages, process communication
and scheduling, sorting arrays, coroutines, classes, 
monitors, processes, semaphores, buffers, path expressions, input/output 

3.8 4.2 4.22 4.32 5.24

CA781108 DH January 26, 1979  10:40 AM

2865	4	3043
2866	4	3043
2896	4	3043
2898	4	3043
2972	4	3043
2972	4	3043
3037	4	3043
3039	4	3043
3043	4	3043
3043	4	3043
3073	4	3043
3128	4	3043
3144	4	3043
2597	5	3043
2732	5	3043
3043	5	3043
3043	5	3043
3043	5	3043


************************



Distributed Processes: A Concurrent Programming Concept

A language concept for concurrent processes
without common variables is introduced.  These 
processes communicate and synchronize by means of procedure
<B>calls and</B> guarded regions.  This concept 
is proposed for real-time applications controlled by
microcomputer networks with distributed storage. 
 The paper gives several examples of distributed processes
and shows that they include procedures, coroutines, 
classes, monitors, processes, semaphores, buffers, path
expressions, and input/output as special cases.

CACM November, 1978

Hansen, P.

Concurrent programming, distributed processes,
microprocessor networks, nondeterminism, guarded 
regions, programming languages, process communication
and scheduling, sorting arrays, coroutines, classes, 
monitors, processes, semaphores, buffers, path expressions, input/output 

3.8 4.2 4.22 4.32 5.24

CA781108 DH January 26, 1979  10:40 AM

2865	4	3043
2866	4	3043
2896	4	3043
2898	4	3043
2972	4	3043
2972	4	3043
3037	4	3043
3039	4	3043
3043	4	3043
3043	4	3043
3073	4	3043
3128	4	3043
3144	4	3043
2597	5	3043
2732	5	3043
3043	5	3043
3043	5	3043
3043	5	3043


************************

************************
Document:  CACM-3128.html
************************


Synchronization with Eventcounts and Sequencers

Synchronization of concurrent processes requires controlling the relative 
ordering of events in the processes.
A new synchronization mechanism is proposed, using 
abstract objects called eventcounts and sequencers, that allows processes
to control the ordering of events directly, rather than using mutual
exclusion to protect manipulations of shared variables that control
ordering of events.  Direct control of ordering seems to simplify
correctness arguments and also simplifies implementation in distributed
systems.  The mechanism is defined formally, and then several
<B>examples of</B> its use are given.  The relationship of the mechanism
to protection mechanisms in the system is explained; in particular,
eventcounts are shown to be applicable to situations where confinement
of information matters.  An implementation of eventcount
s and sequencers in a system with shared memory is described.

CACM February, 1979

Reed, D.
Kanodia, R.

Process synchronization, interprocess communication, distributed
systems, security models, mutual exclusion, semaphores

4.30 4.32

CA790207 DH April 12, 1979  10:03 AM

2320	4	3128
2597	4	3128
2700	4	3128
2777	4	3128
2840	4	3128
2851	4	3128
2865	4	3128
2866	4	3128
2869	4	3128
2895	4	3128
2898	4	3128
2912	4	3128
2938	4	3128
2945	4	3128
2946	4	3128
2946	4	3128
2972	4	3128
3043	4	3128
3128	4	3128
3128	4	3128
3128	4	3128
3128	4	3128
3128	4	3128
3128	4	3128
3128	4	3128
3128	4	3128
3128	4	3128
3144	4	3128
3148	4	3128
3158	4	3128
2150	5	3128
2376	5	3128
2436	5	3128
2597	5	3128
2865	5	3128
2866	5	3128
2870	5	3128
2912	5	3128
3082	5	3128
3128	5	3128
3128	5	3128
3128	5	3128


************************



Synchronization with Eventcounts and Sequencers

Synchronization of concurrent processes requires controlling the relative 
ordering of events in the processes.
A new synchronization mechanism is proposed, using 
abstract objects called eventcounts and sequencers, that allows processes
to control the ordering of events directly, rather than using mutual
exclusion to protect manipulations of shared variables that control
ordering of events.  Direct control of ordering seems to simplify
correctness arguments and also simplifies implementation in distributed
systems.  The mechanism is defined formally, and then several
examples of its use are given.  The relationship of the mechanism
to protection mechanisms in the system is explained; in particular,
eventcounts are shown to be applicable to situations where confinement
of information matters.  An implementation of eventcount
s and sequencers <B>in a</B> system with shared memory is described.

CACM February, 1979

Reed, D.
Kanodia, R.

Process synchronization, interprocess communication, distributed
systems, security models, mutual exclusion, semaphores

4.30 4.32

CA790207 DH April 12, 1979  10:03 AM

2320	4	3128
2597	4	3128
2700	4	3128
2777	4	3128
2840	4	3128
2851	4	3128
2865	4	3128
2866	4	3128
2869	4	3128
2895	4	3128
2898	4	3128
2912	4	3128
2938	4	3128
2945	4	3128
2946	4	3128
2946	4	3128
2972	4	3128
3043	4	3128
3128	4	3128
3128	4	3128
3128	4	3128
3128	4	3128
3128	4	3128
3128	4	3128
3128	4	3128
3128	4	3128
3128	4	3128
3144	4	3128
3148	4	3128
3158	4	3128
2150	5	3128
2376	5	3128
2436	5	3128
2597	5	3128
2865	5	3128
2866	5	3128
2870	5	3128
2912	5	3128
3082	5	3128
3128	5	3128
3128	5	3128
3128	5	3128


************************

************************
Document:  CACM-1651.html
************************


An Interpretive Input Routine for Linear Programming

In this descriptive article an input code
is presented which greatly simplifies data input 
to any linear programming solution routine, for subsequent
use either as a pedagogical device or for 
solving rather small LP problems.  This latter (limited)
use derives not at all from inherent limitations 
in the code itself, but from an efficiency evaluation:
large LP problems would doubtless benefit from 
an input system more suited for bulk data handling than
the input code described.  From a user's standpoint, 
input appears almost exactly as a textbook presentation
of the LP problem (limited only by a keypunch's 
inability to write subscripts, etc.).  The input interpreter
scans column wise, thus no fixed format 
data preparation is required.  The user may also, under
very general requirements only, liberally use 
editorial comments throughout the input deck as an
aid in identification, e.g., of row constraints.  
The article includes <B>examples of</B> input, output from a
solution routine presently in use, and a skeleton 
flowchart of the input interpreter.

CACM January, 1967

Aigner, D. J.

CA670104 JB March 1, 1978  8:58 AM

1651	5	1651
1651	5	1651
1651	5	1651


************************

************************
Document:  CACM-1307.html
************************


A Lightpen-Controlled Program For On-Line Data Analysis

This paper describes a technique designed
to ease the use of a data processing system by a 
person, in particular, a scientist, who is intimately and
primarily concerned with interpreting the significance 
of data handled by the system.  Since such a person is
often unable to spend the time necessary to master 
a programming language, it is essential that he be aided
in composing commands to the computer.  In the 
system described, the user is not required to learn
or remember the vocabulary of the language because 
the vocabulary is displayed before him on"menus" by
means of a computer-drive scope.  He selects the 
various vocabulary elements required by pointing with
the light pen.  By use of a small unordered set 
of rewriting rules applied as a result of light pen
selections, the user generates only syntactically
correct commands to the system.  He does not have to learn
or remember the grammar.  The program restricts 
the user severely in the particular language he can use,
but the method <B>for communicating</B> with the program 
makes these restrictions seem quite natural and unconstraining.
 The program has been used successfully 
for over ten months.

CACM February, 1965

Goodenough, J. B.

CA650217 JB March 7, 1978  10:40 PM

1307	5	1307
1307	5	1307
1307	5	1307
1978	5	1307
1307	6	1307
1589	6	1307
1813	6	1307


************************

************************
Document:  CACM-2450.html
************************


Empirical Working Set Behavior

The working set model for program behavior
has been proposed in recent years as a basis for 
the design of scheduling and paging algorithms.  Although
the words "working set" are now commonly encountered 
in the literature dealing with resource allocation, there
is a dearth of published data on program measurements, 
in the hope that workers in the field might find experimental
evidence upon which to substantiate and 
base <B>theoretical work</B>.

CACM September, 1973

Rodriguez-Rosell, J.

virtual memory, paging, working set,
software measurement, program behavior

4.3

CA730905 JB January 23, 1978  9:22 AM

2373	4	2450
2374	4	2450
2380	4	2450
2450	4	2450
2450	4	2450
2595	4	2450
2996	4	2450
3006	4	2450
3006	4	2450
3067	4	2450
3067	4	2450
2373	5	2450
2374	5	2450
2450	5	2450
2450	5	2450
2450	5	2450


************************

************************
Document:  CACM-1014.html
************************


Machine Controls for Analysis of Variance

A major problem in using the analysis of variance,
as the number of factors increases, is the 
exponential rise in the number of interactions.  Even
though the experimenter may not be <B>interested in</B> 
these interactions it is impossible to ignore them in
most experimental designs because of the problem 
of getting error terms.  It is natural therefore to look
to the computer to handle the bulk of work involved 
in computing the interactions.  A program device
to get the computer to do this is described.

CACM August, 1964

Weldon, R. J.

CA640816 JB March 9, 1978  6:37 PM

1014	4	1014
912	5	1014
1014	5	1014
1014	5	1014
1014	5	1014


************************

************************
Document:  CACM-2342.html
************************


Interference Between Communicating Parallel Processes

Various kinds of interference between communicating
parallel processes have been examined by 
Dijkstra, Knuth, and others.  Solutions have been given
for the mutual exclusion problem and associated 
subproblems, in the form of parallel programs, and informal
proofs of correctness have been given for 
these solutions.  In this paper a system of parallel
processes is regarded as a machine which proceeds 
from one state S (i.e. a collection of pertinent data
values and process configurations) to a next state 
S' <B>in a</B>ccordance with a transition rule S --> S'.  A
set of such rules yields sequences of states, which 
dictate the system's behavior.  The mutual exclusion problem
and the associated subproblems are formulated 
as questions of inclusion between sets of states, or
of the existence of certain sequences.  A mechanical 
proof procedure is shown, which will either verify (prove
the correctness of ) or discredit (prove the 
incorrectness of) an attempted solution, with respect
to any of the interference properties.  It is shown 
how to calculate transition rules from the "partial
rules" by which the individual processes operate. 
 The formation of partial rules and the calculation of
transition rules are both applicable to hardware 
processes as well as to software processes, and
symmetry between processes is not required.

CACM June, 1972

Gilbert, P.
Chandler, W. J.

concurrent programming control, cooperating processes,
formal programs, interference, mutual exclusion, 
operating systems, parallel processes

4.0 4.10 4.30 4.32 4.42 5.24 6.20

CA720603 JB January 31, 1978  8:44 AM

1781	4	2342
1828	4	2342
1854	4	2342
1877	4	2342
1960	4	2342
2150	4	2342
2150	4	2342
2150	4	2342
2228	4	2342
2228	4	2342
2256	4	2342
2256	4	2342
2317	4	2342
2317	4	2342
2319	4	2342
2377	4	2342
2342	4	2342
2342	4	2342
2342	4	2342
2376	4	2342
2376	4	2342
2379	4	2342
2424	4	2342
2482	4	2342
2618	4	2342
2618	4	2342
2618	4	2342
2632	4	2342
2704	4	2342
2723	4	2342
2738	4	2342
2740	4	2342
2741	4	2342
2867	4	2342
3184	4	2342
3184	4	2342
1198	5	2342
1338	5	2342
1749	5	2342
2342	5	2342
2342	5	2342
2342	5	2342


************************

************************
Document:  CACM-1470.html
************************


The Structure of Programming Languages

The following are identified as major components
of every programming language: (1) the elementary 
program statement, (2) <B>mechanisms for</B> linking elementary
statements together, (3) the means by which 
a program can obtain data inputs.  Several alternative
forms of each of these components are described, 
compared and evaluated.  Many examples, frequently from
list processing languages, illustrate the forms 
described.  Elementary program statements usually take
the form of commands, requirements, or implicit 
specifications.  A command is an imperative statement
that commands the action to be taken.  A requirement 
describes the effect to be achieved without saying anything
about the actions to be taken.  An implicit 
specification is similar to a requirement, but the programmer
must understand what actions will be taken 
to achieve the desired effect.  Subroutines may be entered
explicitly, by execute call, or by function 
composition.  Explicitly called subroutines generally
require special linkage conventions.  An execute 
subroutine call is syntactically indistinguishable from
a basic instruction of the programming language. 
 Function composition is a convenient alternative to
the explicit call.  The three principal ways of 
getting inputs for routines are (1) by referring to
the data itself, (2) by referring to the data by 
a "name", and (3) by referring to it implicitly by means
of variables or functions.  Names are useful 
entry points into permanent data structures, but can
be error-causing distractions in other contexts. 
The author discusses advantages, disadvantages, and factors
influencing the choice of a form of component 
for a language.   He concludes by suggesting the evolution
of programming languages toward one which 
will permit all the most convenient ways of structuring
programs, organizing systems, and referencing 
data.

CACM March, 1966

Raphael, B.

CA660302 JB March 3, 1978  2:20 PM

1470	5	1470
1470	5	1470
1470	5	1470


************************

************************
Document:  CACM-3049.html
************************


A Simply Extended and Modified Batch
Environment Graphical System (SEMBEGS)

SEMBEGS is a complete batch environment graphical
system containing components for handling 
graphical data files, for displaying the contents of
these files on a variety of graphical hardware, 
and for performing graphical batch input operations.
 SEMBEGS is easy to extend and modify to meet the 
growing needs of a large batch environment, and is even
extendable to a fully interactive system.  The 
paper presents the conceptual view of graphics leading
to the design of SEMBEGS and outlines the major 
components of the system.  The design of SEMBEGS is founded
up<B>on the</B> basic assumption that the true aim 
of computer graphics is to describe graphical entities,
rather than, as commonly held, to provide graphical 
input and output functional capabilities.  SEMBEGS
is built around a Basic Graphical Data Management 
System (BAGDAMS) which provides a common means of communicating
the descriptions of graphical entities 
 between the various components of SEMBEGS.  BAGDAMS
provides facilities for storing, retrieving, and 
manipulating the descriptions of graphical entities
provided by, and received by application programs,
graphics packages, and graphical devices. 

CACM November, 1978

Wendorf, J.

Computer graphics, data structures, graphic display,
graphic input, graphical database, device 
independent graphics

4.33 4.34 8.2

CA781102 DH January 26, 1979  1:30 PM

3030	4	3049
3031	4	3049
3049	4	3049
3049	4	3049
3049	4	3049
3049	4	3049
2956	5	3049
2957	5	3049
2958	5	3049
2960	5	3049
3049	5	3049
3049	5	3049
3049	5	3049


************************



A Simply Extended and Modified Batch
Environment Graphical System (SEMBEGS)

SEMBEGS is a complete batch environment graphical
system containing components for handling 
graphical data files, for displaying the contents of
these files on a variety of graphical hardware, 
and for performing graphical batch input operations.
 SEMBEGS is easy to extend and modify to meet the 
growing needs of a large batch environment, and is even
extendable to a fully interactive system.  The 
paper presents the conceptual view of graphics leading
to the design of SEMBEGS and outlines the major 
components of the system.  The design of SEMBEGS is founded
upon the basic assumption that the true aim 
of computer graphics is to describe graphical entities,
rather than, as commonly held, to provide graphical 
input and output functional capabilities.  SEMBEGS
is built around a Basic Graphical Data Management 
System (BAGDAMS) which provides a common means of communicating
the <B>descriptions of</B> graphical entities 
 between the various components of SEMBEGS.  BAGDAMS
provides facilities for storing, retrieving, and 
manipulating the descriptions of graphical entities
provided by, and received by application programs,
graphics packages, and graphical devices. 

CACM November, 1978

Wendorf, J.

Computer graphics, data structures, graphic display,
graphic input, graphical database, device 
independent graphics

4.33 4.34 8.2

CA781102 DH January 26, 1979  1:30 PM

3030	4	3049
3031	4	3049
3049	4	3049
3049	4	3049
3049	4	3049
3049	4	3049
2956	5	3049
2957	5	3049
2958	5	3049
2960	5	3049
3049	5	3049
3049	5	3049
3049	5	3049


************************

************************
Document:  CACM-2377.html
************************


A Hardware Architecture for Implementing Protection Rings

Protection of computations and information
is an important aspect of a computer utility.  In 
a system which uses segmentation as a memory addressing
scheme, protection can be achieved in part by 
associating concentric rings of decreasing access privilege
with a computation.  This paper describes 
hardware processor mechanisms for implementing these rings
of protection.  The mechanisms for implementing 
these rings of protection. The mechanisms allow cross-ring
<B>calls and</B> subsequent returns to occur without 
trapping to the supervisor.  Automatic hardware validation
of references across ring boundaries is also 
performed.  Thus, a call by a user procedure to a protected
subsystem (including the supervisor) is identical 
to a call to a companion user procedure.  The mechanisms
of passing and referencing arguments are the 
same in both cases as well.

CACM March, 1972

Schroeder, M. D.
Saltzer, J. H.

protection, protection rings, protection hardware,
access control, hardware access control, computer 
utility, time-sharing, shared information, segmentation, virtual memory, Multics

4.32 6.21

CA720304 JB January 31, 1978  2:58 PM

1458	4	2377
1523	4	2377
1603	4	2377
1698	4	2377
1747	4	2377
1748	4	2377
1753	4	2377
1828	4	2377
1854	4	2377
1854	4	2377
1877	4	2377
1877	4	2377
1960	4	2377
1960	4	2377
2150	4	2377
2317	4	2377
2319	4	2377
2358	4	2377
2377	4	2377
2377	4	2377
2377	4	2377
2377	4	2377
2378	4	2377
2372	4	2377
2342	4	2377
2376	4	2377
2379	4	2377
2424	4	2377
2482	4	2377
2497	4	2377
2558	4	2377
2618	4	2377
2625	4	2377
2625	4	2377
2626	4	2377
2626	4	2377
2632	4	2377
2632	4	2377
2669	4	2377
2704	4	2377
2723	4	2377
2738	4	2377
2740	4	2377
2741	4	2377
2840	4	2377
2840	4	2377
2867	4	2377
2941	4	2377
3105	4	2377
3144	4	2377
3184	4	2377
1471	5	2377
1746	5	2377
1749	5	2377
2358	5	2377
2377	5	2377
2377	5	2377
2377	5	2377
2436	5	2377
2626	5	2377
2868	5	2377
2870	5	2377
953	6	2377
1746	6	2377
2080	6	2377
2358	6	2377
2377	6	2377
2377	6	2377
2377	6	2377
2377	6	2377
2380	6	2377
2558	6	2377
2625	6	2377
2625	6	2377
2629	6	2377
2632	6	2377
2632	6	2377


************************



A Hardware Architecture for Implementing Protection Rings

Protection of computations and information
is an important aspect of a computer utility.  In 
a system which uses segmentation as a memory addressing
scheme, protection can be achieved in part by 
associating concentric rings of decreasing access privilege
with a computation.  This paper describes 
hardware processor <B>mechanisms for</B> implementing these rings
of protection.  The mechanisms for implementing 
these rings of protection. The mechanisms allow cross-ring
calls and subsequent returns to occur without 
trapping to the supervisor.  Automatic hardware validation
of references across ring boundaries is also 
performed.  Thus, a call by a user procedure to a protected
subsystem (including the supervisor) is identical 
to a call to a companion user procedure.  The mechanisms
of passing and referencing arguments are the 
same in both cases as well.

CACM March, 1972

Schroeder, M. D.
Saltzer, J. H.

protection, protection rings, protection hardware,
access control, hardware access control, computer 
utility, time-sharing, shared information, segmentation, virtual memory, Multics

4.32 6.21

CA720304 JB January 31, 1978  2:58 PM

1458	4	2377
1523	4	2377
1603	4	2377
1698	4	2377
1747	4	2377
1748	4	2377
1753	4	2377
1828	4	2377
1854	4	2377
1854	4	2377
1877	4	2377
1877	4	2377
1960	4	2377
1960	4	2377
2150	4	2377
2317	4	2377
2319	4	2377
2358	4	2377
2377	4	2377
2377	4	2377
2377	4	2377
2377	4	2377
2378	4	2377
2372	4	2377
2342	4	2377
2376	4	2377
2379	4	2377
2424	4	2377
2482	4	2377
2497	4	2377
2558	4	2377
2618	4	2377
2625	4	2377
2625	4	2377
2626	4	2377
2626	4	2377
2632	4	2377
2632	4	2377
2669	4	2377
2704	4	2377
2723	4	2377
2738	4	2377
2740	4	2377
2741	4	2377
2840	4	2377
2840	4	2377
2867	4	2377
2941	4	2377
3105	4	2377
3144	4	2377
3184	4	2377
1471	5	2377
1746	5	2377
1749	5	2377
2358	5	2377
2377	5	2377
2377	5	2377
2377	5	2377
2436	5	2377
2626	5	2377
2868	5	2377
2870	5	2377
953	6	2377
1746	6	2377
2080	6	2377
2358	6	2377
2377	6	2377
2377	6	2377
2377	6	2377
2377	6	2377
2380	6	2377
2558	6	2377
2625	6	2377
2625	6	2377
2629	6	2377
2632	6	2377
2632	6	2377


************************

************************
Document:  CACM-2949.html
************************


A Correctness Proof of a Topology Information
Main tenance Protocol for a Distributed Computer 
Network

In order for the nodes of a distributed computer
network to communicate, each node must have 
information about the network's topology.  Since nodes
and links sometimes crash, a scheme is needed 
to update this information.  One of the major constrain ts
on such a topology information scheme is that 
it may not involve a central controller.  The Topology
Information Protocol that was implemented <B>on the</B> 
MERIT Computer Network is presented and explained; this
protocol is quite general and could be implemented 
on any computer network.  It is based on Baran's "Hot
Potato Heuristic Routing Doctrine."  A correctness 
proof of this Topology Information Protocol is also presented.

CACM July, 1977

Tajibnapis, W. D.

distributed computer network, correctness proofs,
computer networks, distributed control, network 
topology, routing problem in networks, distributed operating
system, store and forward packet switching, 
store and forward message switching, traffic control

3.81 4.32

CA770703 JB December 28, 1977  11:59 AM

2949	5	2949
2949	5	2949
2949	5	2949


************************



A Correctness Proof of a Topology Information
Main tenance Protocol for a Distributed Computer 
Network

In order for the nodes of <B>a distributed</B> computer
network to communicate, each node must have 
information about the network's topology.  Since nodes
and links sometimes crash, a scheme is needed 
to update this information.  One of the major constrain ts
on such a topology information scheme is that 
it may not involve a central controller.  The Topology
Information Protocol that was implemented on the 
MERIT Computer Network is presented and explained; this
protocol is quite general and could be implemented 
on any computer network.  It is based on Baran's "Hot
Potato Heuristic Routing Doctrine."  A correctness 
proof of this Topology Information Protocol is also presented.

CACM July, 1977

Tajibnapis, W. D.

distributed computer network, correctness proofs,
computer networks, distributed control, network 
topology, routing problem in networks, distributed operating
system, store and forward packet switching, 
store and forward message switching, traffic control

3.81 4.32

CA770703 JB December 28, 1977  11:59 AM

2949	5	2949
2949	5	2949
2949	5	2949


************************

************************
Document:  CACM-3105.html
************************


A Language Extension for Expressing Constraints on Data Access

Controlled sharing of information is needed and
desirable for many applications and is supported 
in operating systems by access control mechanisms.  This
paper shows how to extend programming languages 
to provide controlled sharing.  The extension permits
expression of access constraints on shared data. 
 Access constraints can apply both to simple objects, and
to objects that are components of larger objects, 
such as bank account records <B>in a</B> bank's data base.
 The constraints are stated declaratively, and can 
be enforced by static checking similar to type checking.
 The approach can be used to extend any strongly-typed 
language, but is particularly suitable for extending
languages that support the notion of abstract data 
types. 

CACM May, 1978

Jones, A.
Liskov,B.

Programming languages, access control, data types,
abstract data types, type checking, capabilities

4.20 4.35

CA780502 DH February 26, 1979  3:19 PM

1458	4	3105
1523	4	3105
1603	4	3105
1698	4	3105
1747	4	3105
1748	4	3105
1854	4	3105
1877	4	3105
1960	4	3105
2377	4	3105
2378	4	3105
2497	4	3105
2558	4	3105
2625	4	3105
2626	4	3105
2632	4	3105
2840	4	3105
2868	4	3105
2868	4	3105
2870	4	3105
2876	4	3105
2941	4	3105
3031	4	3105
3105	4	3105
3105	4	3105
3105	4	3105
3105	4	3105
3105	4	3105
3105	4	3105
3144	4	3105
3144	4	3105
3144	4	3105
3148	4	3105
3150	4	3105
1471	5	3105
2625	5	3105
2632	5	3105
2868	5	3105
2939	5	3105
3068	5	3105
3105	5	3105
3105	5	3105
3105	5	3105


************************

************************
Document:  CACM-2932.html
************************


Complexity of Computations

The framework for research in the theory of complexity
of computations is described, emphasizing 
the in terrelation between seemingly diverse problems
and methods.  Illustrative <B>examples of</B> practical 
and theoretical significance are given.  Directions
for new research are discussed.

CACM September, 1977

Rabin, M. O.

complexity of computations, algebraic complexity,
in tractable problems, probabilistic algorithms

5.25

CA770901 JB December 28, 1977  6:54 AM

2932	5	2932
2932	5	2932
2932	5	2932


************************

************************
Document:  CACM-1908.html
************************


Time-Sharing and Batch-Processing:  An Experimental
Comparison of Their Values <B>in a</B> Problem - 
Solving Situation

An experimental comparison of problem-solving
using time-sharing and batch-processing computer 
systems conducted at MIT is described in this paper.
 This study is the first known attempt to evaluate 
two such systems for what may well be the predominant user
population within the next decade-the professionals 
who, as nonprogrammers, are using the computer as an
aid in decision-making and problem-solving rather 
than as a programming end in itself.  Statistically
and logically significant results indicate equal 
cost for usage of the two computer systems; however,
a much higher level of performance is attained by 
time-sharing users.  There are indications that significantly
lower costs would have resulted if the 
time-sharing users had stopped work when they reached
a performance level equal to that of the batch 
users.  The users' speed of problem-solving and their
attitudes made time-sharing the more favorable 
system.

CACM May, 1969

Gold, M. M.

time-sharing vs batch-processing, user performance,
man/machine communications, cost effectiveness, 
on-line vs off-line performance, decision-making performance,
user/programmer behavior, programming experimental 
empirical studies, problem-solving, research in man/machine
communications, man/machine symbiosis

2.11 2.40 3.36 3.51 3.80

CA690501 JB February 17, 1978  4:10 PM

1792	4	1908
1908	4	1908
1908	4	1908
1550	5	1908
1605	5	1908
1908	5	1908
1908	5	1908
1908	5	1908
2705	5	1908
2984	5	1908
1908	6	1908
1908	6	1908
3185	6	1908


************************

************************
Document:  CACM-2849.html
************************


Ethernet: Distributed Packet Switching for Local Computer Networks

Ethernet is a branching broadcast communication
system for carrying digital data packets among 
locally distributed computing stations. The packet
transport mechanism provided by Ethernet has been 
used to build systems which can be viewed as either local
computer networks or loosely coupled multiprocessors. 
 An Ethernet's shared communication facility, its Ether,
is a passive broadcast medium with no central 
control.  Coordination of access to the Ether for packet
broadcasts is distributed among the contending 
transmitting stations using controlled statistical arbitration.
 Switching of packets to their destinations 
<B>on the</B> Ether is distributed among the receiving stations
using packet address recognition.  Design principles 
and implementation are described, based on experience
with an operating Ethernet of 100 nodes along a 
kilometer of coaxial cable.  A model for estimating performance
under heavy loads and a packet protocol 
for error controlled communication are included for completeness.

CACM July, 1976

Metcalfe, R. M.
Boggs, D. R.

computer networks, packet switching, multiprocessing,
distributed control, distributed computing, 
broadcast communication, statistical arbitration

3.81 4.32 6.35

CA760704 JB January 4, 1978  12:49 PM

2849	4	2849
2371	5	2849
2849	5	2849
2849	5	2849
2849	5	2849
3032	5	2849
3119	5	2849
2245	6	2849
2798	6	2849
2849	6	2849
2849	6	2849
2859	6	2849


************************

************************
Document:  CACM-1650.html
************************


A Unifying Computational Method for the
Analysis of Complete Factorial Experiments

A computational method which may be used for
the calculation of sums of squares in the analysis 
of variance <B>of complete</B> factorial experiments and in
the computation of main effect or interaction means 
is described.  The method is elucidated as unifying since
one method can be used for a variety of purposes 
each previously requiring different methods.  The programming
advantages of such a method are obvious. 
 The following variants are discussed: (1) the standard
analysis of variance; (2) analyses omitting certain 
levels of one or more factors; (3) separate analyses
for some levels of a factor or for combinations 
of levels of more than one factor.  These are performed
simultaneously; (4) the calculation of main effect 
or interaction means.  The mean expects the data in standard
order and it leaves the data in that order 
so that many analyses of the same data can be performed
without rearrangement.  The total sum of squares, 
excluding a replication sum of squares, is partitioned
into all polynomial partitions and their interactions 
each with one degree of freedom.  This is so even
if factors have unequally spaced factor levels.

CACM January, 1967

Cooper, B. E.

CA670105 JB February 28, 1978  4:49 PM

1650	5	1650
1650	5	1650
1650	5	1650


************************

************************
Document:  CACM-1530.html
************************


The ML/I Macro Processor

A general purpose macro processor called ML/I
is described.  ML/I has been implemented <B>on the</B> 
PDP-7 and I. Atlas 2 computers and is intended as a
tool to allow users to extend any existing programming 
language by incorporating new statements and other
syntactic forms of their own choosing and in their 
own notation.  This allows a complete user-oriented
language to be built up with relative ease.

CACM October, 1967

Brown, P. J.

CA671003 JB February 27, 1978  2:38 PM

1530	4	1530
1530	4	1530
1531	4	1530
1565	4	1530
1703	4	1530
1781	4	1530
1852	4	1530
1945	4	1530
2034	4	1530
2036	4	1530
1455	5	1530
1530	5	1530
1530	5	1530
1530	5	1530
1565	5	1530


************************

************************
Document:  CACM-0724.html
************************


A Profile of the Programmer

Synopsis: 549 members of the ACM participated
in a study concerned primarily with the attitudes 
of programmers toward their careers and jobs.  A very
high percentage of programmers have apparently 
entered their careers by accident; it has proven a happy
choice for most and they expect to remain in 
the field during the next five years.  Their principal
job satisfactions relate to the nature of their 
work, and mostfind their jobs offer high level of professional
interest and good working conditions. 
 Salary and advancement prospects, however,are not as
satisfactory.  More than half report a positive 
attitude toward programmers and programming <B>on the</B> part
of their organizations.  Turnover among themselves 
is attributed primarily to poor management-salary is
seen as the principal motivating factor in turnover 
among other programmers.  Nature of the work offered
and salary are principal determinants in accepting 
a new job.  Programmers are less mobile than expected.
 Programmers tend to see their colleagues in a 
favorable light, on the whole.  Personalities seem to
vary with function, systems programmers differing 
from applications programmers.  Four principal problems
for programming in the immediate future are listed 
by participants: languages, personnel, various specific
applications and techniques, and building programming 
as a profession.

CACM October, 1963

CA631001 JB March 13, 1978  6:48 PM

724	5	724
724	5	724
724	5	724


************************



A Profile of the Programmer

Synopsis: 549 members of the ACM participated
<B>in a</B> study concerned primarily with the attitudes 
of programmers toward their careers and jobs.  A very
high percentage of programmers have apparently 
entered their careers by accident; it has proven a happy
choice for most and they expect to remain in 
the field during the next five years.  Their principal
job satisfactions relate to the nature of their 
work, and mostfind their jobs offer high level of professional
interest and good working conditions. 
 Salary and advancement prospects, however,are not as
satisfactory.  More than half report a positive 
attitude toward programmers and programming on the part
of their organizations.  Turnover among themselves 
is attributed primarily to poor management-salary is
seen as the principal motivating factor in turnover 
among other programmers.  Nature of the work offered
and salary are principal determinants in accepting 
a new job.  Programmers are less mobile than expected.
 Programmers tend to see their colleagues in a 
favorable light, on the whole.  Personalities seem to
vary with function, systems programmers differing 
from applications programmers.  Four principal problems
for programming in the immediate future are listed 
by participants: languages, personnel, various specific
applications and techniques, and building programming 
as a profession.

CACM October, 1963

CA631001 JB March 13, 1978  6:48 PM

724	5	724
724	5	724
724	5	724


************************

************************
Document:  CACM-0616.html
************************


An Information Algebra - Phase I Report-Language
Structure Group of the CODASYL Development Committee

This report represents the results of the
first phase of the work of the Language Structure 
Group.  The goal of this work is to arrive at a proper
structure for a machine-independent problem-defining 
language, at the systems level of data processing.  The
report is based, for the most part, on a mathematical 
model called "An Information Algebra" developed primarily
by R. Bosak.  It is hoped that this report 
will be read (a) with avid interest by programming language
designers and implementors, and all those 
<B>interested in</B> developing a theoretical approach to data
processing; (b) with interest and understanding 
by professional programmers and systems analysts; and (c)
with appreciation by the businessman-analyst-manager. 
 The authors have not attempted an exhaustive discourse
in this report.  Rather, they have tried to present 
a philosophy to the professional people who are vitally
concerned with providing a working language for 
the systems analyst's use.  They trust that the ideas
in this report will stimulate others to think along 
similar lines.  Questions and comments will be welcomed,
and can be addressed to any of the members of 
the Language Structure Group:  Robert Bosak, System
Development Corporation;  Richard F. Clippinger, 
Honeywell EDP Division;  Carey Dobbs, Remington Rand
Univac Division;  Roy Goldfinger (Chairman), IBM 
Corporation;  Renee B. Jasper, Navy Management Office;
 William Keating, National Cash Register;  George 
Kendrick, General Electric Company;  Jean E. Sammet, IBM Corporation.

CACM April, 1962

CA620401 JB March 20, 1978  2:40 PM

1135	5	616
1136	5	616
2710	5	616
2765	5	616
2888	5	616
2906	5	616
493	5	616
616	5	616
616	5	616
616	5	616
729	5	616
1515	6	616
288	6	616
1936	6	616
1976	6	616
2046	6	616
2046	6	616
2046	6	616
2451	6	616
2452	6	616
2715	6	616
493	6	616
616	6	616
616	6	616
616	6	616
616	6	616
616	6	616
616	6	616
616	6	616
616	6	616
657	6	616


************************

************************
Document:  CACM-2457.html
************************


Inductive Methodsfor Proving Properties of Programs

There are two main purposes in this paper:
first, clarification and extension of known results 
about computation of recursive programs, with emphasis
on the difference between the theoretical and 
practical approaches; second, presentation and examination
of various known methods for proving properties 
of recursive programs.  Discussed in detail are two
powerful inductive methods computational induction 
and structural induction, including <B>examples of</B> their applications.

CACM August, 1973

Manna, Z.
Nes, S.
Vuillemin, J.

recursive programs, least fixed point, computational
induction, structural induction

4.2 5.23 5.24

CA730817 JB January 23, 1978  10:24 AM

2326	4	2457
2411	4	2457
2457	4	2457
2457	4	2457
2842	4	2457
2903	4	2457
2192	5	2457
2326	5	2457
2457	5	2457
2457	5	2457
2457	5	2457
2981	5	2457
3030	5	2457
3077	5	2457
3104	5	2457
210	6	2457
1834	6	2457
2060	6	2457
2247	6	2457
2356	6	2457
2457	6	2457
2457	6	2457
2457	6	2457
2457	6	2457
2651	6	2457
2683	6	2457
2958	6	2457
2972	6	2457


************************



Inductive Methodsfor Proving Properties of Programs

There are two main purposes in this paper:
first, clarification and extension of known results 
about computation of recursive programs, with emphasis
<B>on the</B> difference between the theoretical and 
practical approaches; second, presentation and examination
of various known methods for proving properties 
of recursive programs.  Discussed in detail are two
powerful inductive methods computational induction 
and structural induction, including examples of their applications.

CACM August, 1973

Manna, Z.
Nes, S.
Vuillemin, J.

recursive programs, least fixed point, computational
induction, structural induction

4.2 5.23 5.24

CA730817 JB January 23, 1978  10:24 AM

2326	4	2457
2411	4	2457
2457	4	2457
2457	4	2457
2842	4	2457
2903	4	2457
2192	5	2457
2326	5	2457
2457	5	2457
2457	5	2457
2457	5	2457
2981	5	2457
3030	5	2457
3077	5	2457
3104	5	2457
210	6	2457
1834	6	2457
2060	6	2457
2247	6	2457
2356	6	2457
2457	6	2457
2457	6	2457
2457	6	2457
2457	6	2457
2651	6	2457
2683	6	2457
2958	6	2457
2972	6	2457


************************

************************
Document:  CACM-1590.html
************************


Pitch Period Determination of Speech Sounds

A computer procedure which determines pitch
periods by the recognition of the peak structure 
of the speech waveform is described.  Speech sounds were
sampled by a microphone and an analog-to-digital 
converter attached to an interconnected IBM 7090-PDP-1
system.  These utterances were recorded at the 
normal noise level of the computer room but were not
band-compressed or phase-distorted <B>in a</B>ny manner. 
 A sequence of operations defined on the speech wave selects
a list of points along the waveform as candidates 
for pitch markers.  These markers are validated by
an error detection and correction procedurebout 
95 percent of the pitch periods were recognized correctly
within 1 to 2 times real-time on the IBM 7090.

CACM June,1967

Reddy, D. R.

CA670602 JB February 28, 1978  9:42 AM

1590	5	1590
1590	5	1590
1590	5	1590


************************



Pitch Period Determination of Speech Sounds

A computer procedure which determines pitch
periods by the recognition of the peak structure 
of the speech waveform is described.  Speech sounds were
sampled by a microphone and an analog-to-digital 
converter attached to an interconnected IBM 7090-PDP-1
system.  These utterances were recorded at the 
normal noise level of the computer room but were not
band-compressed or phase-distorted in any manner. 
 A sequence of operations defined <B>on the</B> speech wave selects
a list of points along the waveform as candidates 
for pitch markers.  These markers are validated by
an error detection and correction procedurebout 
95 percent of the pitch periods were recognized correctly
within 1 to 2 times real-time on the IBM 7090.

CACM June,1967

Reddy, D. R.

CA670602 JB February 28, 1978  9:42 AM

1590	5	1590
1590	5	1590
1590	5	1590


************************

************************
Document:  CACM-2536.html
************************


Telecommunications Using a Front-End Minicomputer

The use of a front-end minicomputer to provide
varied remote terminal access to a large scale 
computer is considered.  The problems of embedding
telecommunications I/O within an operating system 
are discussed, and it is shown how the decentralization
of intelligence acquired by front-end processing 
vastly simplifies the problem.  A specific implementation is
discussed with emphasis <B>on the</B> main processor-minicomputer 
link, the hardware-software implementation, the effect
of the main processor operating system, and an 
assessment of the advantages over a hard wired line controller.

CACM March, 1973

Feinroth, Y.
Franceschini, E.
Goldstein, M.

telecommunications, minicomputer, front-end
processor, remote job entry, remote terminals

3.81 4.32 4.41

CA730303 JB January 24, 1978  11:23 AM

1657	4	2536
2080	4	2536
2357	4	2536
2536	4	2536
1523	5	2536
2536	5	2536
2536	5	2536
2536	5	2536
2919	5	2536
2536	6	2536
2593	6	2536
2629	6	2536


************************



Telecommunications Using a Front-End Minicomputer

The use of a front-end minicomputer to provide
varied remote terminal access to a large scale 
computer is considered.  The problems of embedding
telecommunications I/O with<B>in a</B>n operating system 
are discussed, and it is shown how the decentralization
of intelligence acquired by front-end processing 
vastly simplifies the problem.  A specific implementation is
discussed with emphasis on the main processor-minicomputer 
link, the hardware-software implementation, the effect
of the main processor operating system, and an 
assessment of the advantages over a hard wired line controller.

CACM March, 1973

Feinroth, Y.
Franceschini, E.
Goldstein, M.

telecommunications, minicomputer, front-end
processor, remote job entry, remote terminals

3.81 4.32 4.41

CA730303 JB January 24, 1978  11:23 AM

1657	4	2536
2080	4	2536
2357	4	2536
2536	4	2536
1523	5	2536
2536	5	2536
2536	5	2536
2536	5	2536
2919	5	2536
2536	6	2536
2593	6	2536
2629	6	2536


************************

************************
Document:  CACM-1710.html
************************


ASP-A Ring Implemented Associative Structure Package

ASP is a general purpose Associative Data
Structure Package in which an arbitrary number of 
data items and an arbitrary number of the relationships
between these data items may be represented. 
 A special picture language is described which has proved
very useful for drawing ASP structures on paper. 
 ASP structures are built and manipulated by means
of a series of macro calls, which are outlined in 
the Appendix.  Emphasis is <B>on the</B> philosophy of the system
rather than a particular implementation, though 
sufficient information is included to enable the
reader to produce his own implementation of ASP.

CACM August, 1968

Lang, C. A.
Gray, J. C.

associative, data structure, ring structure lists,
list structure, set languages, modeling, graphics

4.20 4.22

CA680804 JB February 22, 1978  11:02 AM

1710	5	1710
1710	5	1710
1710	5	1710
1853	5	1710
2003	5	1710
1710	6	1710
1710	6	1710
1767	6	1710
2105	6	1710


************************

************************
Document:  CACM-2439.html
************************


Multiple Terminals Under User Program
Control in a Time-Sharing Environment

User-written programs <B>on the</B> Dartmouth Time-Sharing
system can communicate with many remote 
terminals simultaneously and can control the interactions
between these terminals.  Such programs can 
be written using standard input and output instructions
in any language available on the system.  This 
paper describes how this multiple-terminal facility
was implemented without requiring any changes in 
the system executive or in any of the system's compilers or interpreters.

CACM October, 1973

McGeachie, J. S.

DTSS, multiple terminals, remote terminals, remote
consoles, time-sharing, on-line interaction, 
on-line games

3.81 4.32

CA731001 JB January 23, 1978  8:33 AM

2439	5	2439
2439	5	2439
2439	5	2439


************************



Multiple Terminals Under User Program
Control <B>in a</B> Time-Sharing Environment

User-written programs on the Dartmouth Time-Sharing
system can communicate with many remote 
terminals simultaneously and can control the interactions
between these terminals.  Such programs can 
be written using standard input and output instructions
in any language available on the system.  This 
paper describes how this multiple-terminal facility
was implemented without requiring any changes in 
the system executive or in any of the system's compilers or interpreters.

CACM October, 1973

McGeachie, J. S.

DTSS, multiple terminals, remote terminals, remote
consoles, time-sharing, on-line interaction, 
on-line games

3.81 4.32

CA731001 JB January 23, 1978  8:33 AM

2439	5	2439
2439	5	2439
2439	5	2439


************************

