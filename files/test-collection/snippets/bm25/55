Snippets for the query:  Articles relation the algebraic theory of semigroups and monoids to the study of automata and regular languages.
************************
Total Hits:  41
************************

************************
Document:  CACM-2167.html
************************


Algebraic Simplification: A Guide for the Perplexed

Algebraic simplification is examined first from
the point of view of a user who needs to comprehend 
a large expression, and second from the point of view
of a designer who wants to construct a useful and 
efficient system.  First we describe various techniques
akin to substitution.  These techniques can be 
used to decrease thesize of an expression and make it
more intelligible to a user.  Then we delineate 
the spectrum of approaches <B>to the</B> design of automatic simplification
capabilities in an algebraic manipulation 
system.  Systems are divided into five types.  Each type
provides different facilities for the manipulation 
and simplification of expressions. Finally we discuss
some of the theoretical results related to algebraic 
simplification.  We describe several positive results
about the existence of powerful simplification 
algorithms and the number-theoretic conjectures on which
they rely.  Results about the nonexistence of 
algorithms for certain classes of expressions are included.

CACM August, 1971

Moses, J.

algebraic manipulation, algebraic simplification,
canonical simplification

3.1 3.2 3.6 4.9 5.2 5.9

CA710805 JB February 2, 1978  3:42 PM

1396	4	2167
1396	4	2167
1946	4	2167
2167	4	2167
2167	4	2167
2167	4	2167
2167	4	2167
2857	4	2167
2956	4	2167
1379	5	2167
1393	5	2167
1392	5	2167
2167	5	2167
2167	5	2167
2167	5	2167
2164	5	2167
2169	5	2167
2170	5	2167
2323	5	2167
2719	5	2167
1626	6	2167
210	6	2167
2151	6	2167
2164	6	2167
2165	6	2167
2167	6	2167
2167	6	2167
2167	6	2167
2167	6	2167
2166	6	2167
2170	6	2167
2210	6	2167
2645	6	2167
2657	6	2167


************************

************************
Document:  CACM-1334.html
************************


Mechanization of Tedious Algebra: The
Newcomb Operators of Planetary Theory

A computer program has been written to generate
tables of formulas for the Newcomb operators 
of planetary theory.  The Newcomb operators are expressed
as polynomials in two variables, one of which 
stands for a simple differential operator, and the other
for an arbitrary integer.  The polynomials are 
generated by a recurrence scheme.  The program is coded in
FORTRAN, using simple array manipulation techniques 
to perform <B>the algebraic</B> operations.  Formulas for over
100 Newcomb operators have been produced by the 
program and typeset photographically on an S-560 Photon system.

CACM January, 1965

Gerard, J. M.
Izsak, I. G.
Barnett, M. P.

CA650103 JB March 8, 1978  2:59 PM

1334	4	1334
1396	4	1334
1444	4	1334
964	5	1334
1334	5	1334
1334	5	1334
1334	5	1334
1396	5	1334
964	6	1334
1028	6	1334
1029	6	1334
1083	6	1334
1132	6	1334
1214	6	1334
1278	6	1334
1334	6	1334
1365	6	1334
1386	6	1334
1387	6	1334
1388	6	1334
1392	6	1334
1393	6	1334
1394	6	1334
1395	6	1334
1396	6	1334
1397	6	1334
1496	6	1334
284	6	1334
407	6	1334
3199	6	1334
3200	6	1334
3201	6	1334
3202	6	1334
3203	6	1334
3204	6	1334
561	6	1334
730	6	1334


************************

************************
Document:  CACM-1154.html
************************


Multi-Tape and Infinite-State Automata -- A Survey

A survey of machines which are more powerful
than finite <B>automata and</B> less powerful than general 
Turing machines is presented.  It is felt that the machines
in this category are as closely related to 
digital computers as either the finite automata or the
unrestricted Turing machines.  Intermediate machines 
can be created by adjoining on infinite-state memory
to a finite-state machine and then performing any 
or all of the following: (1) restrict the manner in
which the unbounded portion of the memory can be 
accessed, (2) bound the number of steps allowed for a
computation by some increasing recursive function 
of the length of the input, (3) restrict the total amount
of memory available in the same manner.  Examples 
from all three classes and their properties are discussed.

CACM December, 1965

Fischer, P. C.

CA651215 JB March 6, 1978  3:24 PM

1154	5	1154
1154	5	1154
1154	5	1154


************************

************************
Document:  CACM-1961.html
************************


An Efficient Search Algorithm to Find the Elementary Circuits of a Graph

A theoretically most efficient search algorithm is presented
which uses an exhaustive search to find all of the elementary
circuits of a graph.  The algorithm can be easily modified to find all
of the elementary circuits with a particular attribute such as
length.  A rigorous proof of the algorithm is given as well as an example
of its application.  Empirical bounds are presented relating
the speed of the algorithm <B>to the</B> number of vertices and the number
of arcs.  The speed is also related to the number of circuits
in the graph to give a relation between speed and complexity.
Extensions to undirected and s-graphs are discussed.

CACM December, 1970

Tiernan, J. C.

algorithm, graph theory, circuit search
algorithm, path search algorithm, searching

3.74 5.32

CA701202 JB February 9, 1978 4:12 PM

1847	4	1961
1961	4	1961
1961	4	1961
1961	4	1961
2052	4	1961
2177	4	1961
2763	4	1961
1369	5	1961
1504	5	1961
1847	5	1961
1961	5	1961
1961	5	1961
1961	5	1961
2430	5	1961
1961	6	1961


************************

************************
Document:  CACM-2931.html
************************


Logic and Programming Languages

Logic has been long in terested in whether answers
to certain questions are computable in principle, 
since the outcome puts bounds on the possibilities of
formalization.  More recently, precise comparisons 
in the efficiency of decision methods have become available
through the developments in complexity theory. 
 These, however, are applications to logic, and a big question
is whether methods of logic have significance 
in the other direction for the more applied parts of
computability theory.  Programming languages offer 
an obvious opportunity as their syntactic formalization
is well advanced; however, the semantical theory 
can hardly be said to be complete.  Though we have
many examples, we have still to give wide-ranging 
mathematical answers to these queries:  What is a machine?
 What is a computable process?  How (or how 
well) does a machine simulate a process?  Programs naturally
enter in giving descriptions of processes. 
 The definition of the precise meaning of a program
then requires us to explain what are the objects 
of computation (in a way, the statics of the problem)
and how they are to be transformed (the dynamics). 
 So far the theories <B>of automata</B> and of nets, though
most in teresting for dynamics, have formalized only 
a portion of the field, and there has been perhaps too
much concentration on the finite-state and algebraic 
aspects.  It would seem that the understanding of higher-level
program features involves us with infinite 
objects and forces us to pass through several levels
of explanation to go from the conceptual ideas to 
the final simulation on a real machine.  These levels
can be made mathematically exact if we can find 
the right abstractions to represent the necessary structures.
 The experience of many independent workers 
with the method of data types as lattices (or partial
orderings) under an information content ordering, 
and with their continuous mappings, has demonstrated the
flexibility of this approach in providing definitions 
and proofs, which are clean and without undue dependence
on implementations.  Nevertheless much remains 
to be done in showing how abstract conceptualizations
can (or cannot) be actualized before we can say 
we have a unified theory.

CACM September, 1977

Scott, D. S.

logic, programming languages, automata, denotational
semantics, a-calculus models, computability, 
partial functions, approximation, function spaces

1.2 4.20 5.21 5.24 5.27

CA770902 JB December 28, 1977  6:49 AM

2931	5	2931
2931	5	2931
2931	5	2931


************************



Logic and Programming Languages

Logic has been long in terested in whether answers
to certain questions are computable in principle, 
since the outcome puts bounds on the possibilities of
formalization.  More recently, precise comparisons 
in the efficiency of decision methods have become available
through the developments in complexity theory. 
 These, however, are applications to logic, and a big question
is whether methods of logic have significance 
in the other direction for the more applied parts of
computability theory.  Programming languages offer 
an obvious opportunity as their syntactic formalization
is well advanced; however, the semantical theory 
can hardly be said to be complete.  Though we have
many examples, we have still to give wide-ranging 
mathematical answers to these queries:  What is a machine?
 What is a computable process?  How (or how 
well) does a machine simulate a process?  Programs naturally
enter in giving descriptions of processes. 
 The definition of the precise meaning of a program
then requires us to explain what are the objects 
of computation (in a way, the statics of the problem)
and how they are to be transformed (the dynamics). 
 So far the theories of <B>automata and</B> of nets, though
most in teresting for dynamics, have formalized only 
a portion of the field, and there has been perhaps too
much concentration on the finite-state and algebraic 
aspects.  It would seem that the understanding of higher-level
program features involves us with infinite 
objects and forces us to pass through several levels
of explanation to go from the conceptual ideas to 
the final simulation on a real machine.  These levels
can be made mathematically exact if we can find 
the right abstractions to represent the necessary structures.
 The experience of many independent workers 
with the method of data types as lattices (or partial
orderings) under an information content ordering, 
and with their continuous mappings, has demonstrated the
flexibility of this approach in providing definitions 
and proofs, which are clean and without undue dependence
on implementations.  Nevertheless much remains 
to be done in showing how abstract conceptualizations
can (or cannot) be actualized before we can say 
we have a unified theory.

CACM September, 1977

Scott, D. S.

logic, programming languages, automata, denotational
semantics, a-calculus models, computability, 
partial functions, approximation, function spaces

1.2 4.20 5.21 5.24 5.27

CA770902 JB December 28, 1977  6:49 AM

2931	5	2931
2931	5	2931
2931	5	2931


************************



Logic and Programming Languages

Logic has been long in terested in whether answers
to certain questions are computable in principle, 
since the outcome puts bounds on the possibilities of
formalization.  More recently, precise comparisons 
in the efficiency of decision methods have become available
through the developments in complexity theory. 
 These, however, are applications to logic, and a big question
is whether methods of logic have significance 
in the other direction for the more applied parts of
computability theory.  Programming languages offer 
an obvious opportunity as their syntactic formalization
is well advanced; however, the semantical theory 
can hardly be said to be complete.  Though we have
many examples, we have still to give wide-ranging 
mathematical answers <B>to the</B>se queries:  What is a machine?
 What is a computable process?  How (or how 
well) does a machine simulate a process?  Programs naturally
enter in giving descriptions of processes. 
 The definition of the precise meaning of a program
then requires us to explain what are the objects 
of computation (in a way, the statics of the problem)
and how they are to be transformed (the dynamics). 
 So far the theories of automata and of nets, though
most in teresting for dynamics, have formalized only 
a portion of the field, and there has been perhaps too
much concentration on the finite-state and algebraic 
aspects.  It would seem that the understanding of higher-level
program features involves us with infinite 
objects and forces us to pass through several levels
of explanation to go from the conceptual ideas to 
the final simulation on a real machine.  These levels
can be made mathematically exact if we can find 
the right abstractions to represent the necessary structures.
 The experience of many independent workers 
with the method of data types as lattices (or partial
orderings) under an information content ordering, 
and with their continuous mappings, has demonstrated the
flexibility of this approach in providing definitions 
and proofs, which are clean and without undue dependence
on implementations.  Nevertheless much remains 
to be done in showing how abstract conceptualizations
can (or cannot) be actualized before we can say 
we have a unified theory.

CACM September, 1977

Scott, D. S.

logic, programming languages, automata, denotational
semantics, a-calculus models, computability, 
partial functions, approximation, function spaces

1.2 4.20 5.21 5.24 5.27

CA770902 JB December 28, 1977  6:49 AM

2931	5	2931
2931	5	2931
2931	5	2931


************************

************************
Document:  CACM-1253.html
************************


QUIKSCRIPT-A SIMSCRIPT- Like Language for the G-20

QUIKSCRIPT is a simulation language based on
SIMSCRIPT and programmed entirely in an algebraic 
language, 20-GATE.  The QUIKSCRIPT language, its internal
implementation, and major differences between 
QUIKSCRIPT and SIMSCRIPT are presented.  This paper is
not a programming guide <B>to the</B> language, but rather 
an attempt to present its flavor.  A brief description of
SIMSCRIPT is included, as is a sufficient description 
of 20-GATE to render this material understandable
to the reader familiar with algebraic languages.

CACM June, 1965

Tonge, F. M.
Keller, P.
Newell, A.

CA650602 JB March 7, 1978  12:45 PM

1253	5	1253
1253	5	1253
1253	5	1253


************************

************************
Document:  CACM-2061.html
************************


An Algorithm for the Construction Of Bounded-Context Parsers

An algorithm is described which accepts an arbitrary context-free
grammar and constructs a bounded-context parser for
it whenever such a parser exists.  In the first part of the paper
the definition of a context-free grammar and the working of a
bounded-context parser are recalled.  The notion of reduction class for
a context-free grammar is then introduced and its connection with
the structure of a bounded-context parser is indicated.  Next,
pushdown automata which generate the different reduction classes
of a context-free grammar are defined.  Finally, the algorithm is described;
it essentially carries out an exhaustive <B>study of</B> all possible
runs of the pushdown automata generating the reduction classes.
In the second part, the utility of the algorithm is discuss
ed in the light of the experience gained from its use in compiler design.
The algorithm is claimed to be particularly useful in the
simultaneous design of a language and a compiler for it.

CACM May, 1970

Loeckx, J.

bounded-context parsing, bounded-context syntactic analysis, parser 
construction, syntactical analyzer construction, generators, compiler 
compilers, compiler writing systems, translator writing systems metacompilers,
context-free grammars, formal languages, pushdown automata

4.12 5.22 5.23

CA700505 JB February 13, 1978  1:58 PM

1379	4	2061
1491	4	2061
1496	4	2061
1542	4	2061
1683	4	2061
1683	4	2061
1693	4	2061
1693	4	2061
1768	4	2061
1781	4	2061
1781	4	2061
1781	4	2061
1787	4	2061
1787	4	2061
1836	4	2061
1836	4	2061
1945	4	2061
1945	4	2061
1945	4	2061
2015	4	2061
2060	4	2061
2060	4	2061
2061	4	2061
2061	4	2061
2061	4	2061
2061	4	2061
2061	4	2061
2061	4	2061
2082	4	2061
2091	4	2061
2091	4	2061
2152	4	2061
2179	4	2061
2179	4	2061
2179	4	2061
2340	4	2061
2356	4	2061
2546	4	2061
2546	4	2061
2603	4	2061
2698	4	2061
2698	4	2061
2708	4	2061
2708	4	2061
2824	4	2061
2982	4	2061
2986	4	2061
3045	4	2061
3045	4	2061
3093	4	2061
1140	5	2061
1141	5	2061
1477	5	2061
1491	5	2061
1825	5	2061
2061	5	2061
2061	5	2061
2061	5	2061
773	5	2061


************************

************************
Document:  CACM-2803.html
************************


Pseudoinverses and Conjugate Gradients

This paper is devoted to the <B>study of</B> connections
between pseudoinverses of matrices and conjugate 
gradients and conjugate direction routines.

CACM January, 1975

Hestenes, M. R.

pseudoinverse, conjugate gradients, hermitian matrix, minimization

5.14

CA750108 JB January 12, 1978  10:08 AM

2803	5	2803
2803	5	2803
2803	5	2803


************************



Pseudoinverses and Conjugate Gradients

This paper is devoted <B>to the</B> study of connections
between pseudoinverses of matrices and conjugate 
gradients and conjugate direction routines.

CACM January, 1975

Hestenes, M. R.

pseudoinverse, conjugate gradients, hermitian matrix, minimization

5.14

CA750108 JB January 12, 1978  10:08 AM

2803	5	2803
2803	5	2803
2803	5	2803


************************



Pseudoinverses and Conjugate Gradients

This paper is devoted to <B>the study</B> of connections
between pseudoinverses of matrices and conjugate 
gradients and conjugate direction routines.

CACM January, 1975

Hestenes, M. R.

pseudoinverse, conjugate gradients, hermitian matrix, minimization

5.14

CA750108 JB January 12, 1978  10:08 AM

2803	5	2803
2803	5	2803
2803	5	2803


************************

************************
Document:  CACM-2921.html
************************


Regular Right Part Grammars and Their Parsers

This paper in troduces an alternative to context-free
grammars called regular right part (RRP) 
grammars, which resemble PASCAL syntax diagrams.  Formally,
RRP grammars have production right parts, 
which are nondeterministic finite state machines (FSMs),
and, as a special case, regular expressions, 
since these can be converted to FSMs.  RRP grammars
describe the syntax of programming languages more 
concisely and more understandably than is possible with
CF grammars.  Also in troduced is a class of parsers, 
RRP LR(m, k) parsers, which includes the CF LR(k) parsers
and provides the same advantages.  Informally, 
an RRP LR(m, k) parser can determine the right end of
each handle by considering at most k symbols to 
the right of the handle and the left end, after the
right end has been found, by considering at most 
m symbols <B>to the</B> left of the handle.  A mechanism for
determining the left end is required because there 
is no bound on the length of the handle.

CACM October, 1977

LaLonde, W. R.

finite state machines (automata), regular expressions,
syntax diagrams,LR(k) grammars, parser construction, 
parsing, programming languages, language generation,
formal definition, compilers, translators, scanners

4.2 5.21 5.23

CA771005 JB December 27, 1977  11:01 AM

1989	4	2921
2060	4	2921
2179	4	2921
2581	4	2921
2698	4	2921
2739	4	2921
2795	4	2921
2921	4	2921
2921	4	2921
3087	4	2921
3154	4	2921
1989	5	2921
2110	5	2921
2921	5	2921
2921	5	2921
2921	5	2921


************************

************************
Document:  CACM-2470.html
************************


Fen-An Axiomatic Basis for Program Semantics

A formal system is presented which abstracts
the notions of data item, function, and relation. 
 It is argued that the system is more suitable than set
theory (or its derivatives) for the concise and 
accurate description of program semantics.  It is shown
how the system can be used to build composite 
data types out of simper ones with the operations of rowing,
structuring, and uniting.  It is also demonstrated 
that completely new primitive types can be introduced
into languages through the mechanism of singleton 
data types.  Both deterministic and nondeterministic
functions are shown to be definable in the system. 
 It is described how the local environment can be modeled
as a data item and how imperative statements 
can be considered functions on the environment.  The
nature of recursive functions is briefly discussed, 
and a technique is presented by which they can be introduced
in<B>to the</B> system.  The technique is contrasted 
with the use of the paradoxical combinator, Y.  The
questions of local and global environments and of 
various modes of function calling and parameter passing
are touched upon. The theory is applied to the 
proof of several elementary theorems concerning the semantics
of the assignment, conditional, and iterative 
statements.  An appendix is included which presents in
detail the formal system governing webs and fen, 
the abstractions used informally in the body of the paper.

CACM August, 1973

MacLennan, B. J.

semantics, formal systems, lambda-calculus, extensible
languages, data types, modes, axioms, correctness, 
formal language definition, formal description, data structures,
description languages, models of computation

4.22 5.21 5.24 5.26

CA730804 JB January 23, 1978  11:01 AM

1469	4	2470
1486	4	2470
1491	4	2470
1781	4	2470
2021	4	2470
2060	4	2470
2178	4	2470
2222	4	2470
2227	4	2470
2294	4	2470
2315	4	2470
2326	4	2470
2326	4	2470
2470	4	2470
2470	4	2470
2470	4	2470
2470	4	2470
2684	4	2470
2732	4	2470
2865	4	2470
2896	4	2470
2943	4	2470
3014	4	2470
3044	4	2470
3068	4	2470
3077	4	2470
3124	4	2470
3143	4	2470
1303	5	2470
1469	5	2470
1834	5	2470
2264	5	2470
2470	5	2470
2470	5	2470
2470	5	2470


************************

************************
Document:  CACM-1934.html
************************


On Arithmetic Expressions and Trees

A description is given of how a tree representing the
evaluation of an arithmetic expression 
can be drawn in such a way that the number of accumulators
needed for the computation can be represented 
in a straightforward manner.  This representation reduces
the choice of the best order of computation 
to a specific problem under the <B>theory of</B> graphs.
 An algorithm to solve this problem is presented.

CACM February, 1969

Redziejowski, R. R.

arithmetic expression, compiler design, graph theory,
programming, storage minimization, topological 
ordering,tree

4.12 5.32

CA690204 JB February 20, 1978  11:11 AM

1807	4	1934
1934	4	1934
2175	4	1934
1551	5	1934
1934	5	1934
1934	5	1934
1934	5	1934


************************

************************
Document:  CACM-1665.html
************************


Automatic Generation of Efficient Lexical
Processors Using Finite State Techniques

The practical application of the theory of
finite-state automata to automatically generate 
lexical processors is dealt with in this tutorial article
by the use of the AED RWORD system, developed 
at M. as part of the AED-1 system.  This system
accepts as input description of the multicharacter 
items or of words allowable in a language given in terms
of a subset of regular expressions. The output 
of the system is a lexical processor which reads a string
of characters and combines them in<B>to the</B> items 
as defined by the regular expressions.  Each output
item is identified by a code number together with 
a pointer to a block of storage containing the characters
and character count in the item.  The processors 
produced by the system are based on finite-state machines.
 Each state of a "machine" corresponds to 
a unique condition in the lexical processing of a character
string.  At each state a character is read, 
and the machine changes to a new state.  At each transition
appropriate actions are taken based on the 
particular character read.  The system has been in operation
since 1966, and processors generated have 
compared favorably in speed to carefully hand-coded programs
to accomplish the same task.  Lexical processors 
for AED-O and MAD are among the many which have been
produced.  The techniques employed are independent 
of the nature of the items being evaluated.  If the
word "events" is substituted for character string, 
these processors may be described as generalized decision-making
mechanisms based upon an ordered sequence 
of events.  This allows the system to be used in a
range of applications outside the area of lexical 
processing.  However convenient these advantages may
be, speed is the most important consideration.  
In designing a system for automatic generation of a
lexical processor, the goal was a processor which 
completely eliminated backup or rereading, which was nearly
as fast as hand-coded processors, which would 
analyze the language and detect errors, and
which would be convenient and easy to use.

CACM December, 1968

Johnson, W. L.
Porter, J. H.
Ackley, S. I.
Ross, D. T.

character string, compiler, finite-state automata, finite-state
machine, lexical processor, nondeterministic 
machine, parsing, plex structure, regular expressions,sequential
machine, syntactic analysis

3.63 3.75 4.12 5.22 5.24 5.31

CA681201 JB February 21, 1978  2:19 PM

1051	4	1665
1139	4	1665
1265	4	1665
1323	4	1665
1358	4	1665
1380	4	1665
1552	4	1665
1665	4	1665
1665	4	1665
1665	4	1665
1665	4	1665
1768	4	1665
1781	4	1665
1787	4	1665
1787	4	1665
1824	4	1665
1825	4	1665
1836	4	1665
1860	4	1665
1861	4	1665
1989	4	1665
2015	4	1665
2110	4	1665
2112	4	1665
2127	4	1665
2155	4	1665
2187	4	1665
2317	4	1665
2534	4	1665
2541	4	1665
2545	4	1665
2698	4	1665
2698	4	1665
2733	4	1665
2733	4	1665
2820	4	1665
3073	4	1665
3155	4	1665
763	4	1665
1665	5	1665
1665	5	1665
1665	5	1665
1781	5	1665
378	5	1665
2746	5	1665
631	5	1665
799	5	1665
1665	6	1665
1739	6	1665
2139	6	1665
2545	6	1665
2786	6	1665


************************



Automatic Generation of Efficient Lexical
Processors Using Finite State Techniques

The practical application of the <B>theory of</B>
finite-state automata to automatically generate 
lexical processors is dealt with in this tutorial article
by the use of the AED RWORD system, developed 
at M. as part of the AED-1 system.  This system
accepts as input description of the multicharacter 
items or of words allowable in a language given in terms
of a subset of regular expressions. The output 
of the system is a lexical processor which reads a string
of characters and combines them into the items 
as defined by the regular expressions.  Each output
item is identified by a code number together with 
a pointer to a block of storage containing the characters
and character count in the item.  The processors 
produced by the system are based on finite-state machines.
 Each state of a "machine" corresponds to 
a unique condition in the lexical processing of a character
string.  At each state a character is read, 
and the machine changes to a new state.  At each transition
appropriate actions are taken based on the 
particular character read.  The system has been in operation
since 1966, and processors generated have 
compared favorably in speed to carefully hand-coded programs
to accomplish the same task.  Lexical processors 
for AED-O and MAD are among the many which have been
produced.  The techniques employed are independent 
of the nature of the items being evaluated.  If the
word "events" is substituted for character string, 
these processors may be described as generalized decision-making
mechanisms based upon an ordered sequence 
of events.  This allows the system to be used in a
range of applications outside the area of lexical 
processing.  However convenient these advantages may
be, speed is the most important consideration.  
In designing a system for automatic generation of a
lexical processor, the goal was a processor which 
completely eliminated backup or rereading, which was nearly
as fast as hand-coded processors, which would 
analyze the language and detect errors, and
which would be convenient and easy to use.

CACM December, 1968

Johnson, W. L.
Porter, J. H.
Ackley, S. I.
Ross, D. T.

character string, compiler, finite-state automata, finite-state
machine, lexical processor, nondeterministic 
machine, parsing, plex structure, regular expressions,sequential
machine, syntactic analysis

3.63 3.75 4.12 5.22 5.24 5.31

CA681201 JB February 21, 1978  2:19 PM

1051	4	1665
1139	4	1665
1265	4	1665
1323	4	1665
1358	4	1665
1380	4	1665
1552	4	1665
1665	4	1665
1665	4	1665
1665	4	1665
1665	4	1665
1768	4	1665
1781	4	1665
1787	4	1665
1787	4	1665
1824	4	1665
1825	4	1665
1836	4	1665
1860	4	1665
1861	4	1665
1989	4	1665
2015	4	1665
2110	4	1665
2112	4	1665
2127	4	1665
2155	4	1665
2187	4	1665
2317	4	1665
2534	4	1665
2541	4	1665
2545	4	1665
2698	4	1665
2698	4	1665
2733	4	1665
2733	4	1665
2820	4	1665
3073	4	1665
3155	4	1665
763	4	1665
1665	5	1665
1665	5	1665
1665	5	1665
1781	5	1665
378	5	1665
2746	5	1665
631	5	1665
799	5	1665
1665	6	1665
1739	6	1665
2139	6	1665
2545	6	1665
2786	6	1665


************************

************************
Document:  CACM-1649.html
************************


Data Directed Input-Output in FORTRAN

A statement which is similar <B>to the</B> NAMELIST
statement of FORTRAN IV has been incorporated 
in the FORTRAN 63 compiler.  The FORTRAN 63 implementation
allows a greater flexibility and simplicity 
than the FORTRAN IV feature.  The Hollerith names, the
location, the mode and the dimensions of a variable 
can be discovered by means of standard FORTRAN statements.
 Methods of using this information are illustrated 
in relation to general purpose data directed input and
output routines; some other uses such as matrix 
manipulation are discussed.

CACM January, 1967

Hassitt, A.

CA670106 JB February 28, 1978  4:41 PM

1649	4	1649
1053	5	1649
1649	5	1649
1649	5	1649
1649	5	1649


************************

************************
Document:  CACM-2809.html
************************


Positivity and Norms

Following some lines of joint work with A.
S. Householder, the character and use of algebraic 
methods in the <B>theory of</B> norms is demonstrated.  New results
concerning norms with values in an Archimedian 
vector lattice (not necessarily being totally ordered)
are given, in particular for the generalization 
of order unit norms, L-norms and M-norms.  An example
of application to operator norms is given concerning 
contraction properties of positive operators.

CACM January, 1975

Bauer, F. L.

matrices, norms, positivity, numerical range, positivity
cones, vector lattice,absolute, monotonic

5.11 5.14

CA750102 JB January 12, 1978  10:56 AM

2809	5	2809
2809	5	2809
2809	5	2809


************************

************************
Document:  CACM-0099.html
************************


Possible Modifications <B>to the</B> International Algebraic Language

CACM February, 1959

Green, J.

CA590202 JB March 22, 1978  8:22 PM

99	5	99
99	5	99
99	5	99


************************

************************
Document:  CACM-2323.html
************************


Toward a General Theory of Special Functions

A list of a number of natural developments
for the field of algebraic manipulation is given. 
 Then the prospects for a general <B>theory of</B> functions
defined by ordinary differential equations are 
discussed.  The claim is made that recent developments
in mathematics indicate that it should be possible 
to algorithmically generate many properties of solutions
to differential equations.  Such a theory is 
preferable to a less general effort to make algebraic
manipulation systems knowledgeable about the usual 
special functions (e.g. exponential, hypergeometric).

CACM July, 1972

Moses, J.

algebraic manipulation, special functions, algebraic
simplification, symbolic integration, algebraic 
geometry, differential algebra

1.50 3.15 5.19 5.9

CA720705 JB January 30, 1978  3:07 PM

2164	4	2323
2170	4	2323
2323	4	2323
2323	4	2323
2323	4	2323
2719	4	2323
2167	5	2323
2164	5	2323
2170	5	2323
2323	5	2323
2323	5	2323
2323	5	2323


************************

************************
Document:  CACM-3124.html
************************


Recursive Data Structures in APL

A mathematical <B>study of</B> three approaches for defining nested
arrays in APL is presented.  Theorems exhibiting the relationships
between the definitional systems are given and illustrated through graph
representations.  One of the approaches is used to define an
APL array to be a recursive data structure equivalent to a tree structure
in which all data is stored at the leaves as homogeneous
arrays of numbers and characters.  An extension of APL is proposed that
includes new primitive functions to manipulate the nesting
level of arrays and new operators to assist in the
construction of data-driven algorithms.  

CACM February, 1979

Gull,W.
Jenkins, M.

Nested arrays, APL arrays, recursive data structures,
trees, data-driven algorithms, theory of arrays

4.22 5.29

CA790203 DH April 10, 1979  3:41 PM

2060	4	3124
2294	4	3124
2470	4	3124
3124	4	3124
1469	5	3124
3124	5	3124
3124	5	3124
3124	5	3124


************************



Recursive Data Structures in APL

A mathematical study of three approaches for defining nested
arrays in APL is presented.  Theorems exhibiting the relationships
between the definitional systems are given and illustrated through graph
representations.  One of the approaches is used to define an
APL array to be a recursive data structure equivalent to a tree structure
in which all data is stored at the leaves as homogeneous
arrays of numbers and characters.  An extension of APL is proposed that
includes new primitive functions to manipulate the nesting
level of arrays and new operators to assist in the
construction of data-driven algorithms.  

CACM February, 1979

Gull,W.
Jenkins, M.

Nested arrays, APL arrays, recursive data structures,
trees, data-driven algorithms, <B>theory of</B> arrays

4.22 5.29

CA790203 DH April 10, 1979  3:41 PM

2060	4	3124
2294	4	3124
2470	4	3124
3124	4	3124
1469	5	3124
3124	5	3124
3124	5	3124
3124	5	3124


************************

************************
Document:  CACM-2165.html
************************


General Relativity and the Application of Algebraic Manipulative Systems

The paper describes some applications of symbolic
algebra systems to problems of general relativity 
including the derivation of the field equations, the
Petrov classification of a metric, and the solution 
of the field equations in the presence of matter in
a simple case.  Attention is drawn <B>to the</B> strictly 
algebraic difficulties encountered in this work.

CACM August, 1971

Barton, D.
Fitch, J. P.

symbolic mathematics,nonnumerical mathematics, general
relativity, algebraic manipulation, equation 
manipulation

1.3 3.11 5.10

CA710807 JB February 2, 1978  2:53 PM

2165	5	2165
2165	5	2165
2165	5	2165
2170	5	2165
3071	5	2165
2165	6	2165
2165	6	2165
2167	6	2165
2166	6	2165


************************

************************
Document:  CACM-1048.html
************************


Approximate Solution of Axially Symmetric Problems

A variety of physical problems in such diverse
fields as electrostatic  field theory, heat 
and ideal fluid flow, and stress concentration theory
reduce, under the assumption of axial symmetry, 
to <B>the study</B> of an elliptic partial differential equation.
 Dirichlet-type problems associated with this 
equation are studied on regions whose boundaries include
a nondegenerate portion of the x-axis and exceedingly 
accurate numerical methods are given for approximating solutions.

CACM June, 1964

Greenspan, D.

CA640619 JB March 9, 1978  8:55 PM

1048	5	1048
1048	5	1048
1048	5	1048


************************



Approximate Solution of Axially Symmetric Problems

A variety of physical problems in such diverse
fields as electrostatic  field theory, heat 
and ideal fluid flow, and stress concentration theory
reduce, under the assumption of axial symmetry, 
<B>to the</B> study of an elliptic partial differential equation.
 Dirichlet-type problems associated with this 
equation are studied on regions whose boundaries include
a nondegenerate portion of the x-axis and exceedingly 
accurate numerical methods are given for approximating solutions.

CACM June, 1964

Greenspan, D.

CA640619 JB March 9, 1978  8:55 PM

1048	5	1048
1048	5	1048
1048	5	1048


************************



Approximate Solution of Axially Symmetric Problems

A variety of physical problems in such diverse
fields as electrostatic  field theory, heat 
and ideal fluid flow, and stress concentration theory
reduce, under the assumption of axial symmetry, 
to the <B>study of</B> an elliptic partial differential equation.
 Dirichlet-type problems associated with this 
equation are studied on regions whose boundaries include
a nondegenerate portion of the x-axis and exceedingly 
accurate numerical methods are given for approximating solutions.

CACM June, 1964

Greenspan, D.

CA640619 JB March 9, 1978  8:55 PM

1048	5	1048
1048	5	1048
1048	5	1048


************************

************************
Document:  CACM-3203.html
************************


   GRAD Assistant - A Program for Symbolic Algebraic Manipulation and 
Differentiation

   The General Recursive Algebra and Differentiation Assistant (GRAD Assistant)
now under development is a set of LISP functions which symbolically manipulate
abd differentiate algebraic expressions. It is designed for use with problemms 
in which a large amount of routine manipulation is to be done by a program 
without human intervention. Thus, GRAD must recognize necessary simplifications
without external guidance. While some complicated expressions (notably ones
involving nested radicals and trigonometric functions) do not yield completely
<B>to the</B> present version, it has proved quite useful indeed.

CACM August, 1966

Fletcher, J. G.

CA660817 ES March 17, 1982 10:10 AM

1396	5	3203
3203	5	3203
3203	5	3203
3203	5	3203
964	6	3203
1028	6	3203
1029	6	3203
1083	6	3203
1132	6	3203
1214	6	3203
1278	6	3203
1334	6	3203
1365	6	3203
1386	6	3203
1387	6	3203
1388	6	3203
1392	6	3203
1393	6	3203
1394	6	3203
1395	6	3203
1396	6	3203
1397	6	3203
1496	6	3203
284	6	3203
407	6	3203
3199	6	3203
3200	6	3203
3201	6	3203
3202	6	3203
3203	6	3203
3204	6	3203
561	6	3203
730	6	3203


************************

************************
Document:  CACM-2616.html
************************


On the Conversion of Programs to Decision Tables: Method and Objectives

The problems of converting programs to decision
tables are investigated.  Objectives of these 
conversions are mainly program debugging and optimization
in practice.  Extensions <B>to the</B> theory of computation 
and computability are suggested.

CACM August, 1974

Cavouras, J. C.

decision tables, program optimization, debugging,
semantics, theory of programming, systems analysis

4.19 4.42 4.43 5.21 5.29

CA740808 JB January 17, 1978  9:43 AM

2053	4	2616
2220	4	2616
2492	4	2616
2517	4	2616
2518	4	2616
2518	4	2616
2598	4	2616
2616	4	2616
2616	4	2616
2616	4	2616
2616	4	2616
2726	4	2616
3034	4	2616
3034	4	2616
795	4	2616
931	5	2616
1548	5	2616
1684	5	2616
2517	5	2616
2616	5	2616
2616	5	2616
2616	5	2616


************************



On the Conversion of Programs to Decision Tables: Method and Objectives

The problems of converting programs to decision
tables are investigated.  Objectives of these 
conversions are mainly program debugging and optimization
in practice.  Extensions to the <B>theory of</B> computation 
and computability are suggested.

CACM August, 1974

Cavouras, J. C.

decision tables, program optimization, debugging,
semantics, theory of programming, systems analysis

4.19 4.42 4.43 5.21 5.29

CA740808 JB January 17, 1978  9:43 AM

2053	4	2616
2220	4	2616
2492	4	2616
2517	4	2616
2518	4	2616
2518	4	2616
2598	4	2616
2616	4	2616
2616	4	2616
2616	4	2616
2616	4	2616
2726	4	2616
3034	4	2616
3034	4	2616
795	4	2616
931	5	2616
1548	5	2616
1684	5	2616
2517	5	2616
2616	5	2616
2616	5	2616
2616	5	2616


************************

************************
Document:  CACM-3012.html
************************


The Use of an Interactive Information Storage
and Retrieval System in Medical Research

This paper presents the results of a study
of the use of an interactive computerized storage 
and retrieval system.  A monitor built into the computer
system provided usage data for <B>the study</B>.  Additional 
data on user reactions were gathe red from a questionnaire.
 The results show the important role played 
by frequently chosen laboratory reference leaders in influencing
the use of this system.  The implications 
of the study for the design of similar systems are discussed.

CACM March, 1978

Lucas, Hr.

implementation, system use, information storage and retrieval system

2.10 3.50 3.72

CA780301 JB March 28, 1978  1:51 PM

3012	5	3012
3012	5	3012
3012	5	3012


************************



The Use of an Interactive Information Storage
and Retrieval System in Medical Research

This paper presents the results of a study
of the use of an interactive computerized storage 
and retrieval system.  A monitor built in<B>to the</B> computer
system provided usage data for the study.  Additional 
data on user reactions were gathe red from a questionnaire.
 The results show the important role played 
by frequently chosen laboratory reference leaders in influencing
the use of this system.  The implications 
of the study for the design of similar systems are discussed.

CACM March, 1978

Lucas, Hr.

implementation, system use, information storage and retrieval system

2.10 3.50 3.72

CA780301 JB March 28, 1978  1:51 PM

3012	5	3012
3012	5	3012
3012	5	3012


************************

************************
Document:  CACM-2932.html
************************


Complexity of Computations

The framework for research in the <B>theory of</B> complexity
of computations is described, emphasizing 
the in terrelation between seemingly diverse problems
and methods.  Illustrative examples of practical 
and theoretical significance are given.  Directions
for new research are discussed.

CACM September, 1977

Rabin, M. O.

complexity of computations, algebraic complexity,
in tractable problems, probabilistic algorithms

5.25

CA770901 JB December 28, 1977  6:54 AM

2932	5	2932
2932	5	2932
2932	5	2932


************************

************************
Document:  CACM-2327.html
************************


Toward an Automata Theory of Brains

A source of ideas for automata theory-<B>the study</B>
of the brain-has been pushed aside in mathematical 
development of the theory.  This paper suggests the ways
in which automata theory might evolve over the 
next 25 years if it is to contribute to an understanding
of how the brain processes information.

CACM July, 1972

Arbib, M. A.

automata theory, brain theory, network complexity,
resolution of redundancy of potential command, 
frog visual system, reticular formation mode selection

3.36 3.65 5.22

CA720701 JB January 30, 1978  3:46 PM

2327	5	2327
2327	5	2327
2327	5	2327


************************

************************
Document:  CACM-3189.html
************************


   An Algebraic Compiler for the FORTRAN Assembly Program

   An algebraic compiler has been written which may be added <B>to the</B> FORTRAN 
Assembly Program. This compiler will expand all algebraic statements with the 
following operations: addition, subtraction, multiplication and division. It
will compile multi-level expressions in floating-point arithmetic (this is
easily be revised to fixed-point).

CACM November, 1962

Stiegler, A. D.

CA621124 ES March 17, 1982 10:10 AM

1788	5	3189
3189	5	3189
3189	5	3189
3189	5	3189
1006	6	3189
1007	6	3189
205	6	3189
3189	6	3189


************************

************************
Document:  CACM-1678.html
************************


Automata, Formal Languages, Abstract Switching,
and Computability in a Ph. Computer Science 
Program

A number of courses are listed in the area
describe as automata, formal languages, abstract 
switching, and computability, that might be available
to a Ph. student in computer science.  A brief 
catalog description of each course is applied and the
role of each of the courses in the graduate program 
is discussed.

CACM November, 1968

McNaughton, R.

Ph. computer-science curriculum, Ph. computer
science program, automata, formal languages, 
switching theory, <B>theory of</B> computability

1.5 5.2 6.1

CA681101 JB February 21, 1978  3:16 PM

1678	5	1678
1678	5	1678
1678	5	1678
3003	5	1678
1659	6	1678
1678	6	1678
1927	6	1678
1945	6	1678
2097	6	1678
2147	6	1678
2163	6	1678
2187	6	1678
2329	6	1678
2345	6	1678
2367	6	1678
2407	6	1678
2478	6	1678
2479	6	1678
2480	6	1678
2538	6	1678


************************

************************
Document:  CACM-2580.html
************************


A Method for Composing Simple Traditional Music by Computer

A method is described for composing musical
rounds by computer.  This method uses some music 
theory plus additional heuristics.  Fundamental <B>to the</B>
method is a set of productions together with sets 
of applicability rules and weight rules which operate
on the productions deciding when and to what extent 
they are available for use.  Several rounds generated
by the computer implementation of the method are 
presented.  Generally, the resultant music sounds mediocre
to the professional although usually pleasing 
to the layman.  It appears that full-blown music theory
is not needed for rounds--all the hardware required 
for structural levels is not necessary for these pieces.
 The author has tried to address both musicians 
and computer scientists.

CACM November, 1974

Rader, G. M.

artificial intelligence, heuristic programming,
models of cognitive processes, computer music, 
computer composition, music theory, formal languages, probabilistic grammars

3.44 3.65 5.23

CA741104 JB January 16, 1978  10:35 AM

2580	5	2580
2580	5	2580
2580	5	2580


************************

************************
Document:  CACM-1867.html
************************


On the Expected Lengths of Sequences Generated
in Sorting by Replacement Selecting

In the replacement-selecting technique of sorting,
one is interested in the ratio L(j) of the 
expected length of the j-th sequence generated by the
technique <B>to the</B> number of memory cells used.  
Using complex-variable theory, it is shown that L(j)
-> 2 and that, asymptotically, the average interval 
between sign changes of L(j)-2 is 2.6662.

CACM July, 1969

Hooker, W. W.

replacement selecting, sorting, sequence lengths,
asymptotic expected length, recursion relation, 
generating function, meromorphic function

3.74 5.31

CA690713 JB February 15, 1978  6:37 PM

1867	4	1867
2272	4	1867
1638	5	1867
1867	5	1867
1867	5	1867
1867	5	1867


************************

************************
Document:  CACM-1906.html
************************


Automated Printed Circuit Routing with a Stepping Aperture

A computer program for routing interconnections
on a two-sided printed circuit board with a 
regular pattern of lines, pins (terminals), and vias
(feed-through holes) is described.  In this program, 
each interconnection is given a planned routing-typically,
down from the upper pin, through a via, and 
horizontally <B>to the</B> lower pin.  From the top, a virtual
aperture (i.e. a long horizontal slit) is stepped 
down the board.  The planned routing is the basis for
rerouting interconnections within the aperture 
to resolve conflicts for lines and vias below the aperture
and to maximize the effective line usage. 
 If a conflict has not been resolved before the aperture
arrives at the lower pin,interconnections are 
deleted to resolve the conflict.  Extensions of this technique
to the control of crosstalk between routed 
interconnections and to the problem of obtaining
100 percent interconnect are also discussed.

CACM May, 1969

Lass, S.

routing, printed circuit, interconnections, aperture,
stepping aperture, computer program, circuit 
board, lines, vias, pins

3.24 6.30

CA690503 JB February 17, 1978  3:57 PM 

1211	4	1906
1549	4	1906
1906	4	1906
2902	4	1906
1051	5	1906
1906	5	1906
1906	5	1906
1906	5	1906


************************

************************
Document:  CACM-2339.html
************************


Computer-Assigned Codes from Verbal Responses

It is often desirable to convert verbal responses
to multidigit codes. This conversion is generally 
accomplished by clerk-coders.  A study was conducted to test
the feasibility of translating verbal descriptions 
to numerical codes in a computer program.  Primary emphasis
was placed on computerized construction of 
a reference file of verbal descriptions for use by the
program.  The results of <B>the study</B> clearly show 
that such procedures are feasible.

CACM June, 1972

O'Reagan, R. T.

verbal responses, computer coding, reference list,
historical response patterns, word strings, 
concept translation, word coding

3.30 3.42 3.63 3.66 3.71 3.74 3.75 5.6

CA720606 JB January 30, 1978  4:23 PM

1112	4	2339
1592	4	2339
1592	4	2339
2111	4	2339
2111	4	2339
2111	4	2339
2339	4	2339
2339	4	2339
2339	4	2339
2339	4	2339
440	4	2339
1112	5	2339
1592	5	2339
2339	5	2339
2339	5	2339
2339	5	2339
440	5	2339
619	5	2339


************************

************************
Document:  CACM-2166.html
************************


Automated Algebraic Manipulation in Celestial Mechanics

In this paper we consider some of the applications
of automated algebraic manipulation which 
have been made in celestial mechanics.  Particular attention
is paid <B>to the</B> use of Poisson series, and 
a typical problem in perturbation theory is described.
 The requirements of processors for use in celestial 
mechanics are considered and compared with those for general
manipulation packages.  Some future directions 
for research using these systems are briefly outlined.
 To illustrate the relative simplicity of the 
algorithm required in celestial mechanics, a typical
integration problem is considered in an appendix. 

CACM August, 1971

Jefferys, W. H.

series manipulation, automated algebra, celestial mechanics

5.10 5.13 5.17

CA710806 JB February 2, 1978  3:31 PM

2166	5	2166
2166	5	2166
2166	5	2166
2170	5	2166
2165	6	2166
2167	6	2166
2166	6	2166


************************

